From patchwork Tue Feb 18 17:13:11 2020
Content-Type: text/plain; charset="utf-8"
MIME-Version: 1.0
Content-Transfer-Encoding: 7bit
X-Patchwork-Submitter: Rob Herring <robh@kernel.org>
X-Patchwork-Id: 11389125
Return-Path: <SRS0=NRU2=4G=vger.kernel.org=kvm-owner@kernel.org>
Received: from mail.kernel.org (pdx-korg-mail-1.web.codeaurora.org
 [172.30.200.123])
	by pdx-korg-patchwork-2.web.codeaurora.org (Postfix) with ESMTP id 82A2B138D
	for <patchwork-kvm@patchwork.kernel.org>;
 Tue, 18 Feb 2020 17:15:07 +0000 (UTC)
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.kernel.org (Postfix) with ESMTP id 59BF92464E
	for <patchwork-kvm@patchwork.kernel.org>;
 Tue, 18 Feb 2020 17:15:07 +0000 (UTC)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple; d=kernel.org;
	s=default; t=1582046107;
	bh=LePWQPdw0yLe3gcSpPm0E4sHYbV16oulKoL2D/G26dk=;
	h=From:To:Cc:Subject:Date:In-Reply-To:References:List-ID:From;
	b=yn54fe0qs/3SxIwkkPCWuhsQb8EWPGHPly793k9KID4ItIyER6+jP73F3GSjGQi7W
	 LijLSLMZ0bUZVctfVlUVOOSnubWq/Cj4s++AASRIXWvQTltZIRYxQ3T6TGxPR77JdY
	 H9kEn84hczgxyq8Ld1cNt/bc3LWFP9J853GG1Apc=
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S1726795AbgBRRN0 (ORCPT
        <rfc822;patchwork-kvm@patchwork.kernel.org>);
        Tue, 18 Feb 2020 12:13:26 -0500
Received: from mail-ot1-f68.google.com ([209.85.210.68]:45975 "EHLO
        mail-ot1-f68.google.com" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S1726750AbgBRRN0 (ORCPT <rfc822;kvm@vger.kernel.org>);
        Tue, 18 Feb 2020 12:13:26 -0500
Received: by mail-ot1-f68.google.com with SMTP id 59so20239284otp.12;
        Tue, 18 Feb 2020 09:13:25 -0800 (PST)
X-Google-DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
        d=1e100.net; s=20161025;
        h=x-gm-message-state:from:to:cc:subject:date:message-id:in-reply-to
         :references:mime-version:content-transfer-encoding;
        bh=4LxZR/H/qWaW6PLZe7czUDlSa5Ov9S/K1kfsaVdcFug=;
        b=Y+eIkOh/8pk4ibBhldw3l0arntaaYotKXwiF29K9P325mXl//DMJJ5zkNVaug/4nYL
         QxyS2BT+5uhwcpZtmXSQu1FoKhp0nGrIregfSKKiL08DsKekbeVrf7y2hwFGGm+4DrYo
         RHHY3XwWgBgA7d+t4bgLWfob/LcH7cJqxt6wR4zwByA4gPE13GNyqyRfOTZ8WrimDQqH
         NYgxtWncTVZP+7d/AE6vBllHbSITaEnfafPlsLurijhLCx0/L59iEL8CPkFQ3GA+2E9c
         NyzHyiIEWshdjhFRa2oJhP3OPTD42OkWPS2qTSwTfqs5WKXla0V8vUr27tdnwNMs54Yx
         nGYw==
X-Gm-Message-State: APjAAAXtoWxEyliSONOWPlZayTiwMT1c2rBDm8UveOkJaugQbWyFOT0R
        ei2xdoRadJxzUeyHpFYHMA==
X-Google-Smtp-Source: 
 APXvYqzcQiA7Kz1hw5DSMbv4x/r+JIz0TrIbtjHbvB5jqm2ONigiZ49RPglyPaLbn09y6q4zITnNIw==
X-Received: by 2002:a05:6830:1f0c:: with SMTP id
 u12mr16226750otg.253.1582046005180;
        Tue, 18 Feb 2020 09:13:25 -0800 (PST)
Received: from xps15.herring.priv (24-155-109-49.dyn.grandenetworks.net.
 [24.155.109.49])
        by smtp.googlemail.com with ESMTPSA id
 y25sm1545755oto.27.2020.02.18.09.13.23
        (version=TLS1_3 cipher=TLS_AES_256_GCM_SHA384 bits=256/256);
        Tue, 18 Feb 2020 09:13:24 -0800 (PST)
From: Rob Herring <robh@kernel.org>
To: linux-arm-kernel@lists.infradead.org, linux-kernel@vger.kernel.org,
        soc@kernel.org, Andre Przywara <andre.przywara@arm.com>,
        Robert Richter <rrichter@marvell.com>,
        Jon Loeliger <jdl@jdl.com>, Alexander Graf <graf@amazon.com>,
        Matthias Brugger <mbrugger@suse.com>,
        Mark Langsdorf <mlangsdo@redhat.com>
Cc: Alex Williamson <alex.williamson@redhat.com>,
        Borislav Petkov <bp@alien8.de>,
        Cornelia Huck <cohuck@redhat.com>,
        Daniel Lezcano <daniel.lezcano@linaro.org>,
        "David S. Miller" <davem@davemloft.net>,
        devicetree@vger.kernel.org, Eric Auger <eric.auger@redhat.com>,
        iommu@lists.linux-foundation.org,
        James Morse <james.morse@arm.com>,
        Jens Axboe <axboe@kernel.dk>, Joerg Roedel <joro@8bytes.org>,
        kvm@vger.kernel.org, linux-clk@vger.kernel.org,
        linux-edac@vger.kernel.org, linux-ide@vger.kernel.org,
        linux-pm@vger.kernel.org,
        Mauro Carvalho Chehab <mchehab@kernel.org>,
        netdev@vger.kernel.org, "Rafael J. Wysocki" <rjw@rjwysocki.net>,
        Robin Murphy <robin.murphy@arm.com>,
        Stephen Boyd <sboyd@kernel.org>,
        Tony Luck <tony.luck@intel.com>,
        Viresh Kumar <viresh.kumar@linaro.org>,
        Will Deacon <will@kernel.org>
Subject: [RFC PATCH 01/11] vfio: Remove Calxeda XGMAC reset driver
Date: Tue, 18 Feb 2020 11:13:11 -0600
Message-Id: <20200218171321.30990-2-robh@kernel.org>
X-Mailer: git-send-email 2.20.1
In-Reply-To: <20200218171321.30990-1-robh@kernel.org>
References: <20200218171321.30990-1-robh@kernel.org>
MIME-Version: 1.0
Sender: kvm-owner@vger.kernel.org
Precedence: bulk
List-ID: <kvm.vger.kernel.org>
X-Mailing-List: kvm@vger.kernel.org

Cc: Eric Auger <eric.auger@redhat.com>
Cc: Alex Williamson <alex.williamson@redhat.com>
Cc: Cornelia Huck <cohuck@redhat.com>
Cc: kvm@vger.kernel.org
Signed-off-by: Rob Herring <robh@kernel.org>
---
Do not apply yet.

 drivers/vfio/platform/reset/Kconfig           |  8 --
 drivers/vfio/platform/reset/Makefile          |  2 -
 .../reset/vfio_platform_calxedaxgmac.c        | 74 -------------------
 3 files changed, 84 deletions(-)
 delete mode 100644 drivers/vfio/platform/reset/vfio_platform_calxedaxgmac.c

--
2.20.1

diff --git a/drivers/vfio/platform/reset/Kconfig b/drivers/vfio/platform/reset/Kconfig
index 1edbe9ee7356..3668d1d92909 100644
--- a/drivers/vfio/platform/reset/Kconfig
+++ b/drivers/vfio/platform/reset/Kconfig
@@ -1,12 +1,4 @@
 # SPDX-License-Identifier: GPL-2.0-only
-config VFIO_PLATFORM_CALXEDAXGMAC_RESET
-	tristate "VFIO support for calxeda xgmac reset"
-	depends on VFIO_PLATFORM
-	help
-	  Enables the VFIO platform driver to handle reset for Calxeda xgmac
-
-	  If you don't know what to do here, say N.
-
 config VFIO_PLATFORM_AMDXGBE_RESET
 	tristate "VFIO support for AMD XGBE reset"
 	depends on VFIO_PLATFORM
diff --git a/drivers/vfio/platform/reset/Makefile b/drivers/vfio/platform/reset/Makefile
index 7294c5ea122e..be7960ce5dbc 100644
--- a/drivers/vfio/platform/reset/Makefile
+++ b/drivers/vfio/platform/reset/Makefile
@@ -1,7 +1,5 @@
 # SPDX-License-Identifier: GPL-2.0
-vfio-platform-calxedaxgmac-y := vfio_platform_calxedaxgmac.o
 vfio-platform-amdxgbe-y := vfio_platform_amdxgbe.o

-obj-$(CONFIG_VFIO_PLATFORM_CALXEDAXGMAC_RESET) += vfio-platform-calxedaxgmac.o
 obj-$(CONFIG_VFIO_PLATFORM_AMDXGBE_RESET) += vfio-platform-amdxgbe.o
 obj-$(CONFIG_VFIO_PLATFORM_BCMFLEXRM_RESET) += vfio_platform_bcmflexrm.o
diff --git a/drivers/vfio/platform/reset/vfio_platform_calxedaxgmac.c b/drivers/vfio/platform/reset/vfio_platform_calxedaxgmac.c
deleted file mode 100644
index 09a9453b75c5..000000000000
--- a/drivers/vfio/platform/reset/vfio_platform_calxedaxgmac.c
+++ /dev/null
@@ -1,74 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0-only
-/*
- * VFIO platform driver specialized for Calxeda xgmac reset
- * reset code is inherited from calxeda xgmac native driver
- *
- * Copyright 2010-2011 Calxeda, Inc.
- * Copyright (c) 2015 Linaro Ltd.
- *              www.linaro.org
- */
-
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <linux/io.h>
-
-#include "../vfio_platform_private.h"
-
-#define DRIVER_VERSION  "0.1"
-#define DRIVER_AUTHOR   "Eric Auger <eric.auger@linaro.org>"
-#define DRIVER_DESC     "Reset support for Calxeda xgmac vfio platform device"
-
-/* XGMAC Register definitions */
-#define XGMAC_CONTROL           0x00000000      /* MAC Configuration */
-
-/* DMA Control and Status Registers */
-#define XGMAC_DMA_CONTROL       0x00000f18      /* Ctrl (Operational Mode) */
-#define XGMAC_DMA_INTR_ENA      0x00000f1c      /* Interrupt Enable */
-
-/* DMA Control registe defines */
-#define DMA_CONTROL_ST          0x00002000      /* Start/Stop Transmission */
-#define DMA_CONTROL_SR          0x00000002      /* Start/Stop Receive */
-
-/* Common MAC defines */
-#define MAC_ENABLE_TX           0x00000008      /* Transmitter Enable */
-#define MAC_ENABLE_RX           0x00000004      /* Receiver Enable */
-
-static inline void xgmac_mac_disable(void __iomem *ioaddr)
-{
-	u32 value = readl(ioaddr + XGMAC_DMA_CONTROL);
-
-	value &= ~(DMA_CONTROL_ST | DMA_CONTROL_SR);
-	writel(value, ioaddr + XGMAC_DMA_CONTROL);
-
-	value = readl(ioaddr + XGMAC_CONTROL);
-	value &= ~(MAC_ENABLE_TX | MAC_ENABLE_RX);
-	writel(value, ioaddr + XGMAC_CONTROL);
-}
-
-static int vfio_platform_calxedaxgmac_reset(struct vfio_platform_device *vdev)
-{
-	struct vfio_platform_region *reg = &vdev->regions[0];
-
-	if (!reg->ioaddr) {
-		reg->ioaddr =
-			ioremap(reg->addr, reg->size);
-		if (!reg->ioaddr)
-			return -ENOMEM;
-	}
-
-	/* disable IRQ */
-	writel(0, reg->ioaddr + XGMAC_DMA_INTR_ENA);
-
-	/* Disable the MAC core */
-	xgmac_mac_disable(reg->ioaddr);
-
-	return 0;
-}
-
-module_vfio_reset_handler("calxeda,hb-xgmac", vfio_platform_calxedaxgmac_reset);
-
-MODULE_VERSION(DRIVER_VERSION);
-MODULE_LICENSE("GPL v2");
-MODULE_AUTHOR(DRIVER_AUTHOR);
-MODULE_DESCRIPTION(DRIVER_DESC);

From patchwork Tue Feb 18 17:13:12 2020
Content-Type: text/plain; charset="utf-8"
MIME-Version: 1.0
Content-Transfer-Encoding: 7bit
X-Patchwork-Submitter: Rob Herring <robh@kernel.org>
X-Patchwork-Id: 11389103
Return-Path: <SRS0=NRU2=4G=vger.kernel.org=kvm-owner@kernel.org>
Received: from mail.kernel.org (pdx-korg-mail-1.web.codeaurora.org
 [172.30.200.123])
	by pdx-korg-patchwork-2.web.codeaurora.org (Postfix) with ESMTP id 19A2B924
	for <patchwork-kvm@patchwork.kernel.org>;
 Tue, 18 Feb 2020 17:14:48 +0000 (UTC)
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.kernel.org (Postfix) with ESMTP id D52DF2465A
	for <patchwork-kvm@patchwork.kernel.org>;
 Tue, 18 Feb 2020 17:14:47 +0000 (UTC)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple; d=kernel.org;
	s=default; t=1582046088;
	bh=p5RYf9TBAgA92fDTAf+vaHyC7OQz7krvXxB4AQnSM+0=;
	h=From:To:Cc:Subject:Date:In-Reply-To:References:List-ID:From;
	b=Iawmnb/hFE6/9uW//am1Xa3mQPcR/uo+Cp0TpcRrgUv9ORCAv6KSLf9P7b1ffHdNp
	 gNNbDqhW8YEQz7oOTUBhsvLt69dut6IPcdbYx0+3eVRgYeXhRt7L4oOn+M9jSzdFKe
	 xoTdITq0q/hm9yO0RrtbwC7KCuTTV5nY4vI0XSpw=
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S1727103AbgBRRNa (ORCPT
        <rfc822;patchwork-kvm@patchwork.kernel.org>);
        Tue, 18 Feb 2020 12:13:30 -0500
Received: from mail-ot1-f65.google.com ([209.85.210.65]:38483 "EHLO
        mail-ot1-f65.google.com" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S1726963AbgBRRN3 (ORCPT <rfc822;kvm@vger.kernel.org>);
        Tue, 18 Feb 2020 12:13:29 -0500
Received: by mail-ot1-f65.google.com with SMTP id z9so20243638oth.5;
        Tue, 18 Feb 2020 09:13:27 -0800 (PST)
X-Google-DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
        d=1e100.net; s=20161025;
        h=x-gm-message-state:from:to:cc:subject:date:message-id:in-reply-to
         :references:mime-version:content-transfer-encoding;
        bh=VtNQPtbipsuMwKFOkITQFTxijny53xSg+1st3kaRJ70=;
        b=ld111lcikpM2/46lkAWhNuMOypwNEWRO9oepV/zS9j10iMou6sLI7VoTpyo2vZMP4a
         wXXET0/ajGJWumK+bB+65ot3S3QMu9Sb/szRCmcV0gpdzVz9/mkN1umV+34hVxEcBMNm
         cEWlleBBNyvhqPOftRY2AHhPhhSFwV37pDVsfkwKhjmPzDS77EET61U0hnuwUilY0e/X
         fKV7FB900uAGtm1bx1pAfQfCK7A0U7m+f4Rtc+hryJonT2rPxmSUTEhlBxqyJY6JI+39
         2lfwO1bfdl1Q4c8NPEKN/Wp8sOZevQO4USZKOAmBqkQp2D8wQNELx/lkVU+FSdzjjMc/
         17ZA==
X-Gm-Message-State: APjAAAWoJQDy6MjiyVhjdbrYWnPt6WrylxhRx92nnYdWDniTrNTdPGU2
        FDDEqZkajI0ft1S+Y+zYyg==
X-Google-Smtp-Source: 
 APXvYqxIgJEiGcrP9a/AzGpB/TQJQKJ5OUIjHj/qcJRzDQIshhUxZWM3aByoxTrV9DaB6xNB+e2CaA==
X-Received: by 2002:a05:6830:2111:: with SMTP id
 i17mr15604572otc.24.1582046007043;
        Tue, 18 Feb 2020 09:13:27 -0800 (PST)
Received: from xps15.herring.priv (24-155-109-49.dyn.grandenetworks.net.
 [24.155.109.49])
        by smtp.googlemail.com with ESMTPSA id
 y25sm1545755oto.27.2020.02.18.09.13.25
        (version=TLS1_3 cipher=TLS_AES_256_GCM_SHA384 bits=256/256);
        Tue, 18 Feb 2020 09:13:26 -0800 (PST)
From: Rob Herring <robh@kernel.org>
To: linux-arm-kernel@lists.infradead.org, linux-kernel@vger.kernel.org,
        soc@kernel.org, Andre Przywara <andre.przywara@arm.com>,
        Robert Richter <rrichter@marvell.com>,
        Jon Loeliger <jdl@jdl.com>, Alexander Graf <graf@amazon.com>,
        Matthias Brugger <mbrugger@suse.com>,
        Mark Langsdorf <mlangsdo@redhat.com>
Cc: Alex Williamson <alex.williamson@redhat.com>,
        Borislav Petkov <bp@alien8.de>,
        Cornelia Huck <cohuck@redhat.com>,
        Daniel Lezcano <daniel.lezcano@linaro.org>,
        "David S. Miller" <davem@davemloft.net>,
        devicetree@vger.kernel.org, Eric Auger <eric.auger@redhat.com>,
        iommu@lists.linux-foundation.org,
        James Morse <james.morse@arm.com>,
        Jens Axboe <axboe@kernel.dk>, Joerg Roedel <joro@8bytes.org>,
        kvm@vger.kernel.org, linux-clk@vger.kernel.org,
        linux-edac@vger.kernel.org, linux-ide@vger.kernel.org,
        linux-pm@vger.kernel.org,
        Mauro Carvalho Chehab <mchehab@kernel.org>,
        netdev@vger.kernel.org, "Rafael J. Wysocki" <rjw@rjwysocki.net>,
        Robin Murphy <robin.murphy@arm.com>,
        Stephen Boyd <sboyd@kernel.org>,
        Tony Luck <tony.luck@intel.com>,
        Viresh Kumar <viresh.kumar@linaro.org>,
        Will Deacon <will@kernel.org>
Subject: [RFC PATCH 02/11] ata: Remove Calxeda AHCI driver
Date: Tue, 18 Feb 2020 11:13:12 -0600
Message-Id: <20200218171321.30990-3-robh@kernel.org>
X-Mailer: git-send-email 2.20.1
In-Reply-To: <20200218171321.30990-1-robh@kernel.org>
References: <20200218171321.30990-1-robh@kernel.org>
MIME-Version: 1.0
Sender: kvm-owner@vger.kernel.org
Precedence: bulk
List-ID: <kvm.vger.kernel.org>
X-Mailing-List: kvm@vger.kernel.org

Cc: Jens Axboe <axboe@kernel.dk>
Cc: linux-ide@vger.kernel.org
Signed-off-by: Rob Herring <robh@kernel.org>
---
Do not apply yet.

 drivers/ata/Kconfig         |   9 -
 drivers/ata/Makefile        |   1 -
 drivers/ata/sata_highbank.c | 635 ------------------------------------
 3 files changed, 645 deletions(-)
 delete mode 100644 drivers/ata/sata_highbank.c

--
2.20.1

diff --git a/drivers/ata/Kconfig b/drivers/ata/Kconfig
index a6beb2c5a692..687ddd9f4188 100644
--- a/drivers/ata/Kconfig
+++ b/drivers/ata/Kconfig
@@ -395,15 +395,6 @@ config SATA_DWC_VDEBUG
 	help
 	  This option enables the taskfile dumping and NCQ debugging.

-config SATA_HIGHBANK
-	tristate "Calxeda Highbank SATA support"
-	depends on ARCH_HIGHBANK || COMPILE_TEST
-	help
-	  This option enables support for the Calxeda Highbank SoC's
-	  onboard SATA.
-
-	  If unsure, say N.
-
 config SATA_MV
 	tristate "Marvell SATA support"
 	depends on PCI || ARCH_DOVE || ARCH_MV78XX0 || \
diff --git a/drivers/ata/Makefile b/drivers/ata/Makefile
index d8cc2e04a6c7..08f26d674ed7 100644
--- a/drivers/ata/Makefile
+++ b/drivers/ata/Makefile
@@ -12,7 +12,6 @@ obj-$(CONFIG_SATA_GEMINI)	+= sata_gemini.o
 obj-$(CONFIG_SATA_INIC162X)	+= sata_inic162x.o
 obj-$(CONFIG_SATA_SIL24)	+= sata_sil24.o
 obj-$(CONFIG_SATA_DWC)		+= sata_dwc_460ex.o
-obj-$(CONFIG_SATA_HIGHBANK)	+= sata_highbank.o libahci.o
 obj-$(CONFIG_AHCI_BRCM)		+= ahci_brcm.o libahci.o libahci_platform.o
 obj-$(CONFIG_AHCI_CEVA)		+= ahci_ceva.o libahci.o libahci_platform.o
 obj-$(CONFIG_AHCI_DA850)	+= ahci_da850.o libahci.o libahci_platform.o
diff --git a/drivers/ata/sata_highbank.c b/drivers/ata/sata_highbank.c
deleted file mode 100644
index ad3893c62572..000000000000
--- a/drivers/ata/sata_highbank.c
+++ /dev/null
@@ -1,635 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0-only
-/*
- * Calxeda Highbank AHCI SATA platform driver
- * Copyright 2012 Calxeda, Inc.
- *
- * based on the AHCI SATA platform driver by Jeff Garzik and Anton Vorontsov
- */
-#include <linux/kernel.h>
-#include <linux/gfp.h>
-#include <linux/module.h>
-#include <linux/types.h>
-#include <linux/err.h>
-#include <linux/io.h>
-#include <linux/spinlock.h>
-#include <linux/device.h>
-#include <linux/of_device.h>
-#include <linux/of_address.h>
-#include <linux/platform_device.h>
-#include <linux/libata.h>
-#include <linux/interrupt.h>
-#include <linux/delay.h>
-#include <linux/export.h>
-#include <linux/gpio/consumer.h>
-
-#include "ahci.h"
-
-#define CPHY_MAP(dev, addr) ((((dev) & 0x1f) << 7) | (((addr) >> 9) & 0x7f))
-#define CPHY_ADDR(addr) (((addr) & 0x1ff) << 2)
-#define SERDES_CR_CTL			0x80a0
-#define SERDES_CR_ADDR			0x80a1
-#define SERDES_CR_DATA			0x80a2
-#define CR_BUSY				0x0001
-#define CR_START			0x0001
-#define CR_WR_RDN			0x0002
-#define CPHY_TX_INPUT_STS		0x2001
-#define CPHY_RX_INPUT_STS		0x2002
-#define CPHY_SATA_TX_OVERRIDE		0x8000
-#define CPHY_SATA_RX_OVERRIDE	 	0x4000
-#define CPHY_TX_OVERRIDE		0x2004
-#define CPHY_RX_OVERRIDE		0x2005
-#define SPHY_LANE			0x100
-#define SPHY_HALF_RATE			0x0001
-#define CPHY_SATA_DPLL_MODE		0x0700
-#define CPHY_SATA_DPLL_SHIFT		8
-#define CPHY_SATA_DPLL_RESET		(1 << 11)
-#define CPHY_SATA_TX_ATTEN		0x1c00
-#define CPHY_SATA_TX_ATTEN_SHIFT	10
-#define CPHY_PHY_COUNT			6
-#define CPHY_LANE_COUNT			4
-#define CPHY_PORT_COUNT			(CPHY_PHY_COUNT * CPHY_LANE_COUNT)
-
-static DEFINE_SPINLOCK(cphy_lock);
-/* Each of the 6 phys can have up to 4 sata ports attached to i. Map 0-based
- * sata ports to their phys and then to their lanes within the phys
- */
-struct phy_lane_info {
-	void __iomem *phy_base;
-	u8 lane_mapping;
-	u8 phy_devs;
-	u8 tx_atten;
-};
-static struct phy_lane_info port_data[CPHY_PORT_COUNT];
-
-static DEFINE_SPINLOCK(sgpio_lock);
-#define SCLOCK				0
-#define SLOAD				1
-#define SDATA				2
-#define SGPIO_PINS			3
-#define SGPIO_PORTS			8
-
-struct ecx_plat_data {
-	u32		n_ports;
-	/* number of extra clocks that the SGPIO PIC controller expects */
-	u32		pre_clocks;
-	u32		post_clocks;
-	struct gpio_desc *sgpio_gpiod[SGPIO_PINS];
-	u32		sgpio_pattern;
-	u32		port_to_sgpio[SGPIO_PORTS];
-};
-
-#define SGPIO_SIGNALS			3
-#define ECX_ACTIVITY_BITS		0x300000
-#define ECX_ACTIVITY_SHIFT		0
-#define ECX_LOCATE_BITS			0x80000
-#define ECX_LOCATE_SHIFT		1
-#define ECX_FAULT_BITS			0x400000
-#define ECX_FAULT_SHIFT			2
-static inline int sgpio_bit_shift(struct ecx_plat_data *pdata, u32 port,
-				u32 shift)
-{
-	return 1 << (3 * pdata->port_to_sgpio[port] + shift);
-}
-
-static void ecx_parse_sgpio(struct ecx_plat_data *pdata, u32 port, u32 state)
-{
-	if (state & ECX_ACTIVITY_BITS)
-		pdata->sgpio_pattern |= sgpio_bit_shift(pdata, port,
-						ECX_ACTIVITY_SHIFT);
-	else
-		pdata->sgpio_pattern &= ~sgpio_bit_shift(pdata, port,
-						ECX_ACTIVITY_SHIFT);
-	if (state & ECX_LOCATE_BITS)
-		pdata->sgpio_pattern |= sgpio_bit_shift(pdata, port,
-						ECX_LOCATE_SHIFT);
-	else
-		pdata->sgpio_pattern &= ~sgpio_bit_shift(pdata, port,
-						ECX_LOCATE_SHIFT);
-	if (state & ECX_FAULT_BITS)
-		pdata->sgpio_pattern |= sgpio_bit_shift(pdata, port,
-						ECX_FAULT_SHIFT);
-	else
-		pdata->sgpio_pattern &= ~sgpio_bit_shift(pdata, port,
-						ECX_FAULT_SHIFT);
-}
-
-/*
- * Tell the LED controller that the signal has changed by raising the clock
- * line for 50 uS and then lowering it for 50 uS.
- */
-static void ecx_led_cycle_clock(struct ecx_plat_data *pdata)
-{
-	gpiod_set_value(pdata->sgpio_gpiod[SCLOCK], 1);
-	udelay(50);
-	gpiod_set_value(pdata->sgpio_gpiod[SCLOCK], 0);
-	udelay(50);
-}
-
-static ssize_t ecx_transmit_led_message(struct ata_port *ap, u32 state,
-					ssize_t size)
-{
-	struct ahci_host_priv *hpriv =  ap->host->private_data;
-	struct ecx_plat_data *pdata = hpriv->plat_data;
-	struct ahci_port_priv *pp = ap->private_data;
-	unsigned long flags;
-	int pmp, i;
-	struct ahci_em_priv *emp;
-	u32 sgpio_out;
-
-	/* get the slot number from the message */
-	pmp = (state & EM_MSG_LED_PMP_SLOT) >> 8;
-	if (pmp < EM_MAX_SLOTS)
-		emp = &pp->em_priv[pmp];
-	else
-		return -EINVAL;
-
-	if (!(hpriv->em_msg_type & EM_MSG_TYPE_LED))
-		return size;
-
-	spin_lock_irqsave(&sgpio_lock, flags);
-	ecx_parse_sgpio(pdata, ap->port_no, state);
-	sgpio_out = pdata->sgpio_pattern;
-	for (i = 0; i < pdata->pre_clocks; i++)
-		ecx_led_cycle_clock(pdata);
-
-	gpiod_set_value(pdata->sgpio_gpiod[SLOAD], 1);
-	ecx_led_cycle_clock(pdata);
-	gpiod_set_value(pdata->sgpio_gpiod[SLOAD], 0);
-	/*
-	 * bit-bang out the SGPIO pattern, by consuming a bit and then
-	 * clocking it out.
-	 */
-	for (i = 0; i < (SGPIO_SIGNALS * pdata->n_ports); i++) {
-		gpiod_set_value(pdata->sgpio_gpiod[SDATA], sgpio_out & 1);
-		sgpio_out >>= 1;
-		ecx_led_cycle_clock(pdata);
-	}
-	for (i = 0; i < pdata->post_clocks; i++)
-		ecx_led_cycle_clock(pdata);
-
-	/* save off new led state for port/slot */
-	emp->led_state = state;
-
-	spin_unlock_irqrestore(&sgpio_lock, flags);
-	return size;
-}
-
-static void highbank_set_em_messages(struct device *dev,
-					struct ahci_host_priv *hpriv,
-					struct ata_port_info *pi)
-{
-	struct device_node *np = dev->of_node;
-	struct ecx_plat_data *pdata = hpriv->plat_data;
-	int i;
-
-	for (i = 0; i < SGPIO_PINS; i++) {
-		struct gpio_desc *gpiod;
-
-		gpiod = devm_gpiod_get_index(dev, "calxeda,sgpio", i,
-					     GPIOD_OUT_HIGH);
-		if (IS_ERR(gpiod)) {
-			dev_err(dev, "failed to get GPIO %d\n", i);
-			continue;
-		}
-		gpiod_set_consumer_name(gpiod, "CX SGPIO");
-
-		pdata->sgpio_gpiod[i] = gpiod;
-	}
-	of_property_read_u32_array(np, "calxeda,led-order",
-						pdata->port_to_sgpio,
-						pdata->n_ports);
-	if (of_property_read_u32(np, "calxeda,pre-clocks", &pdata->pre_clocks))
-		pdata->pre_clocks = 0;
-	if (of_property_read_u32(np, "calxeda,post-clocks",
-				&pdata->post_clocks))
-		pdata->post_clocks = 0;
-
-	/* store em_loc */
-	hpriv->em_loc = 0;
-	hpriv->em_buf_sz = 4;
-	hpriv->em_msg_type = EM_MSG_TYPE_LED;
-	pi->flags |= ATA_FLAG_EM | ATA_FLAG_SW_ACTIVITY;
-}
-
-static u32 __combo_phy_reg_read(u8 sata_port, u32 addr)
-{
-	u32 data;
-	u8 dev = port_data[sata_port].phy_devs;
-	spin_lock(&cphy_lock);
-	writel(CPHY_MAP(dev, addr), port_data[sata_port].phy_base + 0x800);
-	data = readl(port_data[sata_port].phy_base + CPHY_ADDR(addr));
-	spin_unlock(&cphy_lock);
-	return data;
-}
-
-static void __combo_phy_reg_write(u8 sata_port, u32 addr, u32 data)
-{
-	u8 dev = port_data[sata_port].phy_devs;
-	spin_lock(&cphy_lock);
-	writel(CPHY_MAP(dev, addr), port_data[sata_port].phy_base + 0x800);
-	writel(data, port_data[sata_port].phy_base + CPHY_ADDR(addr));
-	spin_unlock(&cphy_lock);
-}
-
-static void combo_phy_wait_for_ready(u8 sata_port)
-{
-	while (__combo_phy_reg_read(sata_port, SERDES_CR_CTL) & CR_BUSY)
-		udelay(5);
-}
-
-static u32 combo_phy_read(u8 sata_port, u32 addr)
-{
-	combo_phy_wait_for_ready(sata_port);
-	__combo_phy_reg_write(sata_port, SERDES_CR_ADDR, addr);
-	__combo_phy_reg_write(sata_port, SERDES_CR_CTL, CR_START);
-	combo_phy_wait_for_ready(sata_port);
-	return __combo_phy_reg_read(sata_port, SERDES_CR_DATA);
-}
-
-static void combo_phy_write(u8 sata_port, u32 addr, u32 data)
-{
-	combo_phy_wait_for_ready(sata_port);
-	__combo_phy_reg_write(sata_port, SERDES_CR_ADDR, addr);
-	__combo_phy_reg_write(sata_port, SERDES_CR_DATA, data);
-	__combo_phy_reg_write(sata_port, SERDES_CR_CTL, CR_WR_RDN | CR_START);
-}
-
-static void highbank_cphy_disable_overrides(u8 sata_port)
-{
-	u8 lane = port_data[sata_port].lane_mapping;
-	u32 tmp;
-	if (unlikely(port_data[sata_port].phy_base == NULL))
-		return;
-	tmp = combo_phy_read(sata_port, CPHY_RX_INPUT_STS + lane * SPHY_LANE);
-	tmp &= ~CPHY_SATA_RX_OVERRIDE;
-	combo_phy_write(sata_port, CPHY_RX_OVERRIDE + lane * SPHY_LANE, tmp);
-}
-
-static void cphy_override_tx_attenuation(u8 sata_port, u32 val)
-{
-	u8 lane = port_data[sata_port].lane_mapping;
-	u32 tmp;
-
-	if (val & 0x8)
-		return;
-
-	tmp = combo_phy_read(sata_port, CPHY_TX_INPUT_STS + lane * SPHY_LANE);
-	tmp &= ~CPHY_SATA_TX_OVERRIDE;
-	combo_phy_write(sata_port, CPHY_TX_OVERRIDE + lane * SPHY_LANE, tmp);
-
-	tmp |= CPHY_SATA_TX_OVERRIDE;
-	combo_phy_write(sata_port, CPHY_TX_OVERRIDE + lane * SPHY_LANE, tmp);
-
-	tmp |= (val << CPHY_SATA_TX_ATTEN_SHIFT) & CPHY_SATA_TX_ATTEN;
-	combo_phy_write(sata_port, CPHY_TX_OVERRIDE + lane * SPHY_LANE, tmp);
-}
-
-static void cphy_override_rx_mode(u8 sata_port, u32 val)
-{
-	u8 lane = port_data[sata_port].lane_mapping;
-	u32 tmp;
-	tmp = combo_phy_read(sata_port, CPHY_RX_INPUT_STS + lane * SPHY_LANE);
-	tmp &= ~CPHY_SATA_RX_OVERRIDE;
-	combo_phy_write(sata_port, CPHY_RX_OVERRIDE + lane * SPHY_LANE, tmp);
-
-	tmp |= CPHY_SATA_RX_OVERRIDE;
-	combo_phy_write(sata_port, CPHY_RX_OVERRIDE + lane * SPHY_LANE, tmp);
-
-	tmp &= ~CPHY_SATA_DPLL_MODE;
-	tmp |= val << CPHY_SATA_DPLL_SHIFT;
-	combo_phy_write(sata_port, CPHY_RX_OVERRIDE + lane * SPHY_LANE, tmp);
-
-	tmp |= CPHY_SATA_DPLL_RESET;
-	combo_phy_write(sata_port, CPHY_RX_OVERRIDE + lane * SPHY_LANE, tmp);
-
-	tmp &= ~CPHY_SATA_DPLL_RESET;
-	combo_phy_write(sata_port, CPHY_RX_OVERRIDE + lane * SPHY_LANE, tmp);
-
-	msleep(15);
-}
-
-static void highbank_cphy_override_lane(u8 sata_port)
-{
-	u8 lane = port_data[sata_port].lane_mapping;
-	u32 tmp, k = 0;
-
-	if (unlikely(port_data[sata_port].phy_base == NULL))
-		return;
-	do {
-		tmp = combo_phy_read(sata_port, CPHY_RX_INPUT_STS +
-						lane * SPHY_LANE);
-	} while ((tmp & SPHY_HALF_RATE) && (k++ < 1000));
-	cphy_override_rx_mode(sata_port, 3);
-	cphy_override_tx_attenuation(sata_port, port_data[sata_port].tx_atten);
-}
-
-static int highbank_initialize_phys(struct device *dev, void __iomem *addr)
-{
-	struct device_node *sata_node = dev->of_node;
-	int phy_count = 0, phy, port = 0, i;
-	void __iomem *cphy_base[CPHY_PHY_COUNT] = {};
-	struct device_node *phy_nodes[CPHY_PHY_COUNT] = {};
-	u32 tx_atten[CPHY_PORT_COUNT] = {};
-
-	memset(port_data, 0, sizeof(struct phy_lane_info) * CPHY_PORT_COUNT);
-
-	do {
-		u32 tmp;
-		struct of_phandle_args phy_data;
-		if (of_parse_phandle_with_args(sata_node,
-				"calxeda,port-phys", "#phy-cells",
-				port, &phy_data))
-			break;
-		for (phy = 0; phy < phy_count; phy++) {
-			if (phy_nodes[phy] == phy_data.np)
-				break;
-		}
-		if (phy_nodes[phy] == NULL) {
-			phy_nodes[phy] = phy_data.np;
-			cphy_base[phy] = of_iomap(phy_nodes[phy], 0);
-			if (cphy_base[phy] == NULL) {
-				return 0;
-			}
-			phy_count += 1;
-		}
-		port_data[port].lane_mapping = phy_data.args[0];
-		of_property_read_u32(phy_nodes[phy], "phydev", &tmp);
-		port_data[port].phy_devs = tmp;
-		port_data[port].phy_base = cphy_base[phy];
-		of_node_put(phy_data.np);
-		port += 1;
-	} while (port < CPHY_PORT_COUNT);
-	of_property_read_u32_array(sata_node, "calxeda,tx-atten",
-				tx_atten, port);
-	for (i = 0; i < port; i++)
-		port_data[i].tx_atten = (u8) tx_atten[i];
-	return 0;
-}
-
-/*
- * The Calxeda SATA phy intermittently fails to bring up a link with Gen3
- * Retrying the phy hard reset can work around the issue, but the drive
- * may fail again. In less than 150 out of 15000 test runs, it took more
- * than 10 tries for the link to be established (but never more than 35).
- * Triple the maximum observed retry count to provide plenty of margin for
- * rare events and to guarantee that the link is established.
- *
- * Also, the default 2 second time-out on a failed drive is too long in
- * this situation. The uboot implementation of the same driver function
- * uses a much shorter time-out period and never experiences a time out
- * issue. Reducing the time-out to 500ms improves the responsiveness.
- * The other timing constants were kept the same as the stock AHCI driver.
- * This change was also tested 15000 times on 24 drives and none of them
- * experienced a time out.
- */
-static int ahci_highbank_hardreset(struct ata_link *link, unsigned int *class,
-				unsigned long deadline)
-{
-	static const unsigned long timing[] = { 5, 100, 500};
-	struct ata_port *ap = link->ap;
-	struct ahci_port_priv *pp = ap->private_data;
-	struct ahci_host_priv *hpriv = ap->host->private_data;
-	u8 *d2h_fis = pp->rx_fis + RX_FIS_D2H_REG;
-	struct ata_taskfile tf;
-	bool online;
-	u32 sstatus;
-	int rc;
-	int retry = 100;
-
-	hpriv->stop_engine(ap);
-
-	/* clear D2H reception area to properly wait for D2H FIS */
-	ata_tf_init(link->device, &tf);
-	tf.command = ATA_BUSY;
-	ata_tf_to_fis(&tf, 0, 0, d2h_fis);
-
-	do {
-		highbank_cphy_disable_overrides(link->ap->port_no);
-		rc = sata_link_hardreset(link, timing, deadline, &online, NULL);
-		highbank_cphy_override_lane(link->ap->port_no);
-
-		/* If the status is 1, we are connected, but the link did not
-		 * come up. So retry resetting the link again.
-		 */
-		if (sata_scr_read(link, SCR_STATUS, &sstatus))
-			break;
-		if (!(sstatus & 0x3))
-			break;
-	} while (!online && retry--);
-
-	hpriv->start_engine(ap);
-
-	if (online)
-		*class = ahci_dev_classify(ap);
-
-	return rc;
-}
-
-static struct ata_port_operations ahci_highbank_ops = {
-	.inherits		= &ahci_ops,
-	.hardreset		= ahci_highbank_hardreset,
-	.transmit_led_message   = ecx_transmit_led_message,
-};
-
-static const struct ata_port_info ahci_highbank_port_info = {
-	.flags          = AHCI_FLAG_COMMON,
-	.pio_mask       = ATA_PIO4,
-	.udma_mask      = ATA_UDMA6,
-	.port_ops       = &ahci_highbank_ops,
-};
-
-static struct scsi_host_template ahci_highbank_platform_sht = {
-	AHCI_SHT("sata_highbank"),
-};
-
-static const struct of_device_id ahci_of_match[] = {
-	{ .compatible = "calxeda,hb-ahci" },
-	{},
-};
-MODULE_DEVICE_TABLE(of, ahci_of_match);
-
-static int ahci_highbank_probe(struct platform_device *pdev)
-{
-	struct device *dev = &pdev->dev;
-	struct ahci_host_priv *hpriv;
-	struct ecx_plat_data *pdata;
-	struct ata_host *host;
-	struct resource *mem;
-	int irq;
-	int i;
-	int rc;
-	u32 n_ports;
-	struct ata_port_info pi = ahci_highbank_port_info;
-	const struct ata_port_info *ppi[] = { &pi, NULL };
-
-	mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	if (!mem) {
-		dev_err(dev, "no mmio space\n");
-		return -EINVAL;
-	}
-
-	irq = platform_get_irq(pdev, 0);
-	if (irq <= 0) {
-		dev_err(dev, "no irq\n");
-		return -EINVAL;
-	}
-
-	hpriv = devm_kzalloc(dev, sizeof(*hpriv), GFP_KERNEL);
-	if (!hpriv) {
-		dev_err(dev, "can't alloc ahci_host_priv\n");
-		return -ENOMEM;
-	}
-	pdata = devm_kzalloc(dev, sizeof(*pdata), GFP_KERNEL);
-	if (!pdata) {
-		dev_err(dev, "can't alloc ecx_plat_data\n");
-		return -ENOMEM;
-	}
-
-	hpriv->irq = irq;
-	hpriv->flags |= (unsigned long)pi.private_data;
-
-	hpriv->mmio = devm_ioremap(dev, mem->start, resource_size(mem));
-	if (!hpriv->mmio) {
-		dev_err(dev, "can't map %pR\n", mem);
-		return -ENOMEM;
-	}
-
-	rc = highbank_initialize_phys(dev, hpriv->mmio);
-	if (rc)
-		return rc;
-
-
-	ahci_save_initial_config(dev, hpriv);
-
-	/* prepare host */
-	if (hpriv->cap & HOST_CAP_NCQ)
-		pi.flags |= ATA_FLAG_NCQ;
-
-	if (hpriv->cap & HOST_CAP_PMP)
-		pi.flags |= ATA_FLAG_PMP;
-
-	if (hpriv->cap & HOST_CAP_64)
-		dma_set_coherent_mask(dev, DMA_BIT_MASK(64));
-
-	/* CAP.NP sometimes indicate the index of the last enabled
-	 * port, at other times, that of the last possible port, so
-	 * determining the maximum port number requires looking at
-	 * both CAP.NP and port_map.
-	 */
-	n_ports = max(ahci_nr_ports(hpriv->cap), fls(hpriv->port_map));
-
-	pdata->n_ports = n_ports;
-	hpriv->plat_data = pdata;
-	highbank_set_em_messages(dev, hpriv, &pi);
-
-	host = ata_host_alloc_pinfo(dev, ppi, n_ports);
-	if (!host) {
-		rc = -ENOMEM;
-		goto err0;
-	}
-
-	host->private_data = hpriv;
-
-	if (!(hpriv->cap & HOST_CAP_SSS) || ahci_ignore_sss)
-		host->flags |= ATA_HOST_PARALLEL_SCAN;
-
-	for (i = 0; i < host->n_ports; i++) {
-		struct ata_port *ap = host->ports[i];
-
-		ata_port_desc(ap, "mmio %pR", mem);
-		ata_port_desc(ap, "port 0x%x", 0x100 + ap->port_no * 0x80);
-
-		/* set enclosure management message type */
-		if (ap->flags & ATA_FLAG_EM)
-			ap->em_message_type = hpriv->em_msg_type;
-
-		/* disabled/not-implemented port */
-		if (!(hpriv->port_map & (1 << i)))
-			ap->ops = &ata_dummy_port_ops;
-	}
-
-	rc = ahci_reset_controller(host);
-	if (rc)
-		goto err0;
-
-	ahci_init_controller(host);
-	ahci_print_info(host, "platform");
-
-	rc = ahci_host_activate(host, &ahci_highbank_platform_sht);
-	if (rc)
-		goto err0;
-
-	return 0;
-err0:
-	return rc;
-}
-
-#ifdef CONFIG_PM_SLEEP
-static int ahci_highbank_suspend(struct device *dev)
-{
-	struct ata_host *host = dev_get_drvdata(dev);
-	struct ahci_host_priv *hpriv = host->private_data;
-	void __iomem *mmio = hpriv->mmio;
-	u32 ctl;
-	int rc;
-
-	if (hpriv->flags & AHCI_HFLAG_NO_SUSPEND) {
-		dev_err(dev, "firmware update required for suspend/resume\n");
-		return -EIO;
-	}
-
-	/*
-	 * AHCI spec rev1.1 section 8.3.3:
-	 * Software must disable interrupts prior to requesting a
-	 * transition of the HBA to D3 state.
-	 */
-	ctl = readl(mmio + HOST_CTL);
-	ctl &= ~HOST_IRQ_EN;
-	writel(ctl, mmio + HOST_CTL);
-	readl(mmio + HOST_CTL); /* flush */
-
-	rc = ata_host_suspend(host, PMSG_SUSPEND);
-	if (rc)
-		return rc;
-
-	return 0;
-}
-
-static int ahci_highbank_resume(struct device *dev)
-{
-	struct ata_host *host = dev_get_drvdata(dev);
-	int rc;
-
-	if (dev->power.power_state.event == PM_EVENT_SUSPEND) {
-		rc = ahci_reset_controller(host);
-		if (rc)
-			return rc;
-
-		ahci_init_controller(host);
-	}
-
-	ata_host_resume(host);
-
-	return 0;
-}
-#endif
-
-static SIMPLE_DEV_PM_OPS(ahci_highbank_pm_ops,
-		  ahci_highbank_suspend, ahci_highbank_resume);
-
-static struct platform_driver ahci_highbank_driver = {
-	.remove = ata_platform_remove_one,
-        .driver = {
-                .name = "highbank-ahci",
-                .of_match_table = ahci_of_match,
-                .pm = &ahci_highbank_pm_ops,
-        },
-	.probe = ahci_highbank_probe,
-};
-
-module_platform_driver(ahci_highbank_driver);
-
-MODULE_DESCRIPTION("Calxeda Highbank AHCI SATA platform driver");
-MODULE_AUTHOR("Mark Langsdorf <mark.langsdorf@calxeda.com>");
-MODULE_LICENSE("GPL");
-MODULE_ALIAS("sata:highbank");

From patchwork Tue Feb 18 17:13:13 2020
Content-Type: text/plain; charset="utf-8"
MIME-Version: 1.0
Content-Transfer-Encoding: 7bit
X-Patchwork-Submitter: Rob Herring <robh@kernel.org>
X-Patchwork-Id: 11389111
Return-Path: <SRS0=NRU2=4G=vger.kernel.org=kvm-owner@kernel.org>
Received: from mail.kernel.org (pdx-korg-mail-1.web.codeaurora.org
 [172.30.200.123])
	by pdx-korg-patchwork-2.web.codeaurora.org (Postfix) with ESMTP id D6E93924
	for <patchwork-kvm@patchwork.kernel.org>;
 Tue, 18 Feb 2020 17:14:50 +0000 (UTC)
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.kernel.org (Postfix) with ESMTP id AF7E02465A
	for <patchwork-kvm@patchwork.kernel.org>;
 Tue, 18 Feb 2020 17:14:50 +0000 (UTC)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple; d=kernel.org;
	s=default; t=1582046090;
	bh=Es9N/A91dwDdIYeYVwDpx/CM30oJw39xtMBR/k8LVOk=;
	h=From:To:Cc:Subject:Date:In-Reply-To:References:List-ID:From;
	b=yMpMk8jW0vgMr73U7fwfD2pp5tz/w5tpZnsThILS/dEXvFH7AhjtVhCAO3Fzvzcl/
	 BLz+By4Z9XeK/3CEicTtaE5Hhxj5ukhhSibUw0we2yVEy3Zh9LCOHnRf7VBACmTd2s
	 qDa3M42kzNt290CHlZKotzS8Y1IKjGQxMjhW9JBI=
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S1726891AbgBRROu (ORCPT
        <rfc822;patchwork-kvm@patchwork.kernel.org>);
        Tue, 18 Feb 2020 12:14:50 -0500
Received: from mail-ot1-f65.google.com ([209.85.210.65]:41620 "EHLO
        mail-ot1-f65.google.com" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S1726697AbgBRRNa (ORCPT <rfc822;kvm@vger.kernel.org>);
        Tue, 18 Feb 2020 12:13:30 -0500
Received: by mail-ot1-f65.google.com with SMTP id r27so20205783otc.8;
        Tue, 18 Feb 2020 09:13:29 -0800 (PST)
X-Google-DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
        d=1e100.net; s=20161025;
        h=x-gm-message-state:from:to:cc:subject:date:message-id:in-reply-to
         :references:mime-version:content-transfer-encoding;
        bh=W1u4wUo3NLYAMgXHhQ1JWTN6DImeyb7sdgcLty9LTVA=;
        b=pfon4pEJFXFUO0/WW0e/mDSzqxwQbhkJdAEHT5a7xHkvoi1vlN8kOGS7GIGU829JOD
         +ygDH7eavAPibknYtWBXNd9jH0HwVIj0OyAHtrFUiXi6M0B7xVhslKavM/7uaebmLNOP
         iBSHcoPArr/kMcFRDT3gLBPcK9jqSCPaLMzQbTkcM8xGr1FPJvWGprIF60Q5dB++fMcc
         NaVSCHOxgrenzVyUx1tlr40ZkzHQNdOc6jamdBiMmNYip1kR0bQcpTYxIkbcpcJhWIUd
         kjAw+/zQyUzHoC7kYEBRf7QFNQbVlwIqhtkDt94woigkJhTa97CttC41Z9Brl4zceuTk
         EKHg==
X-Gm-Message-State: APjAAAUlzTSO2PKgoKuxg6frM8ruhq1NOg9pBCr4op2XQ3FY5qfCdHJ0
        Y2ib8BYyVGwd1mWOgM9YYg==
X-Google-Smtp-Source: 
 APXvYqz9vN5O196Hv3RX5j5QhodRWeWR1h2DBkM3xAqkcK92U7nZEFBLzVra3Zyy0nvATVFM6CGklA==
X-Received: by 2002:a9d:7a89:: with SMTP id l9mr15588431otn.228.1582046008709;
        Tue, 18 Feb 2020 09:13:28 -0800 (PST)
Received: from xps15.herring.priv (24-155-109-49.dyn.grandenetworks.net.
 [24.155.109.49])
        by smtp.googlemail.com with ESMTPSA id
 y25sm1545755oto.27.2020.02.18.09.13.27
        (version=TLS1_3 cipher=TLS_AES_256_GCM_SHA384 bits=256/256);
        Tue, 18 Feb 2020 09:13:28 -0800 (PST)
From: Rob Herring <robh@kernel.org>
To: linux-arm-kernel@lists.infradead.org, linux-kernel@vger.kernel.org,
        soc@kernel.org, Andre Przywara <andre.przywara@arm.com>,
        Robert Richter <rrichter@marvell.com>,
        Jon Loeliger <jdl@jdl.com>, Alexander Graf <graf@amazon.com>,
        Matthias Brugger <mbrugger@suse.com>,
        Mark Langsdorf <mlangsdo@redhat.com>
Cc: Alex Williamson <alex.williamson@redhat.com>,
        Borislav Petkov <bp@alien8.de>,
        Cornelia Huck <cohuck@redhat.com>,
        Daniel Lezcano <daniel.lezcano@linaro.org>,
        "David S. Miller" <davem@davemloft.net>,
        devicetree@vger.kernel.org, Eric Auger <eric.auger@redhat.com>,
        iommu@lists.linux-foundation.org,
        James Morse <james.morse@arm.com>,
        Jens Axboe <axboe@kernel.dk>, Joerg Roedel <joro@8bytes.org>,
        kvm@vger.kernel.org, linux-clk@vger.kernel.org,
        linux-edac@vger.kernel.org, linux-ide@vger.kernel.org,
        linux-pm@vger.kernel.org,
        Mauro Carvalho Chehab <mchehab@kernel.org>,
        netdev@vger.kernel.org, "Rafael J. Wysocki" <rjw@rjwysocki.net>,
        Robin Murphy <robin.murphy@arm.com>,
        Stephen Boyd <sboyd@kernel.org>,
        Tony Luck <tony.luck@intel.com>,
        Viresh Kumar <viresh.kumar@linaro.org>,
        Will Deacon <will@kernel.org>
Subject: [RFC PATCH 03/11] cpuidle: Remove Calxeda driver
Date: Tue, 18 Feb 2020 11:13:13 -0600
Message-Id: <20200218171321.30990-4-robh@kernel.org>
X-Mailer: git-send-email 2.20.1
In-Reply-To: <20200218171321.30990-1-robh@kernel.org>
References: <20200218171321.30990-1-robh@kernel.org>
MIME-Version: 1.0
Sender: kvm-owner@vger.kernel.org
Precedence: bulk
List-ID: <kvm.vger.kernel.org>
X-Mailing-List: kvm@vger.kernel.org

Cc: "Rafael J. Wysocki" <rjw@rjwysocki.net>
Cc: Daniel Lezcano <daniel.lezcano@linaro.org>
Cc: linux-pm@vger.kernel.org
Signed-off-by: Rob Herring <robh@kernel.org>
Acked-by: Daniel Lezcano <daniel.lezcano@linaro.org>
---
Do not apply yet.

 drivers/cpuidle/Kconfig.arm       |  7 ---
 drivers/cpuidle/Makefile          |  1 -
 drivers/cpuidle/cpuidle-calxeda.c | 72 -------------------------------
 3 files changed, 80 deletions(-)
 delete mode 100644 drivers/cpuidle/cpuidle-calxeda.c

--
2.20.1

diff --git a/drivers/cpuidle/Kconfig.arm b/drivers/cpuidle/Kconfig.arm
index 62272ecfa771..c2830d2ed44a 100644
--- a/drivers/cpuidle/Kconfig.arm
+++ b/drivers/cpuidle/Kconfig.arm
@@ -42,13 +42,6 @@ config ARM_CLPS711X_CPUIDLE
 	help
 	  Select this to enable cpuidle on Cirrus Logic CLPS711X SOCs.

-config ARM_HIGHBANK_CPUIDLE
-	bool "CPU Idle Driver for Calxeda processors"
-	depends on ARM_PSCI && !ARM64
-	select ARM_CPU_SUSPEND
-	help
-	  Select this to enable cpuidle on Calxeda processors.
-
 config ARM_KIRKWOOD_CPUIDLE
 	bool "CPU Idle Driver for Marvell Kirkwood SoCs"
 	depends on (MACH_KIRKWOOD || COMPILE_TEST) && !ARM64
diff --git a/drivers/cpuidle/Makefile b/drivers/cpuidle/Makefile
index cc8c769d7fa9..eee5f276edf7 100644
--- a/drivers/cpuidle/Makefile
+++ b/drivers/cpuidle/Makefile
@@ -14,7 +14,6 @@ obj-$(CONFIG_HALTPOLL_CPUIDLE)		  += cpuidle-haltpoll.o
 obj-$(CONFIG_ARM_MVEBU_V7_CPUIDLE) += cpuidle-mvebu-v7.o
 obj-$(CONFIG_ARM_BIG_LITTLE_CPUIDLE)	+= cpuidle-big_little.o
 obj-$(CONFIG_ARM_CLPS711X_CPUIDLE)	+= cpuidle-clps711x.o
-obj-$(CONFIG_ARM_HIGHBANK_CPUIDLE)	+= cpuidle-calxeda.o
 obj-$(CONFIG_ARM_KIRKWOOD_CPUIDLE)	+= cpuidle-kirkwood.o
 obj-$(CONFIG_ARM_ZYNQ_CPUIDLE)		+= cpuidle-zynq.o
 obj-$(CONFIG_ARM_U8500_CPUIDLE)         += cpuidle-ux500.o
diff --git a/drivers/cpuidle/cpuidle-calxeda.c b/drivers/cpuidle/cpuidle-calxeda.c
deleted file mode 100644
index b17d9a8418b0..000000000000
--- a/drivers/cpuidle/cpuidle-calxeda.c
+++ /dev/null
@@ -1,72 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0-only
-/*
- * Copyright 2012 Calxeda, Inc.
- *
- * Based on arch/arm/plat-mxc/cpuidle.c: #v3.7
- * Copyright 2012 Freescale Semiconductor, Inc.
- * Copyright 2012 Linaro Ltd.
- *
- * Maintainer: Rob Herring <rob.herring@calxeda.com>
- */
-
-#include <linux/cpuidle.h>
-#include <linux/cpu_pm.h>
-#include <linux/init.h>
-#include <linux/mm.h>
-#include <linux/platform_device.h>
-#include <linux/psci.h>
-
-#include <asm/cpuidle.h>
-#include <asm/suspend.h>
-
-#include <uapi/linux/psci.h>
-
-#define CALXEDA_IDLE_PARAM \
-	((0 << PSCI_0_2_POWER_STATE_ID_SHIFT) | \
-	 (0 << PSCI_0_2_POWER_STATE_AFFL_SHIFT) | \
-	 (PSCI_POWER_STATE_TYPE_POWER_DOWN << PSCI_0_2_POWER_STATE_TYPE_SHIFT))
-
-static int calxeda_idle_finish(unsigned long val)
-{
-	return psci_ops.cpu_suspend(CALXEDA_IDLE_PARAM, __pa(cpu_resume));
-}
-
-static int calxeda_pwrdown_idle(struct cpuidle_device *dev,
-				struct cpuidle_driver *drv,
-				int index)
-{
-	cpu_pm_enter();
-	cpu_suspend(0, calxeda_idle_finish);
-	cpu_pm_exit();
-
-	return index;
-}
-
-static struct cpuidle_driver calxeda_idle_driver = {
-	.name = "calxeda_idle",
-	.states = {
-		ARM_CPUIDLE_WFI_STATE,
-		{
-			.name = "PG",
-			.desc = "Power Gate",
-			.exit_latency = 30,
-			.power_usage = 50,
-			.target_residency = 200,
-			.enter = calxeda_pwrdown_idle,
-		},
-	},
-	.state_count = 2,
-};
-
-static int calxeda_cpuidle_probe(struct platform_device *pdev)
-{
-	return cpuidle_register(&calxeda_idle_driver, NULL);
-}
-
-static struct platform_driver calxeda_cpuidle_plat_driver = {
-        .driver = {
-                .name = "cpuidle-calxeda",
-        },
-        .probe = calxeda_cpuidle_probe,
-};
-builtin_platform_driver(calxeda_cpuidle_plat_driver);

From patchwork Tue Feb 18 17:13:14 2020
Content-Type: text/plain; charset="utf-8"
MIME-Version: 1.0
Content-Transfer-Encoding: 7bit
X-Patchwork-Submitter: Rob Herring <robh@kernel.org>
X-Patchwork-Id: 11389097
Return-Path: <SRS0=NRU2=4G=vger.kernel.org=kvm-owner@kernel.org>
Received: from mail.kernel.org (pdx-korg-mail-1.web.codeaurora.org
 [172.30.200.123])
	by pdx-korg-patchwork-2.web.codeaurora.org (Postfix) with ESMTP id 7427E924
	for <patchwork-kvm@patchwork.kernel.org>;
 Tue, 18 Feb 2020 17:14:44 +0000 (UTC)
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.kernel.org (Postfix) with ESMTP id 4CEF72176D
	for <patchwork-kvm@patchwork.kernel.org>;
 Tue, 18 Feb 2020 17:14:44 +0000 (UTC)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple; d=kernel.org;
	s=default; t=1582046084;
	bh=FnKR5zpBy7wE5NA3ChCpJ+1zmGg+KAGqKyEyd/Piv6U=;
	h=From:To:Cc:Subject:Date:In-Reply-To:References:List-ID:From;
	b=16H42sBeVG3uLoXoStoHtJRHKggNuIdCrMOSye/RkxRaZRTUqWUTSzdCR0Wii76MB
	 pZWuMVVYFzsEJDGm4ZLWjbjuEZiE/p4zwQGZ9Nr8fLerODopSLW8b03PXLrvOYWkdY
	 GGUhbrLf8l26pKp5PdSKeO/GrqgxVklh/EzcBy80=
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S1727291AbgBRRNc (ORCPT
        <rfc822;patchwork-kvm@patchwork.kernel.org>);
        Tue, 18 Feb 2020 12:13:32 -0500
Received: from mail-ot1-f66.google.com ([209.85.210.66]:41625 "EHLO
        mail-ot1-f66.google.com" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S1727158AbgBRRNb (ORCPT <rfc822;kvm@vger.kernel.org>);
        Tue, 18 Feb 2020 12:13:31 -0500
Received: by mail-ot1-f66.google.com with SMTP id r27so20205893otc.8;
        Tue, 18 Feb 2020 09:13:30 -0800 (PST)
X-Google-DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
        d=1e100.net; s=20161025;
        h=x-gm-message-state:from:to:cc:subject:date:message-id:in-reply-to
         :references:mime-version:content-transfer-encoding;
        bh=JusgAl5N6MihYqm5uluXtGjWepTJgZcRc57DbXhWS1c=;
        b=Ht/DRUApfdDEJwkI1CWe6zG+5n/5CBDzitD9S6yyarok+Kp9wAB63tuZrGMMLIH/N9
         wXAmamgg+ZjM2qhR6wf+pFSm5K3Xki266YKNrmeYG5oLxNR3sqgmTePHN78ZmxZkkNf1
         8ngs5kPjsvEzzmsYq5DWckIUjYReme5RxQYZ5eNwpIkJDlL5Xe4ZqeF9lRAVvOSyfaDT
         sX3Ze8goOk8ZtOs/ifo3lUN/FzP9OnrOv9l9Xs+shxHSxuypi4+5V7tSqxyGgqreaqHb
         gIZGPfzd97pX3LtbUTHTdemQWCQG9SAe9nuwu7N6XyYOXUNAJciheIVU0aejiRHJ9lLP
         ccdQ==
X-Gm-Message-State: APjAAAVCh8Q2BvG+RaklQs0qBtDyP+RC/J+LULd4j245+6Zc5NyrRzVo
        JO0IFO8czX3c3VJiKIBK0Q==
X-Google-Smtp-Source: 
 APXvYqxtfwdO5ZrwB57qMGPOEsnz4rhk/PhIK9UqQ1I24Sd3few+yqThLV3He9kZDSP4GnJqg66xxQ==
X-Received: by 2002:a05:6830:1042:: with SMTP id
 b2mr16287928otp.306.1582046010353;
        Tue, 18 Feb 2020 09:13:30 -0800 (PST)
Received: from xps15.herring.priv (24-155-109-49.dyn.grandenetworks.net.
 [24.155.109.49])
        by smtp.googlemail.com with ESMTPSA id
 y25sm1545755oto.27.2020.02.18.09.13.28
        (version=TLS1_3 cipher=TLS_AES_256_GCM_SHA384 bits=256/256);
        Tue, 18 Feb 2020 09:13:29 -0800 (PST)
From: Rob Herring <robh@kernel.org>
To: linux-arm-kernel@lists.infradead.org, linux-kernel@vger.kernel.org,
        soc@kernel.org, Andre Przywara <andre.przywara@arm.com>,
        Robert Richter <rrichter@marvell.com>,
        Jon Loeliger <jdl@jdl.com>, Alexander Graf <graf@amazon.com>,
        Matthias Brugger <mbrugger@suse.com>,
        Mark Langsdorf <mlangsdo@redhat.com>
Cc: Alex Williamson <alex.williamson@redhat.com>,
        Borislav Petkov <bp@alien8.de>,
        Cornelia Huck <cohuck@redhat.com>,
        Daniel Lezcano <daniel.lezcano@linaro.org>,
        "David S. Miller" <davem@davemloft.net>,
        devicetree@vger.kernel.org, Eric Auger <eric.auger@redhat.com>,
        iommu@lists.linux-foundation.org,
        James Morse <james.morse@arm.com>,
        Jens Axboe <axboe@kernel.dk>, Joerg Roedel <joro@8bytes.org>,
        kvm@vger.kernel.org, linux-clk@vger.kernel.org,
        linux-edac@vger.kernel.org, linux-ide@vger.kernel.org,
        linux-pm@vger.kernel.org,
        Mauro Carvalho Chehab <mchehab@kernel.org>,
        netdev@vger.kernel.org, "Rafael J. Wysocki" <rjw@rjwysocki.net>,
        Robin Murphy <robin.murphy@arm.com>,
        Stephen Boyd <sboyd@kernel.org>,
        Tony Luck <tony.luck@intel.com>,
        Viresh Kumar <viresh.kumar@linaro.org>,
        Will Deacon <will@kernel.org>
Subject: [RFC PATCH 04/11] cpufreq: Remove Calxeda driver
Date: Tue, 18 Feb 2020 11:13:14 -0600
Message-Id: <20200218171321.30990-5-robh@kernel.org>
X-Mailer: git-send-email 2.20.1
In-Reply-To: <20200218171321.30990-1-robh@kernel.org>
References: <20200218171321.30990-1-robh@kernel.org>
MIME-Version: 1.0
Sender: kvm-owner@vger.kernel.org
Precedence: bulk
List-ID: <kvm.vger.kernel.org>
X-Mailing-List: kvm@vger.kernel.org

Cc: "Rafael J. Wysocki" <rjw@rjwysocki.net>
Cc: Viresh Kumar <viresh.kumar@linaro.org>
Cc: linux-pm@vger.kernel.org
Signed-off-by: Rob Herring <robh@kernel.org>
---
Do not apply yet.

 drivers/cpufreq/Kconfig.arm          |  10 ---
 drivers/cpufreq/Makefile             |   3 +-
 drivers/cpufreq/cpufreq-dt-platdev.c |   3 -
 drivers/cpufreq/highbank-cpufreq.c   | 106 ---------------------------
 4 files changed, 1 insertion(+), 121 deletions(-)
 delete mode 100644 drivers/cpufreq/highbank-cpufreq.c

--
2.20.1

diff --git a/drivers/cpufreq/Kconfig.arm b/drivers/cpufreq/Kconfig.arm
index 3858d86cf409..27fdd5ac21da 100644
--- a/drivers/cpufreq/Kconfig.arm
+++ b/drivers/cpufreq/Kconfig.arm
@@ -79,16 +79,6 @@ config ARM_BRCMSTB_AVS_CPUFREQ

 	  Say Y, if you have a Broadcom SoC with AVS support for DFS or DVFS.

-config ARM_HIGHBANK_CPUFREQ
-	tristate "Calxeda Highbank-based"
-	depends on ARCH_HIGHBANK && CPUFREQ_DT && REGULATOR
-	default m
-	help
-	  This adds the CPUFreq driver for Calxeda Highbank SoC
-	  based boards.
-
-	  If in doubt, say N.
-
 config ARM_IMX6Q_CPUFREQ
 	tristate "Freescale i.MX6 cpufreq support"
 	depends on ARCH_MXC
diff --git a/drivers/cpufreq/Makefile b/drivers/cpufreq/Makefile
index f6670c4abbb0..47d773b9312a 100644
--- a/drivers/cpufreq/Makefile
+++ b/drivers/cpufreq/Makefile
@@ -5,7 +5,7 @@ obj-$(CONFIG_CPU_FREQ)			+= cpufreq.o freq_table.o
 # CPUfreq stats
 obj-$(CONFIG_CPU_FREQ_STAT)             += cpufreq_stats.o

-# CPUfreq governors
+# CPUfreq governors
 obj-$(CONFIG_CPU_FREQ_GOV_PERFORMANCE)	+= cpufreq_performance.o
 obj-$(CONFIG_CPU_FREQ_GOV_POWERSAVE)	+= cpufreq_powersave.o
 obj-$(CONFIG_CPU_FREQ_GOV_USERSPACE)	+= cpufreq_userspace.o
@@ -52,7 +52,6 @@ obj-$(CONFIG_ARM_ARMADA_8K_CPUFREQ)	+= armada-8k-cpufreq.o
 obj-$(CONFIG_ARM_BRCMSTB_AVS_CPUFREQ)	+= brcmstb-avs-cpufreq.o
 obj-$(CONFIG_ACPI_CPPC_CPUFREQ)		+= cppc_cpufreq.o
 obj-$(CONFIG_ARCH_DAVINCI)		+= davinci-cpufreq.o
-obj-$(CONFIG_ARM_HIGHBANK_CPUFREQ)	+= highbank-cpufreq.o
 obj-$(CONFIG_ARM_IMX6Q_CPUFREQ)		+= imx6q-cpufreq.o
 obj-$(CONFIG_ARM_IMX_CPUFREQ_DT)	+= imx-cpufreq-dt.o
 obj-$(CONFIG_ARM_KIRKWOOD_CPUFREQ)	+= kirkwood-cpufreq.o
diff --git a/drivers/cpufreq/cpufreq-dt-platdev.c b/drivers/cpufreq/cpufreq-dt-platdev.c
index f2ae9cd455c1..274294f83e7c 100644
--- a/drivers/cpufreq/cpufreq-dt-platdev.c
+++ b/drivers/cpufreq/cpufreq-dt-platdev.c
@@ -102,9 +102,6 @@ static const struct of_device_id whitelist[] __initconst = {
 static const struct of_device_id blacklist[] __initconst = {
 	{ .compatible = "allwinner,sun50i-h6", },

-	{ .compatible = "calxeda,highbank", },
-	{ .compatible = "calxeda,ecx-2000", },
-
 	{ .compatible = "fsl,imx7d", },
 	{ .compatible = "fsl,imx8mq", },
 	{ .compatible = "fsl,imx8mm", },
diff --git a/drivers/cpufreq/highbank-cpufreq.c b/drivers/cpufreq/highbank-cpufreq.c
deleted file mode 100644
index 5a7f6dafcddb..000000000000
--- a/drivers/cpufreq/highbank-cpufreq.c
+++ /dev/null
@@ -1,106 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0-only
-/*
- * Copyright (C) 2012 Calxeda, Inc.
- *
- * This driver provides the clk notifier callbacks that are used when
- * the cpufreq-dt driver changes to frequency to alert the highbank
- * EnergyCore Management Engine (ECME) about the need to change
- * voltage. The ECME interfaces with the actual voltage regulators.
- */
-
-#define pr_fmt(fmt)	KBUILD_MODNAME ": " fmt
-
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/clk.h>
-#include <linux/cpu.h>
-#include <linux/err.h>
-#include <linux/of.h>
-#include <linux/pl320-ipc.h>
-#include <linux/platform_device.h>
-
-#define HB_CPUFREQ_CHANGE_NOTE	0x80000001
-#define HB_CPUFREQ_IPC_LEN	7
-#define HB_CPUFREQ_VOLT_RETRIES	15
-
-static int hb_voltage_change(unsigned int freq)
-{
-	u32 msg[HB_CPUFREQ_IPC_LEN] = {HB_CPUFREQ_CHANGE_NOTE, freq / 1000000};
-
-	return pl320_ipc_transmit(msg);
-}
-
-static int hb_cpufreq_clk_notify(struct notifier_block *nb,
-				unsigned long action, void *hclk)
-{
-	struct clk_notifier_data *clk_data = hclk;
-	int i = 0;
-
-	if (action == PRE_RATE_CHANGE) {
-		if (clk_data->new_rate > clk_data->old_rate)
-			while (hb_voltage_change(clk_data->new_rate))
-				if (i++ > HB_CPUFREQ_VOLT_RETRIES)
-					return NOTIFY_BAD;
-	} else if (action == POST_RATE_CHANGE) {
-		if (clk_data->new_rate < clk_data->old_rate)
-			while (hb_voltage_change(clk_data->new_rate))
-				if (i++ > HB_CPUFREQ_VOLT_RETRIES)
-					return NOTIFY_BAD;
-	}
-
-	return NOTIFY_DONE;
-}
-
-static struct notifier_block hb_cpufreq_clk_nb = {
-	.notifier_call = hb_cpufreq_clk_notify,
-};
-
-static int hb_cpufreq_driver_init(void)
-{
-	struct platform_device_info devinfo = { .name = "cpufreq-dt", };
-	struct device *cpu_dev;
-	struct clk *cpu_clk;
-	struct device_node *np;
-	int ret;
-
-	if ((!of_machine_is_compatible("calxeda,highbank")) &&
-		(!of_machine_is_compatible("calxeda,ecx-2000")))
-		return -ENODEV;
-
-	cpu_dev = get_cpu_device(0);
-	if (!cpu_dev) {
-		pr_err("failed to get highbank cpufreq device\n");
-		return -ENODEV;
-	}
-
-	np = of_node_get(cpu_dev->of_node);
-	if (!np) {
-		pr_err("failed to find highbank cpufreq node\n");
-		return -ENOENT;
-	}
-
-	cpu_clk = clk_get(cpu_dev, NULL);
-	if (IS_ERR(cpu_clk)) {
-		ret = PTR_ERR(cpu_clk);
-		pr_err("failed to get cpu0 clock: %d\n", ret);
-		goto out_put_node;
-	}
-
-	ret = clk_notifier_register(cpu_clk, &hb_cpufreq_clk_nb);
-	if (ret) {
-		pr_err("failed to register clk notifier: %d\n", ret);
-		goto out_put_node;
-	}
-
-	/* Instantiate cpufreq-dt */
-	platform_device_register_full(&devinfo);
-
-out_put_node:
-	of_node_put(np);
-	return ret;
-}
-module_init(hb_cpufreq_driver_init);
-
-MODULE_AUTHOR("Mark Langsdorf <mark.langsdorf@calxeda.com>");
-MODULE_DESCRIPTION("Calxeda Highbank cpufreq driver");
-MODULE_LICENSE("GPL");

From patchwork Tue Feb 18 17:13:15 2020
Content-Type: text/plain; charset="utf-8"
MIME-Version: 1.0
Content-Transfer-Encoding: 7bit
X-Patchwork-Submitter: Rob Herring <robh@kernel.org>
X-Patchwork-Id: 11389087
Return-Path: <SRS0=NRU2=4G=vger.kernel.org=kvm-owner@kernel.org>
Received: from mail.kernel.org (pdx-korg-mail-1.web.codeaurora.org
 [172.30.200.123])
	by pdx-korg-patchwork-2.web.codeaurora.org (Postfix) with ESMTP id 1766F924
	for <patchwork-kvm@patchwork.kernel.org>;
 Tue, 18 Feb 2020 17:14:33 +0000 (UTC)
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.kernel.org (Postfix) with ESMTP id D24732176D
	for <patchwork-kvm@patchwork.kernel.org>;
 Tue, 18 Feb 2020 17:14:32 +0000 (UTC)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple; d=kernel.org;
	s=default; t=1582046073;
	bh=ok1xiAZ7WXj+mbnCKpDrCgz5JGz9ZCZABjFXb9dYyNM=;
	h=From:To:Cc:Subject:Date:In-Reply-To:References:List-ID:From;
	b=feR37peexvfkHP+Qe386AgOn327aUhMNKOPzP903EugQJYuKsrL6mZw3LES7DM/FC
	 KwKAnL1lKe0vEhgPmfxR1X4xa84n5M8yWYzQhdUqQEd7ucbEtOf0+MTpLqIxJTGowB
	 VWGmGnWlL5T67WP46cCWXLO9nqXyichtvlxivdUI=
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S1727476AbgBRRNh (ORCPT
        <rfc822;patchwork-kvm@patchwork.kernel.org>);
        Tue, 18 Feb 2020 12:13:37 -0500
Received: from mail-oi1-f193.google.com ([209.85.167.193]:39880 "EHLO
        mail-oi1-f193.google.com" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S1727259AbgBRRNe (ORCPT <rfc822;kvm@vger.kernel.org>);
        Tue, 18 Feb 2020 12:13:34 -0500
Received: by mail-oi1-f193.google.com with SMTP id z2so20835228oih.6;
        Tue, 18 Feb 2020 09:13:32 -0800 (PST)
X-Google-DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
        d=1e100.net; s=20161025;
        h=x-gm-message-state:from:to:cc:subject:date:message-id:in-reply-to
         :references:mime-version:content-transfer-encoding;
        bh=v0Vl76UEuxsk5yg9Po+ygPtGTaEk/mhPYQr81MGY08w=;
        b=Oc1p5IkhFbSD7nyEpRUNxjrbtupY5OMRnXbUqBraJiMzOpIFdybAtdJB7yOtyb7/mV
         uYllS6jCktnGrzaAMJMwJDWheweSzWV1H3A7Um2FQVUmeb0ytJL6yYEasWtMN3tTQkLc
         AbVQ8JEGF2SOGKUoqytXCJ/JW2ULp2/WsHiSP3komFUhTMsirNQFFkfNhSdLDNfRcAAi
         Uh/kLv9aTUd+JTWSO+xz+UpiD0ZpLn2OF0TdB4yUTXsccX1WKZh5WEgwzLRROA7t3VEG
         096sZDcYweCfGK9sBJO7QP9wgNrvEfSb5bX92Tkk0xhBRhRJayJmIEUtAGkESxdIGbpO
         46Lw==
X-Gm-Message-State: APjAAAX9bsBkqsPeJnyDtC6TyuzPKdA8UvSAIr5XE5sBxaVoXLJWyamv
        7/yecvUCGPHtEVXIMyD6Bg==
X-Google-Smtp-Source: 
 APXvYqwUc3inMoCdecbdUuNsMDgvDcrJjhj8ChMk19cWCZkyZjwjeXollkDMysGYw5kJtCo1GqwvHQ==
X-Received: by 2002:a54:4791:: with SMTP id o17mr1818618oic.70.1582046011959;
        Tue, 18 Feb 2020 09:13:31 -0800 (PST)
Received: from xps15.herring.priv (24-155-109-49.dyn.grandenetworks.net.
 [24.155.109.49])
        by smtp.googlemail.com with ESMTPSA id
 y25sm1545755oto.27.2020.02.18.09.13.30
        (version=TLS1_3 cipher=TLS_AES_256_GCM_SHA384 bits=256/256);
        Tue, 18 Feb 2020 09:13:31 -0800 (PST)
From: Rob Herring <robh@kernel.org>
To: linux-arm-kernel@lists.infradead.org, linux-kernel@vger.kernel.org,
        soc@kernel.org, Andre Przywara <andre.przywara@arm.com>,
        Robert Richter <rrichter@marvell.com>,
        Jon Loeliger <jdl@jdl.com>, Alexander Graf <graf@amazon.com>,
        Matthias Brugger <mbrugger@suse.com>,
        Mark Langsdorf <mlangsdo@redhat.com>
Cc: Alex Williamson <alex.williamson@redhat.com>,
        Borislav Petkov <bp@alien8.de>,
        Cornelia Huck <cohuck@redhat.com>,
        Daniel Lezcano <daniel.lezcano@linaro.org>,
        "David S. Miller" <davem@davemloft.net>,
        devicetree@vger.kernel.org, Eric Auger <eric.auger@redhat.com>,
        iommu@lists.linux-foundation.org,
        James Morse <james.morse@arm.com>,
        Jens Axboe <axboe@kernel.dk>, Joerg Roedel <joro@8bytes.org>,
        kvm@vger.kernel.org, linux-clk@vger.kernel.org,
        linux-edac@vger.kernel.org, linux-ide@vger.kernel.org,
        linux-pm@vger.kernel.org,
        Mauro Carvalho Chehab <mchehab@kernel.org>,
        netdev@vger.kernel.org, "Rafael J. Wysocki" <rjw@rjwysocki.net>,
        Robin Murphy <robin.murphy@arm.com>,
        Stephen Boyd <sboyd@kernel.org>,
        Tony Luck <tony.luck@intel.com>,
        Viresh Kumar <viresh.kumar@linaro.org>,
        Will Deacon <will@kernel.org>
Subject: [RFC PATCH 05/11] EDAC: Remove Calxeda drivers
Date: Tue, 18 Feb 2020 11:13:15 -0600
Message-Id: <20200218171321.30990-6-robh@kernel.org>
X-Mailer: git-send-email 2.20.1
In-Reply-To: <20200218171321.30990-1-robh@kernel.org>
References: <20200218171321.30990-1-robh@kernel.org>
MIME-Version: 1.0
Sender: kvm-owner@vger.kernel.org
Precedence: bulk
List-ID: <kvm.vger.kernel.org>
X-Mailing-List: kvm@vger.kernel.org

Cc: Borislav Petkov <bp@alien8.de>
Cc: Mauro Carvalho Chehab <mchehab@kernel.org>
Cc: Tony Luck <tony.luck@intel.com>
Cc: James Morse <james.morse@arm.com>
Cc: Robert Richter <rrichter@marvell.com>
Cc: linux-edac@vger.kernel.org
Signed-off-by: Rob Herring <robh@kernel.org>
---
Do not apply yet.

 MAINTAINERS                     |   6 -
 drivers/edac/Kconfig            |  14 --
 drivers/edac/Makefile           |   3 -
 drivers/edac/highbank_l2_edac.c | 142 -----------------
 drivers/edac/highbank_mc_edac.c | 272 --------------------------------
 5 files changed, 437 deletions(-)
 delete mode 100644 drivers/edac/highbank_l2_edac.c
 delete mode 100644 drivers/edac/highbank_mc_edac.c

--
2.20.1

diff --git a/MAINTAINERS b/MAINTAINERS
index a0d86490c2c6..4732bb268299 100644
--- a/MAINTAINERS
+++ b/MAINTAINERS
@@ -5964,12 +5964,6 @@ M:	Shravan Kumar Ramani <sramani@mellanox.com>
 S:	Supported
 F:	drivers/edac/bluefield_edac.c

-EDAC-CALXEDA
-M:	Robert Richter <rric@kernel.org>
-L:	linux-edac@vger.kernel.org
-S:	Maintained
-F:	drivers/edac/highbank*
-
 EDAC-CAVIUM OCTEON
 M:	Ralf Baechle <ralf@linux-mips.org>
 M:	Robert Richter <rrichter@marvell.com>
diff --git a/drivers/edac/Kconfig b/drivers/edac/Kconfig
index b3c99bb5fe77..f3ff75e5ed9b 100644
--- a/drivers/edac/Kconfig
+++ b/drivers/edac/Kconfig
@@ -334,20 +334,6 @@ config EDAC_CPC925
 	  a companion chip to the PowerPC 970 family of
 	  processors.

-config EDAC_HIGHBANK_MC
-	tristate "Highbank Memory Controller"
-	depends on ARCH_HIGHBANK
-	help
-	  Support for error detection and correction on the
-	  Calxeda Highbank memory controller.
-
-config EDAC_HIGHBANK_L2
-	tristate "Highbank L2 Cache"
-	depends on ARCH_HIGHBANK
-	help
-	  Support for error detection and correction on the
-	  Calxeda Highbank memory controller.
-
 config EDAC_OCTEON_PC
 	tristate "Cavium Octeon Primary Caches"
 	depends on CPU_CAVIUM_OCTEON
diff --git a/drivers/edac/Makefile b/drivers/edac/Makefile
index d77200c9680b..9a563db39bc3 100644
--- a/drivers/edac/Makefile
+++ b/drivers/edac/Makefile
@@ -69,9 +69,6 @@ obj-$(CONFIG_EDAC_PPC4XX)		+= ppc4xx_edac.o
 obj-$(CONFIG_EDAC_AMD8111)		+= amd8111_edac.o
 obj-$(CONFIG_EDAC_AMD8131)		+= amd8131_edac.o

-obj-$(CONFIG_EDAC_HIGHBANK_MC)		+= highbank_mc_edac.o
-obj-$(CONFIG_EDAC_HIGHBANK_L2)		+= highbank_l2_edac.o
-
 obj-$(CONFIG_EDAC_OCTEON_PC)		+= octeon_edac-pc.o
 obj-$(CONFIG_EDAC_OCTEON_L2C)		+= octeon_edac-l2c.o
 obj-$(CONFIG_EDAC_OCTEON_LMC)		+= octeon_edac-lmc.o
diff --git a/drivers/edac/highbank_l2_edac.c b/drivers/edac/highbank_l2_edac.c
deleted file mode 100644
index c4549cec788b..000000000000
--- a/drivers/edac/highbank_l2_edac.c
+++ /dev/null
@@ -1,142 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0-only
-/*
- * Copyright 2011-2012 Calxeda, Inc.
- */
-#include <linux/types.h>
-#include <linux/kernel.h>
-#include <linux/ctype.h>
-#include <linux/edac.h>
-#include <linux/interrupt.h>
-#include <linux/platform_device.h>
-#include <linux/of_platform.h>
-
-#include "edac_module.h"
-
-#define SR_CLR_SB_ECC_INTR	0x0
-#define SR_CLR_DB_ECC_INTR	0x4
-
-struct hb_l2_drvdata {
-	void __iomem *base;
-	int sb_irq;
-	int db_irq;
-};
-
-static irqreturn_t highbank_l2_err_handler(int irq, void *dev_id)
-{
-	struct edac_device_ctl_info *dci = dev_id;
-	struct hb_l2_drvdata *drvdata = dci->pvt_info;
-
-	if (irq == drvdata->sb_irq) {
-		writel(1, drvdata->base + SR_CLR_SB_ECC_INTR);
-		edac_device_handle_ce(dci, 0, 0, dci->ctl_name);
-	}
-	if (irq == drvdata->db_irq) {
-		writel(1, drvdata->base + SR_CLR_DB_ECC_INTR);
-		edac_device_handle_ue(dci, 0, 0, dci->ctl_name);
-	}
-
-	return IRQ_HANDLED;
-}
-
-static const struct of_device_id hb_l2_err_of_match[] = {
-	{ .compatible = "calxeda,hb-sregs-l2-ecc", },
-	{},
-};
-MODULE_DEVICE_TABLE(of, hb_l2_err_of_match);
-
-static int highbank_l2_err_probe(struct platform_device *pdev)
-{
-	const struct of_device_id *id;
-	struct edac_device_ctl_info *dci;
-	struct hb_l2_drvdata *drvdata;
-	struct resource *r;
-	int res = 0;
-
-	dci = edac_device_alloc_ctl_info(sizeof(*drvdata), "cpu",
-		1, "L", 1, 2, NULL, 0, 0);
-	if (!dci)
-		return -ENOMEM;
-
-	drvdata = dci->pvt_info;
-	dci->dev = &pdev->dev;
-	platform_set_drvdata(pdev, dci);
-
-	if (!devres_open_group(&pdev->dev, NULL, GFP_KERNEL))
-		return -ENOMEM;
-
-	r = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	if (!r) {
-		dev_err(&pdev->dev, "Unable to get mem resource\n");
-		res = -ENODEV;
-		goto err;
-	}
-
-	if (!devm_request_mem_region(&pdev->dev, r->start,
-				     resource_size(r), dev_name(&pdev->dev))) {
-		dev_err(&pdev->dev, "Error while requesting mem region\n");
-		res = -EBUSY;
-		goto err;
-	}
-
-	drvdata->base = devm_ioremap(&pdev->dev, r->start, resource_size(r));
-	if (!drvdata->base) {
-		dev_err(&pdev->dev, "Unable to map regs\n");
-		res = -ENOMEM;
-		goto err;
-	}
-
-	id = of_match_device(hb_l2_err_of_match, &pdev->dev);
-	dci->mod_name = pdev->dev.driver->name;
-	dci->ctl_name = id ? id->compatible : "unknown";
-	dci->dev_name = dev_name(&pdev->dev);
-
-	if (edac_device_add_device(dci))
-		goto err;
-
-	drvdata->db_irq = platform_get_irq(pdev, 0);
-	res = devm_request_irq(&pdev->dev, drvdata->db_irq,
-			       highbank_l2_err_handler,
-			       0, dev_name(&pdev->dev), dci);
-	if (res < 0)
-		goto err2;
-
-	drvdata->sb_irq = platform_get_irq(pdev, 1);
-	res = devm_request_irq(&pdev->dev, drvdata->sb_irq,
-			       highbank_l2_err_handler,
-			       0, dev_name(&pdev->dev), dci);
-	if (res < 0)
-		goto err2;
-
-	devres_close_group(&pdev->dev, NULL);
-	return 0;
-err2:
-	edac_device_del_device(&pdev->dev);
-err:
-	devres_release_group(&pdev->dev, NULL);
-	edac_device_free_ctl_info(dci);
-	return res;
-}
-
-static int highbank_l2_err_remove(struct platform_device *pdev)
-{
-	struct edac_device_ctl_info *dci = platform_get_drvdata(pdev);
-
-	edac_device_del_device(&pdev->dev);
-	edac_device_free_ctl_info(dci);
-	return 0;
-}
-
-static struct platform_driver highbank_l2_edac_driver = {
-	.probe = highbank_l2_err_probe,
-	.remove = highbank_l2_err_remove,
-	.driver = {
-		.name = "hb_l2_edac",
-		.of_match_table = hb_l2_err_of_match,
-	},
-};
-
-module_platform_driver(highbank_l2_edac_driver);
-
-MODULE_LICENSE("GPL v2");
-MODULE_AUTHOR("Calxeda, Inc.");
-MODULE_DESCRIPTION("EDAC Driver for Calxeda Highbank L2 Cache");
diff --git a/drivers/edac/highbank_mc_edac.c b/drivers/edac/highbank_mc_edac.c
deleted file mode 100644
index 61b76ec226af..000000000000
--- a/drivers/edac/highbank_mc_edac.c
+++ /dev/null
@@ -1,272 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0-only
-/*
- * Copyright 2011-2012 Calxeda, Inc.
- */
-#include <linux/types.h>
-#include <linux/kernel.h>
-#include <linux/ctype.h>
-#include <linux/edac.h>
-#include <linux/interrupt.h>
-#include <linux/platform_device.h>
-#include <linux/of_platform.h>
-#include <linux/uaccess.h>
-
-#include "edac_module.h"
-
-/* DDR Ctrlr Error Registers */
-
-#define HB_DDR_ECC_ERR_BASE		0x128
-#define MW_DDR_ECC_ERR_BASE		0x1b4
-
-#define HB_DDR_ECC_OPT			0x00
-#define HB_DDR_ECC_U_ERR_ADDR		0x08
-#define HB_DDR_ECC_U_ERR_STAT		0x0c
-#define HB_DDR_ECC_U_ERR_DATAL		0x10
-#define HB_DDR_ECC_U_ERR_DATAH		0x14
-#define HB_DDR_ECC_C_ERR_ADDR		0x18
-#define HB_DDR_ECC_C_ERR_STAT		0x1c
-#define HB_DDR_ECC_C_ERR_DATAL		0x20
-#define HB_DDR_ECC_C_ERR_DATAH		0x24
-
-#define HB_DDR_ECC_OPT_MODE_MASK	0x3
-#define HB_DDR_ECC_OPT_FWC		0x100
-#define HB_DDR_ECC_OPT_XOR_SHIFT	16
-
-/* DDR Ctrlr Interrupt Registers */
-
-#define HB_DDR_ECC_INT_BASE		0x180
-#define MW_DDR_ECC_INT_BASE		0x218
-
-#define HB_DDR_ECC_INT_STATUS		0x00
-#define HB_DDR_ECC_INT_ACK		0x04
-
-#define HB_DDR_ECC_INT_STAT_CE		0x8
-#define HB_DDR_ECC_INT_STAT_DOUBLE_CE	0x10
-#define HB_DDR_ECC_INT_STAT_UE		0x20
-#define HB_DDR_ECC_INT_STAT_DOUBLE_UE	0x40
-
-struct hb_mc_drvdata {
-	void __iomem *mc_err_base;
-	void __iomem *mc_int_base;
-};
-
-static irqreturn_t highbank_mc_err_handler(int irq, void *dev_id)
-{
-	struct mem_ctl_info *mci = dev_id;
-	struct hb_mc_drvdata *drvdata = mci->pvt_info;
-	u32 status, err_addr;
-
-	/* Read the interrupt status register */
-	status = readl(drvdata->mc_int_base + HB_DDR_ECC_INT_STATUS);
-
-	if (status & HB_DDR_ECC_INT_STAT_UE) {
-		err_addr = readl(drvdata->mc_err_base + HB_DDR_ECC_U_ERR_ADDR);
-		edac_mc_handle_error(HW_EVENT_ERR_UNCORRECTED, mci, 1,
-				     err_addr >> PAGE_SHIFT,
-				     err_addr & ~PAGE_MASK, 0,
-				     0, 0, -1,
-				     mci->ctl_name, "");
-	}
-	if (status & HB_DDR_ECC_INT_STAT_CE) {
-		u32 syndrome = readl(drvdata->mc_err_base + HB_DDR_ECC_C_ERR_STAT);
-		syndrome = (syndrome >> 8) & 0xff;
-		err_addr = readl(drvdata->mc_err_base + HB_DDR_ECC_C_ERR_ADDR);
-		edac_mc_handle_error(HW_EVENT_ERR_CORRECTED, mci, 1,
-				     err_addr >> PAGE_SHIFT,
-				     err_addr & ~PAGE_MASK, syndrome,
-				     0, 0, -1,
-				     mci->ctl_name, "");
-	}
-
-	/* clear the error, clears the interrupt */
-	writel(status, drvdata->mc_int_base + HB_DDR_ECC_INT_ACK);
-	return IRQ_HANDLED;
-}
-
-static void highbank_mc_err_inject(struct mem_ctl_info *mci, u8 synd)
-{
-	struct hb_mc_drvdata *pdata = mci->pvt_info;
-	u32 reg;
-
-	reg = readl(pdata->mc_err_base + HB_DDR_ECC_OPT);
-	reg &= HB_DDR_ECC_OPT_MODE_MASK;
-	reg |= (synd << HB_DDR_ECC_OPT_XOR_SHIFT) | HB_DDR_ECC_OPT_FWC;
-	writel(reg, pdata->mc_err_base + HB_DDR_ECC_OPT);
-}
-
-#define to_mci(k) container_of(k, struct mem_ctl_info, dev)
-
-static ssize_t highbank_mc_inject_ctrl(struct device *dev,
-	struct device_attribute *attr, const char *buf, size_t count)
-{
-	struct mem_ctl_info *mci = to_mci(dev);
-	u8 synd;
-
-	if (kstrtou8(buf, 16, &synd))
-		return -EINVAL;
-
-	highbank_mc_err_inject(mci, synd);
-
-	return count;
-}
-
-static DEVICE_ATTR(inject_ctrl, S_IWUSR, NULL, highbank_mc_inject_ctrl);
-
-static struct attribute *highbank_dev_attrs[] = {
-	&dev_attr_inject_ctrl.attr,
-	NULL
-};
-
-ATTRIBUTE_GROUPS(highbank_dev);
-
-struct hb_mc_settings {
-	int	err_offset;
-	int	int_offset;
-};
-
-static struct hb_mc_settings hb_settings = {
-	.err_offset = HB_DDR_ECC_ERR_BASE,
-	.int_offset = HB_DDR_ECC_INT_BASE,
-};
-
-static struct hb_mc_settings mw_settings = {
-	.err_offset = MW_DDR_ECC_ERR_BASE,
-	.int_offset = MW_DDR_ECC_INT_BASE,
-};
-
-static const struct of_device_id hb_ddr_ctrl_of_match[] = {
-	{ .compatible = "calxeda,hb-ddr-ctrl",		.data = &hb_settings },
-	{ .compatible = "calxeda,ecx-2000-ddr-ctrl",	.data = &mw_settings },
-	{},
-};
-MODULE_DEVICE_TABLE(of, hb_ddr_ctrl_of_match);
-
-static int highbank_mc_probe(struct platform_device *pdev)
-{
-	const struct of_device_id *id;
-	const struct hb_mc_settings *settings;
-	struct edac_mc_layer layers[2];
-	struct mem_ctl_info *mci;
-	struct hb_mc_drvdata *drvdata;
-	struct dimm_info *dimm;
-	struct resource *r;
-	void __iomem *base;
-	u32 control;
-	int irq;
-	int res = 0;
-
-	id = of_match_device(hb_ddr_ctrl_of_match, &pdev->dev);
-	if (!id)
-		return -ENODEV;
-
-	layers[0].type = EDAC_MC_LAYER_CHIP_SELECT;
-	layers[0].size = 1;
-	layers[0].is_virt_csrow = true;
-	layers[1].type = EDAC_MC_LAYER_CHANNEL;
-	layers[1].size = 1;
-	layers[1].is_virt_csrow = false;
-	mci = edac_mc_alloc(0, ARRAY_SIZE(layers), layers,
-			    sizeof(struct hb_mc_drvdata));
-	if (!mci)
-		return -ENOMEM;
-
-	mci->pdev = &pdev->dev;
-	drvdata = mci->pvt_info;
-	platform_set_drvdata(pdev, mci);
-
-	if (!devres_open_group(&pdev->dev, NULL, GFP_KERNEL))
-		return -ENOMEM;
-
-	r = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	if (!r) {
-		dev_err(&pdev->dev, "Unable to get mem resource\n");
-		res = -ENODEV;
-		goto err;
-	}
-
-	if (!devm_request_mem_region(&pdev->dev, r->start,
-				     resource_size(r), dev_name(&pdev->dev))) {
-		dev_err(&pdev->dev, "Error while requesting mem region\n");
-		res = -EBUSY;
-		goto err;
-	}
-
-	base = devm_ioremap(&pdev->dev, r->start, resource_size(r));
-	if (!base) {
-		dev_err(&pdev->dev, "Unable to map regs\n");
-		res = -ENOMEM;
-		goto err;
-	}
-
-	settings = id->data;
-	drvdata->mc_err_base = base + settings->err_offset;
-	drvdata->mc_int_base = base + settings->int_offset;
-
-	control = readl(drvdata->mc_err_base + HB_DDR_ECC_OPT) & 0x3;
-	if (!control || (control == 0x2)) {
-		dev_err(&pdev->dev, "No ECC present, or ECC disabled\n");
-		res = -ENODEV;
-		goto err;
-	}
-
-	mci->mtype_cap = MEM_FLAG_DDR3;
-	mci->edac_ctl_cap = EDAC_FLAG_NONE | EDAC_FLAG_SECDED;
-	mci->edac_cap = EDAC_FLAG_SECDED;
-	mci->mod_name = pdev->dev.driver->name;
-	mci->ctl_name = id->compatible;
-	mci->dev_name = dev_name(&pdev->dev);
-	mci->scrub_mode = SCRUB_SW_SRC;
-
-	/* Only a single 4GB DIMM is supported */
-	dimm = *mci->dimms;
-	dimm->nr_pages = (~0UL >> PAGE_SHIFT) + 1;
-	dimm->grain = 8;
-	dimm->dtype = DEV_X8;
-	dimm->mtype = MEM_DDR3;
-	dimm->edac_mode = EDAC_SECDED;
-
-	res = edac_mc_add_mc_with_groups(mci, highbank_dev_groups);
-	if (res < 0)
-		goto err;
-
-	irq = platform_get_irq(pdev, 0);
-	res = devm_request_irq(&pdev->dev, irq, highbank_mc_err_handler,
-			       0, dev_name(&pdev->dev), mci);
-	if (res < 0) {
-		dev_err(&pdev->dev, "Unable to request irq %d\n", irq);
-		goto err2;
-	}
-
-	devres_close_group(&pdev->dev, NULL);
-	return 0;
-err2:
-	edac_mc_del_mc(&pdev->dev);
-err:
-	devres_release_group(&pdev->dev, NULL);
-	edac_mc_free(mci);
-	return res;
-}
-
-static int highbank_mc_remove(struct platform_device *pdev)
-{
-	struct mem_ctl_info *mci = platform_get_drvdata(pdev);
-
-	edac_mc_del_mc(&pdev->dev);
-	edac_mc_free(mci);
-	return 0;
-}
-
-static struct platform_driver highbank_mc_edac_driver = {
-	.probe = highbank_mc_probe,
-	.remove = highbank_mc_remove,
-	.driver = {
-		.name = "hb_mc_edac",
-		.of_match_table = hb_ddr_ctrl_of_match,
-	},
-};
-
-module_platform_driver(highbank_mc_edac_driver);
-
-MODULE_LICENSE("GPL v2");
-MODULE_AUTHOR("Calxeda, Inc.");
-MODULE_DESCRIPTION("EDAC Driver for Calxeda Highbank");

From patchwork Tue Feb 18 17:13:16 2020
Content-Type: text/plain; charset="utf-8"
MIME-Version: 1.0
Content-Transfer-Encoding: 7bit
X-Patchwork-Submitter: Rob Herring <robh@kernel.org>
X-Patchwork-Id: 11389075
Return-Path: <SRS0=NRU2=4G=vger.kernel.org=kvm-owner@kernel.org>
Received: from mail.kernel.org (pdx-korg-mail-1.web.codeaurora.org
 [172.30.200.123])
	by pdx-korg-patchwork-2.web.codeaurora.org (Postfix) with ESMTP id F2A2592A
	for <patchwork-kvm@patchwork.kernel.org>;
 Tue, 18 Feb 2020 17:14:22 +0000 (UTC)
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.kernel.org (Postfix) with ESMTP id D3BB62176D
	for <patchwork-kvm@patchwork.kernel.org>;
 Tue, 18 Feb 2020 17:14:22 +0000 (UTC)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple; d=kernel.org;
	s=default; t=1582046062;
	bh=oj/PaeebHVoP2kF/x1Y4/iaEEHBzTRG4k0uuxQ3i2G0=;
	h=From:To:Cc:Subject:Date:In-Reply-To:References:List-ID:From;
	b=lfBdUQG0kzONYqmIqyQveHnUO1UtYcHx37fqOxwAMOEmuXXEyP3vF2XsIdqfptCXQ
	 0nUe1IUXBCXzmpfTQsh2MXofA4GmjQqXgqBiJpG3eQM+qyxEX642tDM3qOfDoMHxRe
	 PgzFqtaS1kHbnThPbdYXOtcKQ93J1gNbR5YrWUsQ=
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S1727545AbgBRRNi (ORCPT
        <rfc822;patchwork-kvm@patchwork.kernel.org>);
        Tue, 18 Feb 2020 12:13:38 -0500
Received: from mail-oi1-f194.google.com ([209.85.167.194]:38278 "EHLO
        mail-oi1-f194.google.com" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S1727393AbgBRRNe (ORCPT <rfc822;kvm@vger.kernel.org>);
        Tue, 18 Feb 2020 12:13:34 -0500
Received: by mail-oi1-f194.google.com with SMTP id r137so1267245oie.5;
        Tue, 18 Feb 2020 09:13:33 -0800 (PST)
X-Google-DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
        d=1e100.net; s=20161025;
        h=x-gm-message-state:from:to:cc:subject:date:message-id:in-reply-to
         :references:mime-version:content-transfer-encoding;
        bh=kW31qHj/OGRN2L4TXUUKIQPN57zbu2axU6XP0HsWl20=;
        b=A00RgPnZTtgZXHrAdc6iFFkLWWmYcBvnyU8Y9x4KrQOMS2iySfepez+Hm9HSjrOgZy
         4ybC7S86lz8wm2+Y/Snp9bVdxEpxtSgnwu9DbG+6DbV64XOJi7TuA/3hB9DmInfmE5vq
         nlgOiF8+fxCTjrMIpFMhpcZLDgSlxiEoQfHjCz8OdLCi+wHYD1HdPXNNRGeKqbueQerr
         Crk7kKtpPgcHyAxJ3DHtkwPMyJ2m0M+3vrCE8B/XdehNzQ7ZCdo3i+Hjpp5K6ZKRqLdY
         YIVkWTwaIFe1kliERSlJhyo864sFAyNhjO6wjxsQCfsYao0BwwW1jSKPgq81MbijlmAJ
         nQyQ==
X-Gm-Message-State: APjAAAWbrp5gq2FTsX8aHaW6Y/f7rK2Keu2b/G8gE+2grPF+kJzh7rmE
        L4JHPPIRMhMP8P/T2J84TQ==
X-Google-Smtp-Source: 
 APXvYqzM1O5/oeWQHJ8gT8Z9L53EKPDEEuwksZtS3dmhCEXg8KSK+0rIqhxLhSP9RCgQyZtde069lg==
X-Received: by 2002:a05:6808:9ba:: with SMTP id
 e26mr1936616oig.81.1582046013542;
        Tue, 18 Feb 2020 09:13:33 -0800 (PST)
Received: from xps15.herring.priv (24-155-109-49.dyn.grandenetworks.net.
 [24.155.109.49])
        by smtp.googlemail.com with ESMTPSA id
 y25sm1545755oto.27.2020.02.18.09.13.32
        (version=TLS1_3 cipher=TLS_AES_256_GCM_SHA384 bits=256/256);
        Tue, 18 Feb 2020 09:13:33 -0800 (PST)
From: Rob Herring <robh@kernel.org>
To: linux-arm-kernel@lists.infradead.org, linux-kernel@vger.kernel.org,
        soc@kernel.org, Andre Przywara <andre.przywara@arm.com>,
        Robert Richter <rrichter@marvell.com>,
        Jon Loeliger <jdl@jdl.com>, Alexander Graf <graf@amazon.com>,
        Matthias Brugger <mbrugger@suse.com>,
        Mark Langsdorf <mlangsdo@redhat.com>
Cc: Alex Williamson <alex.williamson@redhat.com>,
        Borislav Petkov <bp@alien8.de>,
        Cornelia Huck <cohuck@redhat.com>,
        Daniel Lezcano <daniel.lezcano@linaro.org>,
        "David S. Miller" <davem@davemloft.net>,
        devicetree@vger.kernel.org, Eric Auger <eric.auger@redhat.com>,
        iommu@lists.linux-foundation.org,
        James Morse <james.morse@arm.com>,
        Jens Axboe <axboe@kernel.dk>, Joerg Roedel <joro@8bytes.org>,
        kvm@vger.kernel.org, linux-clk@vger.kernel.org,
        linux-edac@vger.kernel.org, linux-ide@vger.kernel.org,
        linux-pm@vger.kernel.org,
        Mauro Carvalho Chehab <mchehab@kernel.org>,
        netdev@vger.kernel.org, "Rafael J. Wysocki" <rjw@rjwysocki.net>,
        Robin Murphy <robin.murphy@arm.com>,
        Stephen Boyd <sboyd@kernel.org>,
        Tony Luck <tony.luck@intel.com>,
        Viresh Kumar <viresh.kumar@linaro.org>,
        Will Deacon <will@kernel.org>
Subject: [RFC PATCH 06/11] iommu: arm-smmu: Remove Calxeda secure mode quirk
Date: Tue, 18 Feb 2020 11:13:16 -0600
Message-Id: <20200218171321.30990-7-robh@kernel.org>
X-Mailer: git-send-email 2.20.1
In-Reply-To: <20200218171321.30990-1-robh@kernel.org>
References: <20200218171321.30990-1-robh@kernel.org>
MIME-Version: 1.0
Sender: kvm-owner@vger.kernel.org
Precedence: bulk
List-ID: <kvm.vger.kernel.org>
X-Mailing-List: kvm@vger.kernel.org

Cc: Will Deacon <will@kernel.org>
Cc: Robin Murphy <robin.murphy@arm.com>
Cc: Joerg Roedel <joro@8bytes.org>
Cc: iommu@lists.linux-foundation.org
Signed-off-by: Rob Herring <robh@kernel.org>
---
Do not apply yet.

 drivers/iommu/arm-smmu-impl.c | 43 -----------------------------------
 1 file changed, 43 deletions(-)

--
2.20.1

diff --git a/drivers/iommu/arm-smmu-impl.c b/drivers/iommu/arm-smmu-impl.c
index 74d97a886e93..a3be8712d27f 100644
--- a/drivers/iommu/arm-smmu-impl.c
+++ b/drivers/iommu/arm-smmu-impl.c
@@ -9,45 +9,6 @@

 #include "arm-smmu.h"

-
-static int arm_smmu_gr0_ns(int offset)
-{
-	switch(offset) {
-	case ARM_SMMU_GR0_sCR0:
-	case ARM_SMMU_GR0_sACR:
-	case ARM_SMMU_GR0_sGFSR:
-	case ARM_SMMU_GR0_sGFSYNR0:
-	case ARM_SMMU_GR0_sGFSYNR1:
-	case ARM_SMMU_GR0_sGFSYNR2:
-		return offset + 0x400;
-	default:
-		return offset;
-	}
-}
-
-static u32 arm_smmu_read_ns(struct arm_smmu_device *smmu, int page,
-			    int offset)
-{
-	if (page == ARM_SMMU_GR0)
-		offset = arm_smmu_gr0_ns(offset);
-	return readl_relaxed(arm_smmu_page(smmu, page) + offset);
-}
-
-static void arm_smmu_write_ns(struct arm_smmu_device *smmu, int page,
-			      int offset, u32 val)
-{
-	if (page == ARM_SMMU_GR0)
-		offset = arm_smmu_gr0_ns(offset);
-	writel_relaxed(val, arm_smmu_page(smmu, page) + offset);
-}
-
-/* Since we don't care for sGFAR, we can do without 64-bit accessors */
-static const struct arm_smmu_impl calxeda_impl = {
-	.read_reg = arm_smmu_read_ns,
-	.write_reg = arm_smmu_write_ns,
-};
-
-
 struct cavium_smmu {
 	struct arm_smmu_device smmu;
 	u32 id_base;
@@ -166,10 +127,6 @@ struct arm_smmu_device *arm_smmu_impl_init(struct arm_smmu_device *smmu)
 		break;
 	}

-	if (of_property_read_bool(smmu->dev->of_node,
-				  "calxeda,smmu-secure-config-access"))
-		smmu->impl = &calxeda_impl;
-
 	if (of_device_is_compatible(smmu->dev->of_node, "qcom,sdm845-smmu-500"))
 		return qcom_smmu_impl_init(smmu);


From patchwork Tue Feb 18 17:13:17 2020
Content-Type: text/plain; charset="utf-8"
MIME-Version: 1.0
Content-Transfer-Encoding: 7bit
X-Patchwork-Submitter: Rob Herring <robh@kernel.org>
X-Patchwork-Id: 11389065
Return-Path: <SRS0=NRU2=4G=vger.kernel.org=kvm-owner@kernel.org>
Received: from mail.kernel.org (pdx-korg-mail-1.web.codeaurora.org
 [172.30.200.123])
	by pdx-korg-patchwork-2.web.codeaurora.org (Postfix) with ESMTP id 46D64924
	for <patchwork-kvm@patchwork.kernel.org>;
 Tue, 18 Feb 2020 17:14:18 +0000 (UTC)
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.kernel.org (Postfix) with ESMTP id DC8A32176D
	for <patchwork-kvm@patchwork.kernel.org>;
 Tue, 18 Feb 2020 17:14:17 +0000 (UTC)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple; d=kernel.org;
	s=default; t=1582046058;
	bh=KlgYuHSsDR2YYCWDCnpJJuCk/za7Ia4/s+K8bA0UnT8=;
	h=From:To:Cc:Subject:Date:In-Reply-To:References:List-ID:From;
	b=gu7fxpRYBuxo/RMp4qm1H/Q2cYcaekYhLAroFRwNG16V9P1aZygNsi5rlLUyGaYFO
	 7yqhDmC1SUBVgRzgWUL4P5Y2nvMwTHt+JNGi66Gyt9VufsSoWGypYlE7v/qH7JWYHT
	 BEJncIK1y4gr/JYaLEquaJJ7j4ex6C9ZAvvUS7rM=
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S1727649AbgBRRNj (ORCPT
        <rfc822;patchwork-kvm@patchwork.kernel.org>);
        Tue, 18 Feb 2020 12:13:39 -0500
Received: from mail-oi1-f195.google.com ([209.85.167.195]:40150 "EHLO
        mail-oi1-f195.google.com" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S1727020AbgBRRNh (ORCPT <rfc822;kvm@vger.kernel.org>);
        Tue, 18 Feb 2020 12:13:37 -0500
Received: by mail-oi1-f195.google.com with SMTP id a142so20823407oii.7;
        Tue, 18 Feb 2020 09:13:36 -0800 (PST)
X-Google-DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
        d=1e100.net; s=20161025;
        h=x-gm-message-state:from:to:cc:subject:date:message-id:in-reply-to
         :references:mime-version:content-transfer-encoding;
        bh=ab3FNDlelPzThpf2CtjT70ozbwAY9/reDs4EMvSbG/c=;
        b=uHT98MHw0Q6IlP0hCuXOYCco7xdbc4tJEOYpP/+SejUn/KZGvdpgGTENYjLAU6688z
         oJHL0uAEBLo+xQQLKdIWZzBBVIpvIDqXvY8SprAzhi4OEyMWK6JAgf6R/bv17A0m/mE/
         /xprnme9Go8ToxKOSIqXxvgl3JfbHdZ1OauObaAdas2ZzuRVAeF/JX+N9PL/dM1SLcwz
         JbMNhVZf7ZasetoPtD3pZkd9yWFonDTnJLtvcFiYO7qHSFFnngltZbx43mRzvjB68gRq
         ARECZQAwjnqiGjQhe8cprVJA5Zmhvx02XR1KghPi0cZaWIcypOo2O1mbynf0CDvWs3ji
         Ll5Q==
X-Gm-Message-State: APjAAAUxttlNj166M+fHfAtwJpzXb1I89g7XDQ/ENX3iG4vIFn9CYgDC
        u05JQKAmb1w6RJRJ5D2QsQ==
X-Google-Smtp-Source: 
 APXvYqwE3uSd51pKZQDidmZnsOONT1GpKHDBneO+U5A/JOvD8Odun8K+CFSKtSkJEeZ7ga1y0TTZQg==
X-Received: by 2002:aca:1a10:: with SMTP id a16mr1959529oia.9.1582046015182;
        Tue, 18 Feb 2020 09:13:35 -0800 (PST)
Received: from xps15.herring.priv (24-155-109-49.dyn.grandenetworks.net.
 [24.155.109.49])
        by smtp.googlemail.com with ESMTPSA id
 y25sm1545755oto.27.2020.02.18.09.13.33
        (version=TLS1_3 cipher=TLS_AES_256_GCM_SHA384 bits=256/256);
        Tue, 18 Feb 2020 09:13:34 -0800 (PST)
From: Rob Herring <robh@kernel.org>
To: linux-arm-kernel@lists.infradead.org, linux-kernel@vger.kernel.org,
        soc@kernel.org, Andre Przywara <andre.przywara@arm.com>,
        Robert Richter <rrichter@marvell.com>,
        Jon Loeliger <jdl@jdl.com>, Alexander Graf <graf@amazon.com>,
        Matthias Brugger <mbrugger@suse.com>,
        Mark Langsdorf <mlangsdo@redhat.com>
Cc: Alex Williamson <alex.williamson@redhat.com>,
        Borislav Petkov <bp@alien8.de>,
        Cornelia Huck <cohuck@redhat.com>,
        Daniel Lezcano <daniel.lezcano@linaro.org>,
        "David S. Miller" <davem@davemloft.net>,
        devicetree@vger.kernel.org, Eric Auger <eric.auger@redhat.com>,
        iommu@lists.linux-foundation.org,
        James Morse <james.morse@arm.com>,
        Jens Axboe <axboe@kernel.dk>, Joerg Roedel <joro@8bytes.org>,
        kvm@vger.kernel.org, linux-clk@vger.kernel.org,
        linux-edac@vger.kernel.org, linux-ide@vger.kernel.org,
        linux-pm@vger.kernel.org,
        Mauro Carvalho Chehab <mchehab@kernel.org>,
        netdev@vger.kernel.org, "Rafael J. Wysocki" <rjw@rjwysocki.net>,
        Robin Murphy <robin.murphy@arm.com>,
        Stephen Boyd <sboyd@kernel.org>,
        Tony Luck <tony.luck@intel.com>,
        Viresh Kumar <viresh.kumar@linaro.org>,
        Will Deacon <will@kernel.org>
Subject: [RFC PATCH 07/11] net: Remove Calxeda XGMAC driver
Date: Tue, 18 Feb 2020 11:13:17 -0600
Message-Id: <20200218171321.30990-8-robh@kernel.org>
X-Mailer: git-send-email 2.20.1
In-Reply-To: <20200218171321.30990-1-robh@kernel.org>
References: <20200218171321.30990-1-robh@kernel.org>
MIME-Version: 1.0
Sender: kvm-owner@vger.kernel.org
Precedence: bulk
List-ID: <kvm.vger.kernel.org>
X-Mailing-List: kvm@vger.kernel.org

Cc: "David S. Miller" <davem@davemloft.net>
Cc: netdev@vger.kernel.org
Signed-off-by: Rob Herring <robh@kernel.org>
---
Do not apply yet.

 drivers/net/ethernet/Kconfig          |    1 -
 drivers/net/ethernet/Makefile         |    1 -
 drivers/net/ethernet/calxeda/Kconfig  |    9 -
 drivers/net/ethernet/calxeda/Makefile |    2 -
 drivers/net/ethernet/calxeda/xgmac.c  | 1927 -------------------------
 5 files changed, 1940 deletions(-)
 delete mode 100644 drivers/net/ethernet/calxeda/Kconfig
 delete mode 100644 drivers/net/ethernet/calxeda/Makefile
 delete mode 100644 drivers/net/ethernet/calxeda/xgmac.c

--
2.20.1

diff --git a/drivers/net/ethernet/Kconfig b/drivers/net/ethernet/Kconfig
index 4ded81b27d0a..023928e82b44 100644
--- a/drivers/net/ethernet/Kconfig
+++ b/drivers/net/ethernet/Kconfig
@@ -37,7 +37,6 @@ source "drivers/net/ethernet/aurora/Kconfig"
 source "drivers/net/ethernet/broadcom/Kconfig"
 source "drivers/net/ethernet/brocade/Kconfig"
 source "drivers/net/ethernet/cadence/Kconfig"
-source "drivers/net/ethernet/calxeda/Kconfig"
 source "drivers/net/ethernet/cavium/Kconfig"
 source "drivers/net/ethernet/chelsio/Kconfig"
 source "drivers/net/ethernet/cirrus/Kconfig"
diff --git a/drivers/net/ethernet/Makefile b/drivers/net/ethernet/Makefile
index f8f38dcb5f8a..1011131a736d 100644
--- a/drivers/net/ethernet/Makefile
+++ b/drivers/net/ethernet/Makefile
@@ -23,7 +23,6 @@ obj-$(CONFIG_NET_VENDOR_AURORA) += aurora/
 obj-$(CONFIG_NET_VENDOR_CADENCE) += cadence/
 obj-$(CONFIG_NET_VENDOR_BROADCOM) += broadcom/
 obj-$(CONFIG_NET_VENDOR_BROCADE) += brocade/
-obj-$(CONFIG_NET_CALXEDA_XGMAC) += calxeda/
 obj-$(CONFIG_NET_VENDOR_CAVIUM) += cavium/
 obj-$(CONFIG_NET_VENDOR_CHELSIO) += chelsio/
 obj-$(CONFIG_NET_VENDOR_CIRRUS) += cirrus/
diff --git a/drivers/net/ethernet/calxeda/Kconfig b/drivers/net/ethernet/calxeda/Kconfig
deleted file mode 100644
index ce42157f13f6..000000000000
--- a/drivers/net/ethernet/calxeda/Kconfig
+++ /dev/null
@@ -1,9 +0,0 @@
-# SPDX-License-Identifier: GPL-2.0-only
-config NET_CALXEDA_XGMAC
-	tristate "Calxeda 1G/10G XGMAC Ethernet driver"
-	depends on HAS_IOMEM
-	depends on ARCH_HIGHBANK || COMPILE_TEST
-	select CRC32
-	help
-	  This is the driver for the XGMAC Ethernet IP block found on Calxeda
-	  Highbank platforms.
diff --git a/drivers/net/ethernet/calxeda/Makefile b/drivers/net/ethernet/calxeda/Makefile
deleted file mode 100644
index 641e5b6b5ac7..000000000000
--- a/drivers/net/ethernet/calxeda/Makefile
+++ /dev/null
@@ -1,2 +0,0 @@
-# SPDX-License-Identifier: GPL-2.0-only
-obj-$(CONFIG_NET_CALXEDA_XGMAC) += xgmac.o
diff --git a/drivers/net/ethernet/calxeda/xgmac.c b/drivers/net/ethernet/calxeda/xgmac.c
deleted file mode 100644
index 05a3d067c3fc..000000000000
--- a/drivers/net/ethernet/calxeda/xgmac.c
+++ /dev/null
@@ -1,1927 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0-only
-/*
- * Copyright 2010-2011 Calxeda, Inc.
- */
-#include <linux/module.h>
-#include <linux/mod_devicetable.h>
-#include <linux/kernel.h>
-#include <linux/circ_buf.h>
-#include <linux/interrupt.h>
-#include <linux/etherdevice.h>
-#include <linux/platform_device.h>
-#include <linux/skbuff.h>
-#include <linux/ethtool.h>
-#include <linux/if.h>
-#include <linux/crc32.h>
-#include <linux/dma-mapping.h>
-#include <linux/slab.h>
-
-/* XGMAC Register definitions */
-#define XGMAC_CONTROL		0x00000000	/* MAC Configuration */
-#define XGMAC_FRAME_FILTER	0x00000004	/* MAC Frame Filter */
-#define XGMAC_FLOW_CTRL		0x00000018	/* MAC Flow Control */
-#define XGMAC_VLAN_TAG		0x0000001C	/* VLAN Tags */
-#define XGMAC_VERSION		0x00000020	/* Version */
-#define XGMAC_VLAN_INCL		0x00000024	/* VLAN tag for tx frames */
-#define XGMAC_LPI_CTRL		0x00000028	/* LPI Control and Status */
-#define XGMAC_LPI_TIMER		0x0000002C	/* LPI Timers Control */
-#define XGMAC_TX_PACE		0x00000030	/* Transmit Pace and Stretch */
-#define XGMAC_VLAN_HASH		0x00000034	/* VLAN Hash Table */
-#define XGMAC_DEBUG		0x00000038	/* Debug */
-#define XGMAC_INT_STAT		0x0000003C	/* Interrupt and Control */
-#define XGMAC_ADDR_HIGH(reg)	(0x00000040 + ((reg) * 8))
-#define XGMAC_ADDR_LOW(reg)	(0x00000044 + ((reg) * 8))
-#define XGMAC_HASH(n)		(0x00000300 + (n) * 4) /* HASH table regs */
-#define XGMAC_NUM_HASH		16
-#define XGMAC_OMR		0x00000400
-#define XGMAC_REMOTE_WAKE	0x00000700	/* Remote Wake-Up Frm Filter */
-#define XGMAC_PMT		0x00000704	/* PMT Control and Status */
-#define XGMAC_MMC_CTRL		0x00000800	/* XGMAC MMC Control */
-#define XGMAC_MMC_INTR_RX	0x00000804	/* Receive Interrupt */
-#define XGMAC_MMC_INTR_TX	0x00000808	/* Transmit Interrupt */
-#define XGMAC_MMC_INTR_MASK_RX	0x0000080c	/* Receive Interrupt Mask */
-#define XGMAC_MMC_INTR_MASK_TX	0x00000810	/* Transmit Interrupt Mask */
-
-/* Hardware TX Statistics Counters */
-#define XGMAC_MMC_TXOCTET_GB_LO	0x00000814
-#define XGMAC_MMC_TXOCTET_GB_HI	0x00000818
-#define XGMAC_MMC_TXFRAME_GB_LO	0x0000081C
-#define XGMAC_MMC_TXFRAME_GB_HI	0x00000820
-#define XGMAC_MMC_TXBCFRAME_G	0x00000824
-#define XGMAC_MMC_TXMCFRAME_G	0x0000082C
-#define XGMAC_MMC_TXUCFRAME_GB	0x00000864
-#define XGMAC_MMC_TXMCFRAME_GB	0x0000086C
-#define XGMAC_MMC_TXBCFRAME_GB	0x00000874
-#define XGMAC_MMC_TXUNDERFLOW	0x0000087C
-#define XGMAC_MMC_TXOCTET_G_LO	0x00000884
-#define XGMAC_MMC_TXOCTET_G_HI	0x00000888
-#define XGMAC_MMC_TXFRAME_G_LO	0x0000088C
-#define XGMAC_MMC_TXFRAME_G_HI	0x00000890
-#define XGMAC_MMC_TXPAUSEFRAME	0x00000894
-#define XGMAC_MMC_TXVLANFRAME	0x0000089C
-
-/* Hardware RX Statistics Counters */
-#define XGMAC_MMC_RXFRAME_GB_LO	0x00000900
-#define XGMAC_MMC_RXFRAME_GB_HI	0x00000904
-#define XGMAC_MMC_RXOCTET_GB_LO	0x00000908
-#define XGMAC_MMC_RXOCTET_GB_HI	0x0000090C
-#define XGMAC_MMC_RXOCTET_G_LO	0x00000910
-#define XGMAC_MMC_RXOCTET_G_HI	0x00000914
-#define XGMAC_MMC_RXBCFRAME_G	0x00000918
-#define XGMAC_MMC_RXMCFRAME_G	0x00000920
-#define XGMAC_MMC_RXCRCERR	0x00000928
-#define XGMAC_MMC_RXRUNT	0x00000930
-#define XGMAC_MMC_RXJABBER	0x00000934
-#define XGMAC_MMC_RXUCFRAME_G	0x00000970
-#define XGMAC_MMC_RXLENGTHERR	0x00000978
-#define XGMAC_MMC_RXPAUSEFRAME	0x00000988
-#define XGMAC_MMC_RXOVERFLOW	0x00000990
-#define XGMAC_MMC_RXVLANFRAME	0x00000998
-#define XGMAC_MMC_RXWATCHDOG	0x000009a0
-
-/* DMA Control and Status Registers */
-#define XGMAC_DMA_BUS_MODE	0x00000f00	/* Bus Mode */
-#define XGMAC_DMA_TX_POLL	0x00000f04	/* Transmit Poll Demand */
-#define XGMAC_DMA_RX_POLL	0x00000f08	/* Received Poll Demand */
-#define XGMAC_DMA_RX_BASE_ADDR	0x00000f0c	/* Receive List Base */
-#define XGMAC_DMA_TX_BASE_ADDR	0x00000f10	/* Transmit List Base */
-#define XGMAC_DMA_STATUS	0x00000f14	/* Status Register */
-#define XGMAC_DMA_CONTROL	0x00000f18	/* Ctrl (Operational Mode) */
-#define XGMAC_DMA_INTR_ENA	0x00000f1c	/* Interrupt Enable */
-#define XGMAC_DMA_MISS_FRAME_CTR 0x00000f20	/* Missed Frame Counter */
-#define XGMAC_DMA_RI_WDOG_TIMER	0x00000f24	/* RX Intr Watchdog Timer */
-#define XGMAC_DMA_AXI_BUS	0x00000f28	/* AXI Bus Mode */
-#define XGMAC_DMA_AXI_STATUS	0x00000f2C	/* AXI Status */
-#define XGMAC_DMA_HW_FEATURE	0x00000f58	/* Enabled Hardware Features */
-
-#define XGMAC_ADDR_AE		0x80000000
-
-/* PMT Control and Status */
-#define XGMAC_PMT_POINTER_RESET	0x80000000
-#define XGMAC_PMT_GLBL_UNICAST	0x00000200
-#define XGMAC_PMT_WAKEUP_RX_FRM	0x00000040
-#define XGMAC_PMT_MAGIC_PKT	0x00000020
-#define XGMAC_PMT_WAKEUP_FRM_EN	0x00000004
-#define XGMAC_PMT_MAGIC_PKT_EN	0x00000002
-#define XGMAC_PMT_POWERDOWN	0x00000001
-
-#define XGMAC_CONTROL_SPD	0x40000000	/* Speed control */
-#define XGMAC_CONTROL_SPD_MASK	0x60000000
-#define XGMAC_CONTROL_SPD_1G	0x60000000
-#define XGMAC_CONTROL_SPD_2_5G	0x40000000
-#define XGMAC_CONTROL_SPD_10G	0x00000000
-#define XGMAC_CONTROL_SARC	0x10000000	/* Source Addr Insert/Replace */
-#define XGMAC_CONTROL_SARK_MASK	0x18000000
-#define XGMAC_CONTROL_CAR	0x04000000	/* CRC Addition/Replacement */
-#define XGMAC_CONTROL_CAR_MASK	0x06000000
-#define XGMAC_CONTROL_DP	0x01000000	/* Disable Padding */
-#define XGMAC_CONTROL_WD	0x00800000	/* Disable Watchdog on rx */
-#define XGMAC_CONTROL_JD	0x00400000	/* Jabber disable */
-#define XGMAC_CONTROL_JE	0x00100000	/* Jumbo frame */
-#define XGMAC_CONTROL_LM	0x00001000	/* Loop-back mode */
-#define XGMAC_CONTROL_IPC	0x00000400	/* Checksum Offload */
-#define XGMAC_CONTROL_ACS	0x00000080	/* Automatic Pad/FCS Strip */
-#define XGMAC_CONTROL_DDIC	0x00000010	/* Disable Deficit Idle Count */
-#define XGMAC_CONTROL_TE	0x00000008	/* Transmitter Enable */
-#define XGMAC_CONTROL_RE	0x00000004	/* Receiver Enable */
-
-/* XGMAC Frame Filter defines */
-#define XGMAC_FRAME_FILTER_PR	0x00000001	/* Promiscuous Mode */
-#define XGMAC_FRAME_FILTER_HUC	0x00000002	/* Hash Unicast */
-#define XGMAC_FRAME_FILTER_HMC	0x00000004	/* Hash Multicast */
-#define XGMAC_FRAME_FILTER_DAIF	0x00000008	/* DA Inverse Filtering */
-#define XGMAC_FRAME_FILTER_PM	0x00000010	/* Pass all multicast */
-#define XGMAC_FRAME_FILTER_DBF	0x00000020	/* Disable Broadcast frames */
-#define XGMAC_FRAME_FILTER_SAIF	0x00000100	/* Inverse Filtering */
-#define XGMAC_FRAME_FILTER_SAF	0x00000200	/* Source Address Filter */
-#define XGMAC_FRAME_FILTER_HPF	0x00000400	/* Hash or perfect Filter */
-#define XGMAC_FRAME_FILTER_VHF	0x00000800	/* VLAN Hash Filter */
-#define XGMAC_FRAME_FILTER_VPF	0x00001000	/* VLAN Perfect Filter */
-#define XGMAC_FRAME_FILTER_RA	0x80000000	/* Receive all mode */
-
-/* XGMAC FLOW CTRL defines */
-#define XGMAC_FLOW_CTRL_PT_MASK	0xffff0000	/* Pause Time Mask */
-#define XGMAC_FLOW_CTRL_PT_SHIFT	16
-#define XGMAC_FLOW_CTRL_DZQP	0x00000080	/* Disable Zero-Quanta Phase */
-#define XGMAC_FLOW_CTRL_PLT	0x00000020	/* Pause Low Threshold */
-#define XGMAC_FLOW_CTRL_PLT_MASK 0x00000030	/* PLT MASK */
-#define XGMAC_FLOW_CTRL_UP	0x00000008	/* Unicast Pause Frame Detect */
-#define XGMAC_FLOW_CTRL_RFE	0x00000004	/* Rx Flow Control Enable */
-#define XGMAC_FLOW_CTRL_TFE	0x00000002	/* Tx Flow Control Enable */
-#define XGMAC_FLOW_CTRL_FCB_BPA	0x00000001	/* Flow Control Busy ... */
-
-/* XGMAC_INT_STAT reg */
-#define XGMAC_INT_STAT_PMTIM	0x00800000	/* PMT Interrupt Mask */
-#define XGMAC_INT_STAT_PMT	0x0080		/* PMT Interrupt Status */
-#define XGMAC_INT_STAT_LPI	0x0040		/* LPI Interrupt Status */
-
-/* DMA Bus Mode register defines */
-#define DMA_BUS_MODE_SFT_RESET	0x00000001	/* Software Reset */
-#define DMA_BUS_MODE_DSL_MASK	0x0000007c	/* Descriptor Skip Length */
-#define DMA_BUS_MODE_DSL_SHIFT	2		/* (in DWORDS) */
-#define DMA_BUS_MODE_ATDS	0x00000080	/* Alternate Descriptor Size */
-
-/* Programmable burst length */
-#define DMA_BUS_MODE_PBL_MASK	0x00003f00	/* Programmable Burst Len */
-#define DMA_BUS_MODE_PBL_SHIFT	8
-#define DMA_BUS_MODE_FB		0x00010000	/* Fixed burst */
-#define DMA_BUS_MODE_RPBL_MASK	0x003e0000	/* Rx-Programmable Burst Len */
-#define DMA_BUS_MODE_RPBL_SHIFT	17
-#define DMA_BUS_MODE_USP	0x00800000
-#define DMA_BUS_MODE_8PBL	0x01000000
-#define DMA_BUS_MODE_AAL	0x02000000
-
-/* DMA Bus Mode register defines */
-#define DMA_BUS_PR_RATIO_MASK	0x0000c000	/* Rx/Tx priority ratio */
-#define DMA_BUS_PR_RATIO_SHIFT	14
-#define DMA_BUS_FB		0x00010000	/* Fixed Burst */
-
-/* DMA Control register defines */
-#define DMA_CONTROL_ST		0x00002000	/* Start/Stop Transmission */
-#define DMA_CONTROL_SR		0x00000002	/* Start/Stop Receive */
-#define DMA_CONTROL_DFF		0x01000000	/* Disable flush of rx frames */
-#define DMA_CONTROL_OSF		0x00000004	/* Operate on 2nd tx frame */
-
-/* DMA Normal interrupt */
-#define DMA_INTR_ENA_NIE	0x00010000	/* Normal Summary */
-#define DMA_INTR_ENA_AIE	0x00008000	/* Abnormal Summary */
-#define DMA_INTR_ENA_ERE	0x00004000	/* Early Receive */
-#define DMA_INTR_ENA_FBE	0x00002000	/* Fatal Bus Error */
-#define DMA_INTR_ENA_ETE	0x00000400	/* Early Transmit */
-#define DMA_INTR_ENA_RWE	0x00000200	/* Receive Watchdog */
-#define DMA_INTR_ENA_RSE	0x00000100	/* Receive Stopped */
-#define DMA_INTR_ENA_RUE	0x00000080	/* Receive Buffer Unavailable */
-#define DMA_INTR_ENA_RIE	0x00000040	/* Receive Interrupt */
-#define DMA_INTR_ENA_UNE	0x00000020	/* Tx Underflow */
-#define DMA_INTR_ENA_OVE	0x00000010	/* Receive Overflow */
-#define DMA_INTR_ENA_TJE	0x00000008	/* Transmit Jabber */
-#define DMA_INTR_ENA_TUE	0x00000004	/* Transmit Buffer Unavail */
-#define DMA_INTR_ENA_TSE	0x00000002	/* Transmit Stopped */
-#define DMA_INTR_ENA_TIE	0x00000001	/* Transmit Interrupt */
-
-#define DMA_INTR_NORMAL		(DMA_INTR_ENA_NIE | DMA_INTR_ENA_RIE | \
-				 DMA_INTR_ENA_TUE | DMA_INTR_ENA_TIE)
-
-#define DMA_INTR_ABNORMAL	(DMA_INTR_ENA_AIE | DMA_INTR_ENA_FBE | \
-				 DMA_INTR_ENA_RWE | DMA_INTR_ENA_RSE | \
-				 DMA_INTR_ENA_RUE | DMA_INTR_ENA_UNE | \
-				 DMA_INTR_ENA_OVE | DMA_INTR_ENA_TJE | \
-				 DMA_INTR_ENA_TSE)
-
-/* DMA default interrupt mask */
-#define DMA_INTR_DEFAULT_MASK	(DMA_INTR_NORMAL | DMA_INTR_ABNORMAL)
-
-/* DMA Status register defines */
-#define DMA_STATUS_GMI		0x08000000	/* MMC interrupt */
-#define DMA_STATUS_GLI		0x04000000	/* GMAC Line interface int */
-#define DMA_STATUS_EB_MASK	0x00380000	/* Error Bits Mask */
-#define DMA_STATUS_EB_TX_ABORT	0x00080000	/* Error Bits - TX Abort */
-#define DMA_STATUS_EB_RX_ABORT	0x00100000	/* Error Bits - RX Abort */
-#define DMA_STATUS_TS_MASK	0x00700000	/* Transmit Process State */
-#define DMA_STATUS_TS_SHIFT	20
-#define DMA_STATUS_RS_MASK	0x000e0000	/* Receive Process State */
-#define DMA_STATUS_RS_SHIFT	17
-#define DMA_STATUS_NIS		0x00010000	/* Normal Interrupt Summary */
-#define DMA_STATUS_AIS		0x00008000	/* Abnormal Interrupt Summary */
-#define DMA_STATUS_ERI		0x00004000	/* Early Receive Interrupt */
-#define DMA_STATUS_FBI		0x00002000	/* Fatal Bus Error Interrupt */
-#define DMA_STATUS_ETI		0x00000400	/* Early Transmit Interrupt */
-#define DMA_STATUS_RWT		0x00000200	/* Receive Watchdog Timeout */
-#define DMA_STATUS_RPS		0x00000100	/* Receive Process Stopped */
-#define DMA_STATUS_RU		0x00000080	/* Receive Buffer Unavailable */
-#define DMA_STATUS_RI		0x00000040	/* Receive Interrupt */
-#define DMA_STATUS_UNF		0x00000020	/* Transmit Underflow */
-#define DMA_STATUS_OVF		0x00000010	/* Receive Overflow */
-#define DMA_STATUS_TJT		0x00000008	/* Transmit Jabber Timeout */
-#define DMA_STATUS_TU		0x00000004	/* Transmit Buffer Unavail */
-#define DMA_STATUS_TPS		0x00000002	/* Transmit Process Stopped */
-#define DMA_STATUS_TI		0x00000001	/* Transmit Interrupt */
-
-/* Common MAC defines */
-#define MAC_ENABLE_TX		0x00000008	/* Transmitter Enable */
-#define MAC_ENABLE_RX		0x00000004	/* Receiver Enable */
-
-/* XGMAC Operation Mode Register */
-#define XGMAC_OMR_TSF		0x00200000	/* TX FIFO Store and Forward */
-#define XGMAC_OMR_FTF		0x00100000	/* Flush Transmit FIFO */
-#define XGMAC_OMR_TTC		0x00020000	/* Transmit Threshold Ctrl */
-#define XGMAC_OMR_TTC_MASK	0x00030000
-#define XGMAC_OMR_RFD		0x00006000	/* FC Deactivation Threshold */
-#define XGMAC_OMR_RFD_MASK	0x00007000	/* FC Deact Threshold MASK */
-#define XGMAC_OMR_RFA		0x00000600	/* FC Activation Threshold */
-#define XGMAC_OMR_RFA_MASK	0x00000E00	/* FC Act Threshold MASK */
-#define XGMAC_OMR_EFC		0x00000100	/* Enable Hardware FC */
-#define XGMAC_OMR_FEF		0x00000080	/* Forward Error Frames */
-#define XGMAC_OMR_DT		0x00000040	/* Drop TCP/IP csum Errors */
-#define XGMAC_OMR_RSF		0x00000020	/* RX FIFO Store and Forward */
-#define XGMAC_OMR_RTC_256	0x00000018	/* RX Threshold Ctrl */
-#define XGMAC_OMR_RTC_MASK	0x00000018	/* RX Threshold Ctrl MASK */
-
-/* XGMAC HW Features Register */
-#define DMA_HW_FEAT_TXCOESEL	0x00010000	/* TX Checksum offload */
-
-#define XGMAC_MMC_CTRL_CNT_FRZ	0x00000008
-
-/* XGMAC Descriptor Defines */
-#define MAX_DESC_BUF_SZ		(0x2000 - 8)
-
-#define RXDESC_EXT_STATUS	0x00000001
-#define RXDESC_CRC_ERR		0x00000002
-#define RXDESC_RX_ERR		0x00000008
-#define RXDESC_RX_WDOG		0x00000010
-#define RXDESC_FRAME_TYPE	0x00000020
-#define RXDESC_GIANT_FRAME	0x00000080
-#define RXDESC_LAST_SEG		0x00000100
-#define RXDESC_FIRST_SEG	0x00000200
-#define RXDESC_VLAN_FRAME	0x00000400
-#define RXDESC_OVERFLOW_ERR	0x00000800
-#define RXDESC_LENGTH_ERR	0x00001000
-#define RXDESC_SA_FILTER_FAIL	0x00002000
-#define RXDESC_DESCRIPTOR_ERR	0x00004000
-#define RXDESC_ERROR_SUMMARY	0x00008000
-#define RXDESC_FRAME_LEN_OFFSET	16
-#define RXDESC_FRAME_LEN_MASK	0x3fff0000
-#define RXDESC_DA_FILTER_FAIL	0x40000000
-
-#define RXDESC1_END_RING	0x00008000
-
-#define RXDESC_IP_PAYLOAD_MASK	0x00000003
-#define RXDESC_IP_PAYLOAD_UDP	0x00000001
-#define RXDESC_IP_PAYLOAD_TCP	0x00000002
-#define RXDESC_IP_PAYLOAD_ICMP	0x00000003
-#define RXDESC_IP_HEADER_ERR	0x00000008
-#define RXDESC_IP_PAYLOAD_ERR	0x00000010
-#define RXDESC_IPV4_PACKET	0x00000040
-#define RXDESC_IPV6_PACKET	0x00000080
-#define TXDESC_UNDERFLOW_ERR	0x00000001
-#define TXDESC_JABBER_TIMEOUT	0x00000002
-#define TXDESC_LOCAL_FAULT	0x00000004
-#define TXDESC_REMOTE_FAULT	0x00000008
-#define TXDESC_VLAN_FRAME	0x00000010
-#define TXDESC_FRAME_FLUSHED	0x00000020
-#define TXDESC_IP_HEADER_ERR	0x00000040
-#define TXDESC_PAYLOAD_CSUM_ERR	0x00000080
-#define TXDESC_ERROR_SUMMARY	0x00008000
-#define TXDESC_SA_CTRL_INSERT	0x00040000
-#define TXDESC_SA_CTRL_REPLACE	0x00080000
-#define TXDESC_2ND_ADDR_CHAINED	0x00100000
-#define TXDESC_END_RING		0x00200000
-#define TXDESC_CSUM_IP		0x00400000
-#define TXDESC_CSUM_IP_PAYLD	0x00800000
-#define TXDESC_CSUM_ALL		0x00C00000
-#define TXDESC_CRC_EN_REPLACE	0x01000000
-#define TXDESC_CRC_EN_APPEND	0x02000000
-#define TXDESC_DISABLE_PAD	0x04000000
-#define TXDESC_FIRST_SEG	0x10000000
-#define TXDESC_LAST_SEG		0x20000000
-#define TXDESC_INTERRUPT	0x40000000
-
-#define DESC_OWN		0x80000000
-#define DESC_BUFFER1_SZ_MASK	0x00001fff
-#define DESC_BUFFER2_SZ_MASK	0x1fff0000
-#define DESC_BUFFER2_SZ_OFFSET	16
-
-struct xgmac_dma_desc {
-	__le32 flags;
-	__le32 buf_size;
-	__le32 buf1_addr;		/* Buffer 1 Address Pointer */
-	__le32 buf2_addr;		/* Buffer 2 Address Pointer */
-	__le32 ext_status;
-	__le32 res[3];
-};
-
-struct xgmac_extra_stats {
-	/* Transmit errors */
-	unsigned long tx_jabber;
-	unsigned long tx_frame_flushed;
-	unsigned long tx_payload_error;
-	unsigned long tx_ip_header_error;
-	unsigned long tx_local_fault;
-	unsigned long tx_remote_fault;
-	/* Receive errors */
-	unsigned long rx_watchdog;
-	unsigned long rx_da_filter_fail;
-	unsigned long rx_payload_error;
-	unsigned long rx_ip_header_error;
-	/* Tx/Rx IRQ errors */
-	unsigned long tx_process_stopped;
-	unsigned long rx_buf_unav;
-	unsigned long rx_process_stopped;
-	unsigned long tx_early;
-	unsigned long fatal_bus_error;
-};
-
-struct xgmac_priv {
-	struct xgmac_dma_desc *dma_rx;
-	struct sk_buff **rx_skbuff;
-	unsigned int rx_tail;
-	unsigned int rx_head;
-
-	struct xgmac_dma_desc *dma_tx;
-	struct sk_buff **tx_skbuff;
-	unsigned int tx_head;
-	unsigned int tx_tail;
-	int tx_irq_cnt;
-
-	void __iomem *base;
-	unsigned int dma_buf_sz;
-	dma_addr_t dma_rx_phy;
-	dma_addr_t dma_tx_phy;
-
-	struct net_device *dev;
-	struct device *device;
-	struct napi_struct napi;
-
-	int max_macs;
-	struct xgmac_extra_stats xstats;
-
-	spinlock_t stats_lock;
-	int pmt_irq;
-	char rx_pause;
-	char tx_pause;
-	int wolopts;
-	struct work_struct tx_timeout_work;
-};
-
-/* XGMAC Configuration Settings */
-#define XGMAC_MAX_MTU		9000
-#define PAUSE_TIME		0x400
-
-#define DMA_RX_RING_SZ		256
-#define DMA_TX_RING_SZ		128
-/* minimum number of free TX descriptors required to wake up TX process */
-#define TX_THRESH		(DMA_TX_RING_SZ/4)
-
-/* DMA descriptor ring helpers */
-#define dma_ring_incr(n, s)	(((n) + 1) & ((s) - 1))
-#define dma_ring_space(h, t, s)	CIRC_SPACE(h, t, s)
-#define dma_ring_cnt(h, t, s)	CIRC_CNT(h, t, s)
-
-#define tx_dma_ring_space(p) \
-	dma_ring_space((p)->tx_head, (p)->tx_tail, DMA_TX_RING_SZ)
-
-/* XGMAC Descriptor Access Helpers */
-static inline void desc_set_buf_len(struct xgmac_dma_desc *p, u32 buf_sz)
-{
-	if (buf_sz > MAX_DESC_BUF_SZ)
-		p->buf_size = cpu_to_le32(MAX_DESC_BUF_SZ |
-			(buf_sz - MAX_DESC_BUF_SZ) << DESC_BUFFER2_SZ_OFFSET);
-	else
-		p->buf_size = cpu_to_le32(buf_sz);
-}
-
-static inline int desc_get_buf_len(struct xgmac_dma_desc *p)
-{
-	u32 len = le32_to_cpu(p->buf_size);
-	return (len & DESC_BUFFER1_SZ_MASK) +
-		((len & DESC_BUFFER2_SZ_MASK) >> DESC_BUFFER2_SZ_OFFSET);
-}
-
-static inline void desc_init_rx_desc(struct xgmac_dma_desc *p, int ring_size,
-				     int buf_sz)
-{
-	struct xgmac_dma_desc *end = p + ring_size - 1;
-
-	memset(p, 0, sizeof(*p) * ring_size);
-
-	for (; p <= end; p++)
-		desc_set_buf_len(p, buf_sz);
-
-	end->buf_size |= cpu_to_le32(RXDESC1_END_RING);
-}
-
-static inline void desc_init_tx_desc(struct xgmac_dma_desc *p, u32 ring_size)
-{
-	memset(p, 0, sizeof(*p) * ring_size);
-	p[ring_size - 1].flags = cpu_to_le32(TXDESC_END_RING);
-}
-
-static inline int desc_get_owner(struct xgmac_dma_desc *p)
-{
-	return le32_to_cpu(p->flags) & DESC_OWN;
-}
-
-static inline void desc_set_rx_owner(struct xgmac_dma_desc *p)
-{
-	/* Clear all fields and set the owner */
-	p->flags = cpu_to_le32(DESC_OWN);
-}
-
-static inline void desc_set_tx_owner(struct xgmac_dma_desc *p, u32 flags)
-{
-	u32 tmpflags = le32_to_cpu(p->flags);
-	tmpflags &= TXDESC_END_RING;
-	tmpflags |= flags | DESC_OWN;
-	p->flags = cpu_to_le32(tmpflags);
-}
-
-static inline void desc_clear_tx_owner(struct xgmac_dma_desc *p)
-{
-	u32 tmpflags = le32_to_cpu(p->flags);
-	tmpflags &= TXDESC_END_RING;
-	p->flags = cpu_to_le32(tmpflags);
-}
-
-static inline int desc_get_tx_ls(struct xgmac_dma_desc *p)
-{
-	return le32_to_cpu(p->flags) & TXDESC_LAST_SEG;
-}
-
-static inline int desc_get_tx_fs(struct xgmac_dma_desc *p)
-{
-	return le32_to_cpu(p->flags) & TXDESC_FIRST_SEG;
-}
-
-static inline u32 desc_get_buf_addr(struct xgmac_dma_desc *p)
-{
-	return le32_to_cpu(p->buf1_addr);
-}
-
-static inline void desc_set_buf_addr(struct xgmac_dma_desc *p,
-				     u32 paddr, int len)
-{
-	p->buf1_addr = cpu_to_le32(paddr);
-	if (len > MAX_DESC_BUF_SZ)
-		p->buf2_addr = cpu_to_le32(paddr + MAX_DESC_BUF_SZ);
-}
-
-static inline void desc_set_buf_addr_and_size(struct xgmac_dma_desc *p,
-					      u32 paddr, int len)
-{
-	desc_set_buf_len(p, len);
-	desc_set_buf_addr(p, paddr, len);
-}
-
-static inline int desc_get_rx_frame_len(struct xgmac_dma_desc *p)
-{
-	u32 data = le32_to_cpu(p->flags);
-	u32 len = (data & RXDESC_FRAME_LEN_MASK) >> RXDESC_FRAME_LEN_OFFSET;
-	if (data & RXDESC_FRAME_TYPE)
-		len -= ETH_FCS_LEN;
-
-	return len;
-}
-
-static void xgmac_dma_flush_tx_fifo(void __iomem *ioaddr)
-{
-	int timeout = 1000;
-	u32 reg = readl(ioaddr + XGMAC_OMR);
-	writel(reg | XGMAC_OMR_FTF, ioaddr + XGMAC_OMR);
-
-	while ((timeout-- > 0) && readl(ioaddr + XGMAC_OMR) & XGMAC_OMR_FTF)
-		udelay(1);
-}
-
-static int desc_get_tx_status(struct xgmac_priv *priv, struct xgmac_dma_desc *p)
-{
-	struct xgmac_extra_stats *x = &priv->xstats;
-	u32 status = le32_to_cpu(p->flags);
-
-	if (!(status & TXDESC_ERROR_SUMMARY))
-		return 0;
-
-	netdev_dbg(priv->dev, "tx desc error = 0x%08x\n", status);
-	if (status & TXDESC_JABBER_TIMEOUT)
-		x->tx_jabber++;
-	if (status & TXDESC_FRAME_FLUSHED)
-		x->tx_frame_flushed++;
-	if (status & TXDESC_UNDERFLOW_ERR)
-		xgmac_dma_flush_tx_fifo(priv->base);
-	if (status & TXDESC_IP_HEADER_ERR)
-		x->tx_ip_header_error++;
-	if (status & TXDESC_LOCAL_FAULT)
-		x->tx_local_fault++;
-	if (status & TXDESC_REMOTE_FAULT)
-		x->tx_remote_fault++;
-	if (status & TXDESC_PAYLOAD_CSUM_ERR)
-		x->tx_payload_error++;
-
-	return -1;
-}
-
-static int desc_get_rx_status(struct xgmac_priv *priv, struct xgmac_dma_desc *p)
-{
-	struct xgmac_extra_stats *x = &priv->xstats;
-	int ret = CHECKSUM_UNNECESSARY;
-	u32 status = le32_to_cpu(p->flags);
-	u32 ext_status = le32_to_cpu(p->ext_status);
-
-	if (status & RXDESC_DA_FILTER_FAIL) {
-		netdev_dbg(priv->dev, "XGMAC RX : Dest Address filter fail\n");
-		x->rx_da_filter_fail++;
-		return -1;
-	}
-
-	/* All frames should fit into a single buffer */
-	if (!(status & RXDESC_FIRST_SEG) || !(status & RXDESC_LAST_SEG))
-		return -1;
-
-	/* Check if packet has checksum already */
-	if ((status & RXDESC_FRAME_TYPE) && (status & RXDESC_EXT_STATUS) &&
-		!(ext_status & RXDESC_IP_PAYLOAD_MASK))
-		ret = CHECKSUM_NONE;
-
-	netdev_dbg(priv->dev, "rx status - frame type=%d, csum = %d, ext stat %08x\n",
-		   (status & RXDESC_FRAME_TYPE) ? 1 : 0, ret, ext_status);
-
-	if (!(status & RXDESC_ERROR_SUMMARY))
-		return ret;
-
-	/* Handle any errors */
-	if (status & (RXDESC_DESCRIPTOR_ERR | RXDESC_OVERFLOW_ERR |
-		RXDESC_GIANT_FRAME | RXDESC_LENGTH_ERR | RXDESC_CRC_ERR))
-		return -1;
-
-	if (status & RXDESC_EXT_STATUS) {
-		if (ext_status & RXDESC_IP_HEADER_ERR)
-			x->rx_ip_header_error++;
-		if (ext_status & RXDESC_IP_PAYLOAD_ERR)
-			x->rx_payload_error++;
-		netdev_dbg(priv->dev, "IP checksum error - stat %08x\n",
-			   ext_status);
-		return CHECKSUM_NONE;
-	}
-
-	return ret;
-}
-
-static inline void xgmac_mac_enable(void __iomem *ioaddr)
-{
-	u32 value = readl(ioaddr + XGMAC_CONTROL);
-	value |= MAC_ENABLE_RX | MAC_ENABLE_TX;
-	writel(value, ioaddr + XGMAC_CONTROL);
-
-	value = readl(ioaddr + XGMAC_DMA_CONTROL);
-	value |= DMA_CONTROL_ST | DMA_CONTROL_SR;
-	writel(value, ioaddr + XGMAC_DMA_CONTROL);
-}
-
-static inline void xgmac_mac_disable(void __iomem *ioaddr)
-{
-	u32 value = readl(ioaddr + XGMAC_DMA_CONTROL);
-	value &= ~(DMA_CONTROL_ST | DMA_CONTROL_SR);
-	writel(value, ioaddr + XGMAC_DMA_CONTROL);
-
-	value = readl(ioaddr + XGMAC_CONTROL);
-	value &= ~(MAC_ENABLE_TX | MAC_ENABLE_RX);
-	writel(value, ioaddr + XGMAC_CONTROL);
-}
-
-static void xgmac_set_mac_addr(void __iomem *ioaddr, unsigned char *addr,
-			       int num)
-{
-	u32 data;
-
-	if (addr) {
-		data = (addr[5] << 8) | addr[4] | (num ? XGMAC_ADDR_AE : 0);
-		writel(data, ioaddr + XGMAC_ADDR_HIGH(num));
-		data = (addr[3] << 24) | (addr[2] << 16) | (addr[1] << 8) | addr[0];
-		writel(data, ioaddr + XGMAC_ADDR_LOW(num));
-	} else {
-		writel(0, ioaddr + XGMAC_ADDR_HIGH(num));
-		writel(0, ioaddr + XGMAC_ADDR_LOW(num));
-	}
-}
-
-static void xgmac_get_mac_addr(void __iomem *ioaddr, unsigned char *addr,
-			       int num)
-{
-	u32 hi_addr, lo_addr;
-
-	/* Read the MAC address from the hardware */
-	hi_addr = readl(ioaddr + XGMAC_ADDR_HIGH(num));
-	lo_addr = readl(ioaddr + XGMAC_ADDR_LOW(num));
-
-	/* Extract the MAC address from the high and low words */
-	addr[0] = lo_addr & 0xff;
-	addr[1] = (lo_addr >> 8) & 0xff;
-	addr[2] = (lo_addr >> 16) & 0xff;
-	addr[3] = (lo_addr >> 24) & 0xff;
-	addr[4] = hi_addr & 0xff;
-	addr[5] = (hi_addr >> 8) & 0xff;
-}
-
-static int xgmac_set_flow_ctrl(struct xgmac_priv *priv, int rx, int tx)
-{
-	u32 reg;
-	unsigned int flow = 0;
-
-	priv->rx_pause = rx;
-	priv->tx_pause = tx;
-
-	if (rx || tx) {
-		if (rx)
-			flow |= XGMAC_FLOW_CTRL_RFE;
-		if (tx)
-			flow |= XGMAC_FLOW_CTRL_TFE;
-
-		flow |= XGMAC_FLOW_CTRL_PLT | XGMAC_FLOW_CTRL_UP;
-		flow |= (PAUSE_TIME << XGMAC_FLOW_CTRL_PT_SHIFT);
-
-		writel(flow, priv->base + XGMAC_FLOW_CTRL);
-
-		reg = readl(priv->base + XGMAC_OMR);
-		reg |= XGMAC_OMR_EFC;
-		writel(reg, priv->base + XGMAC_OMR);
-	} else {
-		writel(0, priv->base + XGMAC_FLOW_CTRL);
-
-		reg = readl(priv->base + XGMAC_OMR);
-		reg &= ~XGMAC_OMR_EFC;
-		writel(reg, priv->base + XGMAC_OMR);
-	}
-
-	return 0;
-}
-
-static void xgmac_rx_refill(struct xgmac_priv *priv)
-{
-	struct xgmac_dma_desc *p;
-	dma_addr_t paddr;
-	int bufsz = priv->dev->mtu + ETH_HLEN + ETH_FCS_LEN;
-
-	while (dma_ring_space(priv->rx_head, priv->rx_tail, DMA_RX_RING_SZ) > 1) {
-		int entry = priv->rx_head;
-		struct sk_buff *skb;
-
-		p = priv->dma_rx + entry;
-
-		if (priv->rx_skbuff[entry] == NULL) {
-			skb = netdev_alloc_skb_ip_align(priv->dev, bufsz);
-			if (unlikely(skb == NULL))
-				break;
-
-			paddr = dma_map_single(priv->device, skb->data,
-					       priv->dma_buf_sz - NET_IP_ALIGN,
-					       DMA_FROM_DEVICE);
-			if (dma_mapping_error(priv->device, paddr)) {
-				dev_kfree_skb_any(skb);
-				break;
-			}
-			priv->rx_skbuff[entry] = skb;
-			desc_set_buf_addr(p, paddr, priv->dma_buf_sz);
-		}
-
-		netdev_dbg(priv->dev, "rx ring: head %d, tail %d\n",
-			priv->rx_head, priv->rx_tail);
-
-		priv->rx_head = dma_ring_incr(priv->rx_head, DMA_RX_RING_SZ);
-		desc_set_rx_owner(p);
-	}
-}
-
-/**
- * init_xgmac_dma_desc_rings - init the RX/TX descriptor rings
- * @dev: net device structure
- * Description:  this function initializes the DMA RX/TX descriptors
- * and allocates the socket buffers.
- */
-static int xgmac_dma_desc_rings_init(struct net_device *dev)
-{
-	struct xgmac_priv *priv = netdev_priv(dev);
-	unsigned int bfsize;
-
-	/* Set the Buffer size according to the MTU;
-	 * The total buffer size including any IP offset must be a multiple
-	 * of 8 bytes.
-	 */
-	bfsize = ALIGN(dev->mtu + ETH_HLEN + ETH_FCS_LEN + NET_IP_ALIGN, 8);
-
-	netdev_dbg(priv->dev, "mtu [%d] bfsize [%d]\n", dev->mtu, bfsize);
-
-	priv->rx_skbuff = kcalloc(DMA_RX_RING_SZ, sizeof(struct sk_buff *),
-				  GFP_KERNEL);
-	if (!priv->rx_skbuff)
-		return -ENOMEM;
-
-	priv->dma_rx = dma_alloc_coherent(priv->device,
-					  DMA_RX_RING_SZ *
-					  sizeof(struct xgmac_dma_desc),
-					  &priv->dma_rx_phy,
-					  GFP_KERNEL);
-	if (!priv->dma_rx)
-		goto err_dma_rx;
-
-	priv->tx_skbuff = kcalloc(DMA_TX_RING_SZ, sizeof(struct sk_buff *),
-				  GFP_KERNEL);
-	if (!priv->tx_skbuff)
-		goto err_tx_skb;
-
-	priv->dma_tx = dma_alloc_coherent(priv->device,
-					  DMA_TX_RING_SZ *
-					  sizeof(struct xgmac_dma_desc),
-					  &priv->dma_tx_phy,
-					  GFP_KERNEL);
-	if (!priv->dma_tx)
-		goto err_dma_tx;
-
-	netdev_dbg(priv->dev, "DMA desc rings: virt addr (Rx %p, "
-	    "Tx %p)\n\tDMA phy addr (Rx 0x%08x, Tx 0x%08x)\n",
-	    priv->dma_rx, priv->dma_tx,
-	    (unsigned int)priv->dma_rx_phy, (unsigned int)priv->dma_tx_phy);
-
-	priv->rx_tail = 0;
-	priv->rx_head = 0;
-	priv->dma_buf_sz = bfsize;
-	desc_init_rx_desc(priv->dma_rx, DMA_RX_RING_SZ, priv->dma_buf_sz);
-	xgmac_rx_refill(priv);
-
-	priv->tx_tail = 0;
-	priv->tx_head = 0;
-	desc_init_tx_desc(priv->dma_tx, DMA_TX_RING_SZ);
-
-	writel(priv->dma_tx_phy, priv->base + XGMAC_DMA_TX_BASE_ADDR);
-	writel(priv->dma_rx_phy, priv->base + XGMAC_DMA_RX_BASE_ADDR);
-
-	return 0;
-
-err_dma_tx:
-	kfree(priv->tx_skbuff);
-err_tx_skb:
-	dma_free_coherent(priv->device,
-			  DMA_RX_RING_SZ * sizeof(struct xgmac_dma_desc),
-			  priv->dma_rx, priv->dma_rx_phy);
-err_dma_rx:
-	kfree(priv->rx_skbuff);
-	return -ENOMEM;
-}
-
-static void xgmac_free_rx_skbufs(struct xgmac_priv *priv)
-{
-	int i;
-	struct xgmac_dma_desc *p;
-
-	if (!priv->rx_skbuff)
-		return;
-
-	for (i = 0; i < DMA_RX_RING_SZ; i++) {
-		struct sk_buff *skb = priv->rx_skbuff[i];
-		if (skb == NULL)
-			continue;
-
-		p = priv->dma_rx + i;
-		dma_unmap_single(priv->device, desc_get_buf_addr(p),
-				 priv->dma_buf_sz - NET_IP_ALIGN, DMA_FROM_DEVICE);
-		dev_kfree_skb_any(skb);
-		priv->rx_skbuff[i] = NULL;
-	}
-}
-
-static void xgmac_free_tx_skbufs(struct xgmac_priv *priv)
-{
-	int i;
-	struct xgmac_dma_desc *p;
-
-	if (!priv->tx_skbuff)
-		return;
-
-	for (i = 0; i < DMA_TX_RING_SZ; i++) {
-		if (priv->tx_skbuff[i] == NULL)
-			continue;
-
-		p = priv->dma_tx + i;
-		if (desc_get_tx_fs(p))
-			dma_unmap_single(priv->device, desc_get_buf_addr(p),
-					 desc_get_buf_len(p), DMA_TO_DEVICE);
-		else
-			dma_unmap_page(priv->device, desc_get_buf_addr(p),
-				       desc_get_buf_len(p), DMA_TO_DEVICE);
-
-		if (desc_get_tx_ls(p))
-			dev_kfree_skb_any(priv->tx_skbuff[i]);
-		priv->tx_skbuff[i] = NULL;
-	}
-}
-
-static void xgmac_free_dma_desc_rings(struct xgmac_priv *priv)
-{
-	/* Release the DMA TX/RX socket buffers */
-	xgmac_free_rx_skbufs(priv);
-	xgmac_free_tx_skbufs(priv);
-
-	/* Free the consistent memory allocated for descriptor rings */
-	if (priv->dma_tx) {
-		dma_free_coherent(priv->device,
-				  DMA_TX_RING_SZ * sizeof(struct xgmac_dma_desc),
-				  priv->dma_tx, priv->dma_tx_phy);
-		priv->dma_tx = NULL;
-	}
-	if (priv->dma_rx) {
-		dma_free_coherent(priv->device,
-				  DMA_RX_RING_SZ * sizeof(struct xgmac_dma_desc),
-				  priv->dma_rx, priv->dma_rx_phy);
-		priv->dma_rx = NULL;
-	}
-	kfree(priv->rx_skbuff);
-	priv->rx_skbuff = NULL;
-	kfree(priv->tx_skbuff);
-	priv->tx_skbuff = NULL;
-}
-
-/**
- * xgmac_tx:
- * @priv: private driver structure
- * Description: it reclaims resources after transmission completes.
- */
-static void xgmac_tx_complete(struct xgmac_priv *priv)
-{
-	while (dma_ring_cnt(priv->tx_head, priv->tx_tail, DMA_TX_RING_SZ)) {
-		unsigned int entry = priv->tx_tail;
-		struct sk_buff *skb = priv->tx_skbuff[entry];
-		struct xgmac_dma_desc *p = priv->dma_tx + entry;
-
-		/* Check if the descriptor is owned by the DMA. */
-		if (desc_get_owner(p))
-			break;
-
-		netdev_dbg(priv->dev, "tx ring: curr %d, dirty %d\n",
-			priv->tx_head, priv->tx_tail);
-
-		if (desc_get_tx_fs(p))
-			dma_unmap_single(priv->device, desc_get_buf_addr(p),
-					 desc_get_buf_len(p), DMA_TO_DEVICE);
-		else
-			dma_unmap_page(priv->device, desc_get_buf_addr(p),
-				       desc_get_buf_len(p), DMA_TO_DEVICE);
-
-		/* Check tx error on the last segment */
-		if (desc_get_tx_ls(p)) {
-			desc_get_tx_status(priv, p);
-			dev_consume_skb_any(skb);
-		}
-
-		priv->tx_skbuff[entry] = NULL;
-		priv->tx_tail = dma_ring_incr(entry, DMA_TX_RING_SZ);
-	}
-
-	/* Ensure tx_tail is visible to xgmac_xmit */
-	smp_mb();
-	if (unlikely(netif_queue_stopped(priv->dev) &&
-	    (tx_dma_ring_space(priv) > MAX_SKB_FRAGS)))
-		netif_wake_queue(priv->dev);
-}
-
-static void xgmac_tx_timeout_work(struct work_struct *work)
-{
-	u32 reg, value;
-	struct xgmac_priv *priv =
-		container_of(work, struct xgmac_priv, tx_timeout_work);
-
-	napi_disable(&priv->napi);
-
-	writel(0, priv->base + XGMAC_DMA_INTR_ENA);
-
-	netif_tx_lock(priv->dev);
-
-	reg = readl(priv->base + XGMAC_DMA_CONTROL);
-	writel(reg & ~DMA_CONTROL_ST, priv->base + XGMAC_DMA_CONTROL);
-	do {
-		value = readl(priv->base + XGMAC_DMA_STATUS) & 0x700000;
-	} while (value && (value != 0x600000));
-
-	xgmac_free_tx_skbufs(priv);
-	desc_init_tx_desc(priv->dma_tx, DMA_TX_RING_SZ);
-	priv->tx_tail = 0;
-	priv->tx_head = 0;
-	writel(priv->dma_tx_phy, priv->base + XGMAC_DMA_TX_BASE_ADDR);
-	writel(reg | DMA_CONTROL_ST, priv->base + XGMAC_DMA_CONTROL);
-
-	writel(DMA_STATUS_TU | DMA_STATUS_TPS | DMA_STATUS_NIS | DMA_STATUS_AIS,
-		priv->base + XGMAC_DMA_STATUS);
-
-	netif_tx_unlock(priv->dev);
-	netif_wake_queue(priv->dev);
-
-	napi_enable(&priv->napi);
-
-	/* Enable interrupts */
-	writel(DMA_INTR_DEFAULT_MASK, priv->base + XGMAC_DMA_STATUS);
-	writel(DMA_INTR_DEFAULT_MASK, priv->base + XGMAC_DMA_INTR_ENA);
-}
-
-static int xgmac_hw_init(struct net_device *dev)
-{
-	u32 value, ctrl;
-	int limit;
-	struct xgmac_priv *priv = netdev_priv(dev);
-	void __iomem *ioaddr = priv->base;
-
-	/* Save the ctrl register value */
-	ctrl = readl(ioaddr + XGMAC_CONTROL) & XGMAC_CONTROL_SPD_MASK;
-
-	/* SW reset */
-	value = DMA_BUS_MODE_SFT_RESET;
-	writel(value, ioaddr + XGMAC_DMA_BUS_MODE);
-	limit = 15000;
-	while (limit-- &&
-		(readl(ioaddr + XGMAC_DMA_BUS_MODE) & DMA_BUS_MODE_SFT_RESET))
-		cpu_relax();
-	if (limit < 0)
-		return -EBUSY;
-
-	value = (0x10 << DMA_BUS_MODE_PBL_SHIFT) |
-		(0x10 << DMA_BUS_MODE_RPBL_SHIFT) |
-		DMA_BUS_MODE_FB | DMA_BUS_MODE_ATDS | DMA_BUS_MODE_AAL;
-	writel(value, ioaddr + XGMAC_DMA_BUS_MODE);
-
-	writel(0, ioaddr + XGMAC_DMA_INTR_ENA);
-
-	/* Mask power mgt interrupt */
-	writel(XGMAC_INT_STAT_PMTIM, ioaddr + XGMAC_INT_STAT);
-
-	/* XGMAC requires AXI bus init. This is a 'magic number' for now */
-	writel(0x0077000E, ioaddr + XGMAC_DMA_AXI_BUS);
-
-	ctrl |= XGMAC_CONTROL_DDIC | XGMAC_CONTROL_JE | XGMAC_CONTROL_ACS |
-		XGMAC_CONTROL_CAR;
-	if (dev->features & NETIF_F_RXCSUM)
-		ctrl |= XGMAC_CONTROL_IPC;
-	writel(ctrl, ioaddr + XGMAC_CONTROL);
-
-	writel(DMA_CONTROL_OSF, ioaddr + XGMAC_DMA_CONTROL);
-
-	/* Set the HW DMA mode and the COE */
-	writel(XGMAC_OMR_TSF | XGMAC_OMR_RFD | XGMAC_OMR_RFA |
-		XGMAC_OMR_RTC_256,
-		ioaddr + XGMAC_OMR);
-
-	/* Reset the MMC counters */
-	writel(1, ioaddr + XGMAC_MMC_CTRL);
-	return 0;
-}
-
-/**
- *  xgmac_open - open entry point of the driver
- *  @dev : pointer to the device structure.
- *  Description:
- *  This function is the open entry point of the driver.
- *  Return value:
- *  0 on success and an appropriate (-)ve integer as defined in errno.h
- *  file on failure.
- */
-static int xgmac_open(struct net_device *dev)
-{
-	int ret;
-	struct xgmac_priv *priv = netdev_priv(dev);
-	void __iomem *ioaddr = priv->base;
-
-	/* Check that the MAC address is valid.  If its not, refuse
-	 * to bring the device up. The user must specify an
-	 * address using the following linux command:
-	 *      ifconfig eth0 hw ether xx:xx:xx:xx:xx:xx  */
-	if (!is_valid_ether_addr(dev->dev_addr)) {
-		eth_hw_addr_random(dev);
-		netdev_dbg(priv->dev, "generated random MAC address %pM\n",
-			dev->dev_addr);
-	}
-
-	memset(&priv->xstats, 0, sizeof(struct xgmac_extra_stats));
-
-	/* Initialize the XGMAC and descriptors */
-	xgmac_hw_init(dev);
-	xgmac_set_mac_addr(ioaddr, dev->dev_addr, 0);
-	xgmac_set_flow_ctrl(priv, priv->rx_pause, priv->tx_pause);
-
-	ret = xgmac_dma_desc_rings_init(dev);
-	if (ret < 0)
-		return ret;
-
-	/* Enable the MAC Rx/Tx */
-	xgmac_mac_enable(ioaddr);
-
-	napi_enable(&priv->napi);
-	netif_start_queue(dev);
-
-	/* Enable interrupts */
-	writel(DMA_INTR_DEFAULT_MASK, ioaddr + XGMAC_DMA_STATUS);
-	writel(DMA_INTR_DEFAULT_MASK, ioaddr + XGMAC_DMA_INTR_ENA);
-
-	return 0;
-}
-
-/**
- *  xgmac_release - close entry point of the driver
- *  @dev : device pointer.
- *  Description:
- *  This is the stop entry point of the driver.
- */
-static int xgmac_stop(struct net_device *dev)
-{
-	struct xgmac_priv *priv = netdev_priv(dev);
-
-	if (readl(priv->base + XGMAC_DMA_INTR_ENA))
-		napi_disable(&priv->napi);
-
-	writel(0, priv->base + XGMAC_DMA_INTR_ENA);
-
-	netif_tx_disable(dev);
-
-	/* Disable the MAC core */
-	xgmac_mac_disable(priv->base);
-
-	/* Release and free the Rx/Tx resources */
-	xgmac_free_dma_desc_rings(priv);
-
-	return 0;
-}
-
-/**
- *  xgmac_xmit:
- *  @skb : the socket buffer
- *  @dev : device pointer
- *  Description : Tx entry point of the driver.
- */
-static netdev_tx_t xgmac_xmit(struct sk_buff *skb, struct net_device *dev)
-{
-	struct xgmac_priv *priv = netdev_priv(dev);
-	unsigned int entry;
-	int i;
-	u32 irq_flag;
-	int nfrags = skb_shinfo(skb)->nr_frags;
-	struct xgmac_dma_desc *desc, *first;
-	unsigned int desc_flags;
-	unsigned int len;
-	dma_addr_t paddr;
-
-	priv->tx_irq_cnt = (priv->tx_irq_cnt + 1) & (DMA_TX_RING_SZ/4 - 1);
-	irq_flag = priv->tx_irq_cnt ? 0 : TXDESC_INTERRUPT;
-
-	desc_flags = (skb->ip_summed == CHECKSUM_PARTIAL) ?
-		TXDESC_CSUM_ALL : 0;
-	entry = priv->tx_head;
-	desc = priv->dma_tx + entry;
-	first = desc;
-
-	len = skb_headlen(skb);
-	paddr = dma_map_single(priv->device, skb->data, len, DMA_TO_DEVICE);
-	if (dma_mapping_error(priv->device, paddr)) {
-		dev_kfree_skb_any(skb);
-		return NETDEV_TX_OK;
-	}
-	priv->tx_skbuff[entry] = skb;
-	desc_set_buf_addr_and_size(desc, paddr, len);
-
-	for (i = 0; i < nfrags; i++) {
-		skb_frag_t *frag = &skb_shinfo(skb)->frags[i];
-
-		len = skb_frag_size(frag);
-
-		paddr = skb_frag_dma_map(priv->device, frag, 0, len,
-					 DMA_TO_DEVICE);
-		if (dma_mapping_error(priv->device, paddr))
-			goto dma_err;
-
-		entry = dma_ring_incr(entry, DMA_TX_RING_SZ);
-		desc = priv->dma_tx + entry;
-		priv->tx_skbuff[entry] = skb;
-
-		desc_set_buf_addr_and_size(desc, paddr, len);
-		if (i < (nfrags - 1))
-			desc_set_tx_owner(desc, desc_flags);
-	}
-
-	/* Interrupt on completition only for the latest segment */
-	if (desc != first)
-		desc_set_tx_owner(desc, desc_flags |
-			TXDESC_LAST_SEG | irq_flag);
-	else
-		desc_flags |= TXDESC_LAST_SEG | irq_flag;
-
-	/* Set owner on first desc last to avoid race condition */
-	wmb();
-	desc_set_tx_owner(first, desc_flags | TXDESC_FIRST_SEG);
-
-	writel(1, priv->base + XGMAC_DMA_TX_POLL);
-
-	priv->tx_head = dma_ring_incr(entry, DMA_TX_RING_SZ);
-
-	/* Ensure tx_head update is visible to tx completion */
-	smp_mb();
-	if (unlikely(tx_dma_ring_space(priv) <= MAX_SKB_FRAGS)) {
-		netif_stop_queue(dev);
-		/* Ensure netif_stop_queue is visible to tx completion */
-		smp_mb();
-		if (tx_dma_ring_space(priv) > MAX_SKB_FRAGS)
-			netif_start_queue(dev);
-	}
-	return NETDEV_TX_OK;
-
-dma_err:
-	entry = priv->tx_head;
-	for ( ; i > 0; i--) {
-		entry = dma_ring_incr(entry, DMA_TX_RING_SZ);
-		desc = priv->dma_tx + entry;
-		priv->tx_skbuff[entry] = NULL;
-		dma_unmap_page(priv->device, desc_get_buf_addr(desc),
-			       desc_get_buf_len(desc), DMA_TO_DEVICE);
-		desc_clear_tx_owner(desc);
-	}
-	desc = first;
-	dma_unmap_single(priv->device, desc_get_buf_addr(desc),
-			 desc_get_buf_len(desc), DMA_TO_DEVICE);
-	dev_kfree_skb_any(skb);
-	return NETDEV_TX_OK;
-}
-
-static int xgmac_rx(struct xgmac_priv *priv, int limit)
-{
-	unsigned int entry;
-	unsigned int count = 0;
-	struct xgmac_dma_desc *p;
-
-	while (count < limit) {
-		int ip_checksum;
-		struct sk_buff *skb;
-		int frame_len;
-
-		if (!dma_ring_cnt(priv->rx_head, priv->rx_tail, DMA_RX_RING_SZ))
-			break;
-
-		entry = priv->rx_tail;
-		p = priv->dma_rx + entry;
-		if (desc_get_owner(p))
-			break;
-
-		count++;
-		priv->rx_tail = dma_ring_incr(priv->rx_tail, DMA_RX_RING_SZ);
-
-		/* read the status of the incoming frame */
-		ip_checksum = desc_get_rx_status(priv, p);
-		if (ip_checksum < 0)
-			continue;
-
-		skb = priv->rx_skbuff[entry];
-		if (unlikely(!skb)) {
-			netdev_err(priv->dev, "Inconsistent Rx descriptor chain\n");
-			break;
-		}
-		priv->rx_skbuff[entry] = NULL;
-
-		frame_len = desc_get_rx_frame_len(p);
-		netdev_dbg(priv->dev, "RX frame size %d, COE status: %d\n",
-			frame_len, ip_checksum);
-
-		skb_put(skb, frame_len);
-		dma_unmap_single(priv->device, desc_get_buf_addr(p),
-				 priv->dma_buf_sz - NET_IP_ALIGN, DMA_FROM_DEVICE);
-
-		skb->protocol = eth_type_trans(skb, priv->dev);
-		skb->ip_summed = ip_checksum;
-		if (ip_checksum == CHECKSUM_NONE)
-			netif_receive_skb(skb);
-		else
-			napi_gro_receive(&priv->napi, skb);
-	}
-
-	xgmac_rx_refill(priv);
-
-	return count;
-}
-
-/**
- *  xgmac_poll - xgmac poll method (NAPI)
- *  @napi : pointer to the napi structure.
- *  @budget : maximum number of packets that the current CPU can receive from
- *	      all interfaces.
- *  Description :
- *   This function implements the the reception process.
- *   Also it runs the TX completion thread
- */
-static int xgmac_poll(struct napi_struct *napi, int budget)
-{
-	struct xgmac_priv *priv = container_of(napi,
-				       struct xgmac_priv, napi);
-	int work_done = 0;
-
-	xgmac_tx_complete(priv);
-	work_done = xgmac_rx(priv, budget);
-
-	if (work_done < budget) {
-		napi_complete_done(napi, work_done);
-		__raw_writel(DMA_INTR_DEFAULT_MASK, priv->base + XGMAC_DMA_INTR_ENA);
-	}
-	return work_done;
-}
-
-/**
- *  xgmac_tx_timeout
- *  @dev : Pointer to net device structure
- *  Description: this function is called when a packet transmission fails to
- *   complete within a reasonable tmrate. The driver will mark the error in the
- *   netdev structure and arrange for the device to be reset to a sane state
- *   in order to transmit a new packet.
- */
-static void xgmac_tx_timeout(struct net_device *dev, unsigned int txqueue)
-{
-	struct xgmac_priv *priv = netdev_priv(dev);
-	schedule_work(&priv->tx_timeout_work);
-}
-
-/**
- *  xgmac_set_rx_mode - entry point for multicast addressing
- *  @dev : pointer to the device structure
- *  Description:
- *  This function is a driver entry point which gets called by the kernel
- *  whenever multicast addresses must be enabled/disabled.
- *  Return value:
- *  void.
- */
-static void xgmac_set_rx_mode(struct net_device *dev)
-{
-	int i;
-	struct xgmac_priv *priv = netdev_priv(dev);
-	void __iomem *ioaddr = priv->base;
-	unsigned int value = 0;
-	u32 hash_filter[XGMAC_NUM_HASH];
-	int reg = 1;
-	struct netdev_hw_addr *ha;
-	bool use_hash = false;
-
-	netdev_dbg(priv->dev, "# mcasts %d, # unicast %d\n",
-		 netdev_mc_count(dev), netdev_uc_count(dev));
-
-	if (dev->flags & IFF_PROMISC)
-		value |= XGMAC_FRAME_FILTER_PR;
-
-	memset(hash_filter, 0, sizeof(hash_filter));
-
-	if (netdev_uc_count(dev) > priv->max_macs) {
-		use_hash = true;
-		value |= XGMAC_FRAME_FILTER_HUC | XGMAC_FRAME_FILTER_HPF;
-	}
-	netdev_for_each_uc_addr(ha, dev) {
-		if (use_hash) {
-			u32 bit_nr = ~ether_crc(ETH_ALEN, ha->addr) >> 23;
-
-			/* The most significant 4 bits determine the register to
-			 * use (H/L) while the other 5 bits determine the bit
-			 * within the register. */
-			hash_filter[bit_nr >> 5] |= 1 << (bit_nr & 31);
-		} else {
-			xgmac_set_mac_addr(ioaddr, ha->addr, reg);
-			reg++;
-		}
-	}
-
-	if (dev->flags & IFF_ALLMULTI) {
-		value |= XGMAC_FRAME_FILTER_PM;
-		goto out;
-	}
-
-	if ((netdev_mc_count(dev) + reg - 1) > priv->max_macs) {
-		use_hash = true;
-		value |= XGMAC_FRAME_FILTER_HMC | XGMAC_FRAME_FILTER_HPF;
-	} else {
-		use_hash = false;
-	}
-	netdev_for_each_mc_addr(ha, dev) {
-		if (use_hash) {
-			u32 bit_nr = ~ether_crc(ETH_ALEN, ha->addr) >> 23;
-
-			/* The most significant 4 bits determine the register to
-			 * use (H/L) while the other 5 bits determine the bit
-			 * within the register. */
-			hash_filter[bit_nr >> 5] |= 1 << (bit_nr & 31);
-		} else {
-			xgmac_set_mac_addr(ioaddr, ha->addr, reg);
-			reg++;
-		}
-	}
-
-out:
-	for (i = reg; i <= priv->max_macs; i++)
-		xgmac_set_mac_addr(ioaddr, NULL, i);
-	for (i = 0; i < XGMAC_NUM_HASH; i++)
-		writel(hash_filter[i], ioaddr + XGMAC_HASH(i));
-
-	writel(value, ioaddr + XGMAC_FRAME_FILTER);
-}
-
-/**
- *  xgmac_change_mtu - entry point to change MTU size for the device.
- *  @dev : device pointer.
- *  @new_mtu : the new MTU size for the device.
- *  Description: the Maximum Transfer Unit (MTU) is used by the network layer
- *  to drive packet transmission. Ethernet has an MTU of 1500 octets
- *  (ETH_DATA_LEN). This value can be changed with ifconfig.
- *  Return value:
- *  0 on success and an appropriate (-)ve integer as defined in errno.h
- *  file on failure.
- */
-static int xgmac_change_mtu(struct net_device *dev, int new_mtu)
-{
-	/* Stop everything, get ready to change the MTU */
-	if (!netif_running(dev))
-		return 0;
-
-	/* Bring interface down, change mtu and bring interface back up */
-	xgmac_stop(dev);
-	dev->mtu = new_mtu;
-	return xgmac_open(dev);
-}
-
-static irqreturn_t xgmac_pmt_interrupt(int irq, void *dev_id)
-{
-	u32 intr_status;
-	struct net_device *dev = (struct net_device *)dev_id;
-	struct xgmac_priv *priv = netdev_priv(dev);
-	void __iomem *ioaddr = priv->base;
-
-	intr_status = __raw_readl(ioaddr + XGMAC_INT_STAT);
-	if (intr_status & XGMAC_INT_STAT_PMT) {
-		netdev_dbg(priv->dev, "received Magic frame\n");
-		/* clear the PMT bits 5 and 6 by reading the PMT */
-		readl(ioaddr + XGMAC_PMT);
-	}
-	return IRQ_HANDLED;
-}
-
-static irqreturn_t xgmac_interrupt(int irq, void *dev_id)
-{
-	u32 intr_status;
-	struct net_device *dev = (struct net_device *)dev_id;
-	struct xgmac_priv *priv = netdev_priv(dev);
-	struct xgmac_extra_stats *x = &priv->xstats;
-
-	/* read the status register (CSR5) */
-	intr_status = __raw_readl(priv->base + XGMAC_DMA_STATUS);
-	intr_status &= __raw_readl(priv->base + XGMAC_DMA_INTR_ENA);
-	__raw_writel(intr_status, priv->base + XGMAC_DMA_STATUS);
-
-	/* It displays the DMA process states (CSR5 register) */
-	/* ABNORMAL interrupts */
-	if (unlikely(intr_status & DMA_STATUS_AIS)) {
-		if (intr_status & DMA_STATUS_TJT) {
-			netdev_err(priv->dev, "transmit jabber\n");
-			x->tx_jabber++;
-		}
-		if (intr_status & DMA_STATUS_RU)
-			x->rx_buf_unav++;
-		if (intr_status & DMA_STATUS_RPS) {
-			netdev_err(priv->dev, "receive process stopped\n");
-			x->rx_process_stopped++;
-		}
-		if (intr_status & DMA_STATUS_ETI) {
-			netdev_err(priv->dev, "transmit early interrupt\n");
-			x->tx_early++;
-		}
-		if (intr_status & DMA_STATUS_TPS) {
-			netdev_err(priv->dev, "transmit process stopped\n");
-			x->tx_process_stopped++;
-			schedule_work(&priv->tx_timeout_work);
-		}
-		if (intr_status & DMA_STATUS_FBI) {
-			netdev_err(priv->dev, "fatal bus error\n");
-			x->fatal_bus_error++;
-		}
-	}
-
-	/* TX/RX NORMAL interrupts */
-	if (intr_status & (DMA_STATUS_RI | DMA_STATUS_TU | DMA_STATUS_TI)) {
-		__raw_writel(DMA_INTR_ABNORMAL, priv->base + XGMAC_DMA_INTR_ENA);
-		napi_schedule(&priv->napi);
-	}
-
-	return IRQ_HANDLED;
-}
-
-#ifdef CONFIG_NET_POLL_CONTROLLER
-/* Polling receive - used by NETCONSOLE and other diagnostic tools
- * to allow network I/O with interrupts disabled. */
-static void xgmac_poll_controller(struct net_device *dev)
-{
-	disable_irq(dev->irq);
-	xgmac_interrupt(dev->irq, dev);
-	enable_irq(dev->irq);
-}
-#endif
-
-static void
-xgmac_get_stats64(struct net_device *dev,
-		  struct rtnl_link_stats64 *storage)
-{
-	struct xgmac_priv *priv = netdev_priv(dev);
-	void __iomem *base = priv->base;
-	u32 count;
-
-	spin_lock_bh(&priv->stats_lock);
-	writel(XGMAC_MMC_CTRL_CNT_FRZ, base + XGMAC_MMC_CTRL);
-
-	storage->rx_bytes = readl(base + XGMAC_MMC_RXOCTET_G_LO);
-	storage->rx_bytes |= (u64)(readl(base + XGMAC_MMC_RXOCTET_G_HI)) << 32;
-
-	storage->rx_packets = readl(base + XGMAC_MMC_RXFRAME_GB_LO);
-	storage->multicast = readl(base + XGMAC_MMC_RXMCFRAME_G);
-	storage->rx_crc_errors = readl(base + XGMAC_MMC_RXCRCERR);
-	storage->rx_length_errors = readl(base + XGMAC_MMC_RXLENGTHERR);
-	storage->rx_missed_errors = readl(base + XGMAC_MMC_RXOVERFLOW);
-
-	storage->tx_bytes = readl(base + XGMAC_MMC_TXOCTET_G_LO);
-	storage->tx_bytes |= (u64)(readl(base + XGMAC_MMC_TXOCTET_G_HI)) << 32;
-
-	count = readl(base + XGMAC_MMC_TXFRAME_GB_LO);
-	storage->tx_errors = count - readl(base + XGMAC_MMC_TXFRAME_G_LO);
-	storage->tx_packets = count;
-	storage->tx_fifo_errors = readl(base + XGMAC_MMC_TXUNDERFLOW);
-
-	writel(0, base + XGMAC_MMC_CTRL);
-	spin_unlock_bh(&priv->stats_lock);
-}
-
-static int xgmac_set_mac_address(struct net_device *dev, void *p)
-{
-	struct xgmac_priv *priv = netdev_priv(dev);
-	void __iomem *ioaddr = priv->base;
-	struct sockaddr *addr = p;
-
-	if (!is_valid_ether_addr(addr->sa_data))
-		return -EADDRNOTAVAIL;
-
-	memcpy(dev->dev_addr, addr->sa_data, dev->addr_len);
-
-	xgmac_set_mac_addr(ioaddr, dev->dev_addr, 0);
-
-	return 0;
-}
-
-static int xgmac_set_features(struct net_device *dev, netdev_features_t features)
-{
-	u32 ctrl;
-	struct xgmac_priv *priv = netdev_priv(dev);
-	void __iomem *ioaddr = priv->base;
-	netdev_features_t changed = dev->features ^ features;
-
-	if (!(changed & NETIF_F_RXCSUM))
-		return 0;
-
-	ctrl = readl(ioaddr + XGMAC_CONTROL);
-	if (features & NETIF_F_RXCSUM)
-		ctrl |= XGMAC_CONTROL_IPC;
-	else
-		ctrl &= ~XGMAC_CONTROL_IPC;
-	writel(ctrl, ioaddr + XGMAC_CONTROL);
-
-	return 0;
-}
-
-static const struct net_device_ops xgmac_netdev_ops = {
-	.ndo_open = xgmac_open,
-	.ndo_start_xmit = xgmac_xmit,
-	.ndo_stop = xgmac_stop,
-	.ndo_change_mtu = xgmac_change_mtu,
-	.ndo_set_rx_mode = xgmac_set_rx_mode,
-	.ndo_tx_timeout = xgmac_tx_timeout,
-	.ndo_get_stats64 = xgmac_get_stats64,
-#ifdef CONFIG_NET_POLL_CONTROLLER
-	.ndo_poll_controller = xgmac_poll_controller,
-#endif
-	.ndo_set_mac_address = xgmac_set_mac_address,
-	.ndo_set_features = xgmac_set_features,
-};
-
-static int xgmac_ethtool_get_link_ksettings(struct net_device *dev,
-					    struct ethtool_link_ksettings *cmd)
-{
-	cmd->base.autoneg = 0;
-	cmd->base.duplex = DUPLEX_FULL;
-	cmd->base.speed = 10000;
-	ethtool_convert_legacy_u32_to_link_mode(cmd->link_modes.supported, 0);
-	ethtool_convert_legacy_u32_to_link_mode(cmd->link_modes.advertising, 0);
-	return 0;
-}
-
-static void xgmac_get_pauseparam(struct net_device *netdev,
-				      struct ethtool_pauseparam *pause)
-{
-	struct xgmac_priv *priv = netdev_priv(netdev);
-
-	pause->rx_pause = priv->rx_pause;
-	pause->tx_pause = priv->tx_pause;
-}
-
-static int xgmac_set_pauseparam(struct net_device *netdev,
-				     struct ethtool_pauseparam *pause)
-{
-	struct xgmac_priv *priv = netdev_priv(netdev);
-
-	if (pause->autoneg)
-		return -EINVAL;
-
-	return xgmac_set_flow_ctrl(priv, pause->rx_pause, pause->tx_pause);
-}
-
-struct xgmac_stats {
-	char stat_string[ETH_GSTRING_LEN];
-	int stat_offset;
-	bool is_reg;
-};
-
-#define XGMAC_STAT(m)	\
-	{ #m, offsetof(struct xgmac_priv, xstats.m), false }
-#define XGMAC_HW_STAT(m, reg_offset)	\
-	{ #m, reg_offset, true }
-
-static const struct xgmac_stats xgmac_gstrings_stats[] = {
-	XGMAC_STAT(tx_frame_flushed),
-	XGMAC_STAT(tx_payload_error),
-	XGMAC_STAT(tx_ip_header_error),
-	XGMAC_STAT(tx_local_fault),
-	XGMAC_STAT(tx_remote_fault),
-	XGMAC_STAT(tx_early),
-	XGMAC_STAT(tx_process_stopped),
-	XGMAC_STAT(tx_jabber),
-	XGMAC_STAT(rx_buf_unav),
-	XGMAC_STAT(rx_process_stopped),
-	XGMAC_STAT(rx_payload_error),
-	XGMAC_STAT(rx_ip_header_error),
-	XGMAC_STAT(rx_da_filter_fail),
-	XGMAC_STAT(fatal_bus_error),
-	XGMAC_HW_STAT(rx_watchdog, XGMAC_MMC_RXWATCHDOG),
-	XGMAC_HW_STAT(tx_vlan, XGMAC_MMC_TXVLANFRAME),
-	XGMAC_HW_STAT(rx_vlan, XGMAC_MMC_RXVLANFRAME),
-	XGMAC_HW_STAT(tx_pause, XGMAC_MMC_TXPAUSEFRAME),
-	XGMAC_HW_STAT(rx_pause, XGMAC_MMC_RXPAUSEFRAME),
-};
-#define XGMAC_STATS_LEN ARRAY_SIZE(xgmac_gstrings_stats)
-
-static void xgmac_get_ethtool_stats(struct net_device *dev,
-					 struct ethtool_stats *dummy,
-					 u64 *data)
-{
-	struct xgmac_priv *priv = netdev_priv(dev);
-	void *p = priv;
-	int i;
-
-	for (i = 0; i < XGMAC_STATS_LEN; i++) {
-		if (xgmac_gstrings_stats[i].is_reg)
-			*data++ = readl(priv->base +
-				xgmac_gstrings_stats[i].stat_offset);
-		else
-			*data++ = *(u32 *)(p +
-				xgmac_gstrings_stats[i].stat_offset);
-	}
-}
-
-static int xgmac_get_sset_count(struct net_device *netdev, int sset)
-{
-	switch (sset) {
-	case ETH_SS_STATS:
-		return XGMAC_STATS_LEN;
-	default:
-		return -EINVAL;
-	}
-}
-
-static void xgmac_get_strings(struct net_device *dev, u32 stringset,
-				   u8 *data)
-{
-	int i;
-	u8 *p = data;
-
-	switch (stringset) {
-	case ETH_SS_STATS:
-		for (i = 0; i < XGMAC_STATS_LEN; i++) {
-			memcpy(p, xgmac_gstrings_stats[i].stat_string,
-			       ETH_GSTRING_LEN);
-			p += ETH_GSTRING_LEN;
-		}
-		break;
-	default:
-		WARN_ON(1);
-		break;
-	}
-}
-
-static void xgmac_get_wol(struct net_device *dev,
-			       struct ethtool_wolinfo *wol)
-{
-	struct xgmac_priv *priv = netdev_priv(dev);
-
-	if (device_can_wakeup(priv->device)) {
-		wol->supported = WAKE_MAGIC | WAKE_UCAST;
-		wol->wolopts = priv->wolopts;
-	}
-}
-
-static int xgmac_set_wol(struct net_device *dev,
-			      struct ethtool_wolinfo *wol)
-{
-	struct xgmac_priv *priv = netdev_priv(dev);
-	u32 support = WAKE_MAGIC | WAKE_UCAST;
-
-	if (!device_can_wakeup(priv->device))
-		return -ENOTSUPP;
-
-	if (wol->wolopts & ~support)
-		return -EINVAL;
-
-	priv->wolopts = wol->wolopts;
-
-	if (wol->wolopts) {
-		device_set_wakeup_enable(priv->device, 1);
-		enable_irq_wake(dev->irq);
-	} else {
-		device_set_wakeup_enable(priv->device, 0);
-		disable_irq_wake(dev->irq);
-	}
-
-	return 0;
-}
-
-static const struct ethtool_ops xgmac_ethtool_ops = {
-	.get_link = ethtool_op_get_link,
-	.get_pauseparam = xgmac_get_pauseparam,
-	.set_pauseparam = xgmac_set_pauseparam,
-	.get_ethtool_stats = xgmac_get_ethtool_stats,
-	.get_strings = xgmac_get_strings,
-	.get_wol = xgmac_get_wol,
-	.set_wol = xgmac_set_wol,
-	.get_sset_count = xgmac_get_sset_count,
-	.get_link_ksettings = xgmac_ethtool_get_link_ksettings,
-};
-
-/**
- * xgmac_probe
- * @pdev: platform device pointer
- * Description: the driver is initialized through platform_device.
- */
-static int xgmac_probe(struct platform_device *pdev)
-{
-	int ret = 0;
-	struct resource *res;
-	struct net_device *ndev = NULL;
-	struct xgmac_priv *priv = NULL;
-	u32 uid;
-
-	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	if (!res)
-		return -ENODEV;
-
-	if (!request_mem_region(res->start, resource_size(res), pdev->name))
-		return -EBUSY;
-
-	ndev = alloc_etherdev(sizeof(struct xgmac_priv));
-	if (!ndev) {
-		ret = -ENOMEM;
-		goto err_alloc;
-	}
-
-	SET_NETDEV_DEV(ndev, &pdev->dev);
-	priv = netdev_priv(ndev);
-	platform_set_drvdata(pdev, ndev);
-	ndev->netdev_ops = &xgmac_netdev_ops;
-	ndev->ethtool_ops = &xgmac_ethtool_ops;
-	spin_lock_init(&priv->stats_lock);
-	INIT_WORK(&priv->tx_timeout_work, xgmac_tx_timeout_work);
-
-	priv->device = &pdev->dev;
-	priv->dev = ndev;
-	priv->rx_pause = 1;
-	priv->tx_pause = 1;
-
-	priv->base = ioremap(res->start, resource_size(res));
-	if (!priv->base) {
-		netdev_err(ndev, "ioremap failed\n");
-		ret = -ENOMEM;
-		goto err_io;
-	}
-
-	uid = readl(priv->base + XGMAC_VERSION);
-	netdev_info(ndev, "h/w version is 0x%x\n", uid);
-
-	/* Figure out how many valid mac address filter registers we have */
-	writel(1, priv->base + XGMAC_ADDR_HIGH(31));
-	if (readl(priv->base + XGMAC_ADDR_HIGH(31)) == 1)
-		priv->max_macs = 31;
-	else
-		priv->max_macs = 7;
-
-	writel(0, priv->base + XGMAC_DMA_INTR_ENA);
-	ndev->irq = platform_get_irq(pdev, 0);
-	if (ndev->irq == -ENXIO) {
-		netdev_err(ndev, "No irq resource\n");
-		ret = ndev->irq;
-		goto err_irq;
-	}
-
-	ret = request_irq(ndev->irq, xgmac_interrupt, 0,
-			  dev_name(&pdev->dev), ndev);
-	if (ret < 0) {
-		netdev_err(ndev, "Could not request irq %d - ret %d)\n",
-			ndev->irq, ret);
-		goto err_irq;
-	}
-
-	priv->pmt_irq = platform_get_irq(pdev, 1);
-	if (priv->pmt_irq == -ENXIO) {
-		netdev_err(ndev, "No pmt irq resource\n");
-		ret = priv->pmt_irq;
-		goto err_pmt_irq;
-	}
-
-	ret = request_irq(priv->pmt_irq, xgmac_pmt_interrupt, 0,
-			  dev_name(&pdev->dev), ndev);
-	if (ret < 0) {
-		netdev_err(ndev, "Could not request irq %d - ret %d)\n",
-			priv->pmt_irq, ret);
-		goto err_pmt_irq;
-	}
-
-	device_set_wakeup_capable(&pdev->dev, 1);
-	if (device_can_wakeup(priv->device))
-		priv->wolopts = WAKE_MAGIC;	/* Magic Frame as default */
-
-	ndev->hw_features = NETIF_F_SG | NETIF_F_HIGHDMA;
-	if (readl(priv->base + XGMAC_DMA_HW_FEATURE) & DMA_HW_FEAT_TXCOESEL)
-		ndev->hw_features |= NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM |
-				     NETIF_F_RXCSUM;
-	ndev->features |= ndev->hw_features;
-	ndev->priv_flags |= IFF_UNICAST_FLT;
-
-	/* MTU range: 46 - 9000 */
-	ndev->min_mtu = ETH_ZLEN - ETH_HLEN;
-	ndev->max_mtu = XGMAC_MAX_MTU;
-
-	/* Get the MAC address */
-	xgmac_get_mac_addr(priv->base, ndev->dev_addr, 0);
-	if (!is_valid_ether_addr(ndev->dev_addr))
-		netdev_warn(ndev, "MAC address %pM not valid",
-			 ndev->dev_addr);
-
-	netif_napi_add(ndev, &priv->napi, xgmac_poll, 64);
-	ret = register_netdev(ndev);
-	if (ret)
-		goto err_reg;
-
-	return 0;
-
-err_reg:
-	netif_napi_del(&priv->napi);
-	free_irq(priv->pmt_irq, ndev);
-err_pmt_irq:
-	free_irq(ndev->irq, ndev);
-err_irq:
-	iounmap(priv->base);
-err_io:
-	free_netdev(ndev);
-err_alloc:
-	release_mem_region(res->start, resource_size(res));
-	return ret;
-}
-
-/**
- * xgmac_dvr_remove
- * @pdev: platform device pointer
- * Description: this function resets the TX/RX processes, disables the MAC RX/TX
- * changes the link status, releases the DMA descriptor rings,
- * unregisters the MDIO bus and unmaps the allocated memory.
- */
-static int xgmac_remove(struct platform_device *pdev)
-{
-	struct net_device *ndev = platform_get_drvdata(pdev);
-	struct xgmac_priv *priv = netdev_priv(ndev);
-	struct resource *res;
-
-	xgmac_mac_disable(priv->base);
-
-	/* Free the IRQ lines */
-	free_irq(ndev->irq, ndev);
-	free_irq(priv->pmt_irq, ndev);
-
-	unregister_netdev(ndev);
-	netif_napi_del(&priv->napi);
-
-	iounmap(priv->base);
-	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	release_mem_region(res->start, resource_size(res));
-
-	free_netdev(ndev);
-
-	return 0;
-}
-
-#ifdef CONFIG_PM_SLEEP
-static void xgmac_pmt(void __iomem *ioaddr, unsigned long mode)
-{
-	unsigned int pmt = 0;
-
-	if (mode & WAKE_MAGIC)
-		pmt |= XGMAC_PMT_POWERDOWN | XGMAC_PMT_MAGIC_PKT_EN;
-	if (mode & WAKE_UCAST)
-		pmt |= XGMAC_PMT_POWERDOWN | XGMAC_PMT_GLBL_UNICAST;
-
-	writel(pmt, ioaddr + XGMAC_PMT);
-}
-
-static int xgmac_suspend(struct device *dev)
-{
-	struct net_device *ndev = dev_get_drvdata(dev);
-	struct xgmac_priv *priv = netdev_priv(ndev);
-	u32 value;
-
-	if (!ndev || !netif_running(ndev))
-		return 0;
-
-	netif_device_detach(ndev);
-	napi_disable(&priv->napi);
-	writel(0, priv->base + XGMAC_DMA_INTR_ENA);
-
-	if (device_may_wakeup(priv->device)) {
-		/* Stop TX/RX DMA Only */
-		value = readl(priv->base + XGMAC_DMA_CONTROL);
-		value &= ~(DMA_CONTROL_ST | DMA_CONTROL_SR);
-		writel(value, priv->base + XGMAC_DMA_CONTROL);
-
-		xgmac_pmt(priv->base, priv->wolopts);
-	} else
-		xgmac_mac_disable(priv->base);
-
-	return 0;
-}
-
-static int xgmac_resume(struct device *dev)
-{
-	struct net_device *ndev = dev_get_drvdata(dev);
-	struct xgmac_priv *priv = netdev_priv(ndev);
-	void __iomem *ioaddr = priv->base;
-
-	if (!netif_running(ndev))
-		return 0;
-
-	xgmac_pmt(ioaddr, 0);
-
-	/* Enable the MAC and DMA */
-	xgmac_mac_enable(ioaddr);
-	writel(DMA_INTR_DEFAULT_MASK, ioaddr + XGMAC_DMA_STATUS);
-	writel(DMA_INTR_DEFAULT_MASK, ioaddr + XGMAC_DMA_INTR_ENA);
-
-	netif_device_attach(ndev);
-	napi_enable(&priv->napi);
-
-	return 0;
-}
-#endif /* CONFIG_PM_SLEEP */
-
-static SIMPLE_DEV_PM_OPS(xgmac_pm_ops, xgmac_suspend, xgmac_resume);
-
-static const struct of_device_id xgmac_of_match[] = {
-	{ .compatible = "calxeda,hb-xgmac", },
-	{},
-};
-MODULE_DEVICE_TABLE(of, xgmac_of_match);
-
-static struct platform_driver xgmac_driver = {
-	.driver = {
-		.name = "calxedaxgmac",
-		.of_match_table = xgmac_of_match,
-		.pm = &xgmac_pm_ops,
-	},
-	.probe = xgmac_probe,
-	.remove = xgmac_remove,
-};
-
-module_platform_driver(xgmac_driver);
-
-MODULE_AUTHOR("Calxeda, Inc.");
-MODULE_DESCRIPTION("Calxeda 10G XGMAC driver");
-MODULE_LICENSE("GPL v2");

From patchwork Tue Feb 18 17:13:18 2020
Content-Type: text/plain; charset="utf-8"
MIME-Version: 1.0
Content-Transfer-Encoding: 7bit
X-Patchwork-Submitter: Rob Herring <robh@kernel.org>
X-Patchwork-Id: 11389077
Return-Path: <SRS0=NRU2=4G=vger.kernel.org=kvm-owner@kernel.org>
Received: from mail.kernel.org (pdx-korg-mail-1.web.codeaurora.org
 [172.30.200.123])
	by pdx-korg-patchwork-2.web.codeaurora.org (Postfix) with ESMTP id 8D40B92A
	for <patchwork-kvm@patchwork.kernel.org>;
 Tue, 18 Feb 2020 17:14:28 +0000 (UTC)
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.kernel.org (Postfix) with ESMTP id 5C5F724654
	for <patchwork-kvm@patchwork.kernel.org>;
 Tue, 18 Feb 2020 17:14:28 +0000 (UTC)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple; d=kernel.org;
	s=default; t=1582046068;
	bh=nbHREpyg9JimnwnI/nPcT90CEwrvNVBdPizgOJxL6kE=;
	h=From:To:Cc:Subject:Date:In-Reply-To:References:List-ID:From;
	b=xFXyTh105/KvZkctKtgxYV0NLMsRbPkpLuZW+BQwUMLyA1GxQLgFMjNx3TO6cB/SS
	 uHHPyzxtFBzg1Zb1LcPCutEQgMm2d7k6kAKWANZsUCg9Py0usyHyGIWwwk4TEC3Ggq
	 QtJ/cnAmBWJ3Xyr0ZimqRdP3ROcOkOhvO1RzAl6s=
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S1727206AbgBRROW (ORCPT
        <rfc822;patchwork-kvm@patchwork.kernel.org>);
        Tue, 18 Feb 2020 12:14:22 -0500
Received: from mail-ot1-f68.google.com ([209.85.210.68]:40361 "EHLO
        mail-ot1-f68.google.com" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S1727488AbgBRRNi (ORCPT <rfc822;kvm@vger.kernel.org>);
        Tue, 18 Feb 2020 12:13:38 -0500
Received: by mail-ot1-f68.google.com with SMTP id i6so20247025otr.7;
        Tue, 18 Feb 2020 09:13:37 -0800 (PST)
X-Google-DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
        d=1e100.net; s=20161025;
        h=x-gm-message-state:from:to:cc:subject:date:message-id:in-reply-to
         :references:mime-version:content-transfer-encoding;
        bh=u8D2FPtNZ0VMBn5UkeqSg7CSDs/wZAjBSTTCQDmiSkY=;
        b=eyn6Ia268py7xlpLA8tqbDqJJSSLK5C60VrqcXGDlAbKlm31cTS2Qv6bB5Jk3gSO00
         XAeAxlrXmJTtbq3xnxOrexH4sS8b2aynAiSRLsGvvCQLDTr/vAJsmOdpBnZuH/UvKstq
         JdHjXbpL1BhNuqYpsScd8nBLgjciEXsUnkQ1esdkgwSm1qYLSMkPXNFMf61jGBLdxP/a
         968TK4URNPOXPP038wET6ShZ1+uvrihBvA8DacKgUWcjdNTQJvLqH6ZhGKtmxq7DhuWu
         AWPW1ZULxnuntUDqhBrWuFouj2poa5YMUiYn3A2VcZiI/8F3rY2unUejlxaLsSclwcMA
         +TrA==
X-Gm-Message-State: APjAAAW8ExL+sPFYv+ek2ABsN6y2Db8CsNxHYl2j2lkIa9JlUvZDy+pK
        3mCb7psTmDzgWGbcZa7kmA==
X-Google-Smtp-Source: 
 APXvYqw6TNQhn8784qV+7u3WFCDSuqFfYxpVsfN96SobcjyzzV4x9MxcI5ZxKLnqYBrEuZO3mSlkJg==
X-Received: by 2002:a9d:7386:: with SMTP id j6mr16115366otk.336.1582046016817;
        Tue, 18 Feb 2020 09:13:36 -0800 (PST)
Received: from xps15.herring.priv (24-155-109-49.dyn.grandenetworks.net.
 [24.155.109.49])
        by smtp.googlemail.com with ESMTPSA id
 y25sm1545755oto.27.2020.02.18.09.13.35
        (version=TLS1_3 cipher=TLS_AES_256_GCM_SHA384 bits=256/256);
        Tue, 18 Feb 2020 09:13:36 -0800 (PST)
From: Rob Herring <robh@kernel.org>
To: linux-arm-kernel@lists.infradead.org, linux-kernel@vger.kernel.org,
        soc@kernel.org, Andre Przywara <andre.przywara@arm.com>,
        Robert Richter <rrichter@marvell.com>,
        Jon Loeliger <jdl@jdl.com>, Alexander Graf <graf@amazon.com>,
        Matthias Brugger <mbrugger@suse.com>,
        Mark Langsdorf <mlangsdo@redhat.com>
Cc: Alex Williamson <alex.williamson@redhat.com>,
        Borislav Petkov <bp@alien8.de>,
        Cornelia Huck <cohuck@redhat.com>,
        Daniel Lezcano <daniel.lezcano@linaro.org>,
        "David S. Miller" <davem@davemloft.net>,
        devicetree@vger.kernel.org, Eric Auger <eric.auger@redhat.com>,
        iommu@lists.linux-foundation.org,
        James Morse <james.morse@arm.com>,
        Jens Axboe <axboe@kernel.dk>, Joerg Roedel <joro@8bytes.org>,
        kvm@vger.kernel.org, linux-clk@vger.kernel.org,
        linux-edac@vger.kernel.org, linux-ide@vger.kernel.org,
        linux-pm@vger.kernel.org,
        Mauro Carvalho Chehab <mchehab@kernel.org>,
        netdev@vger.kernel.org, "Rafael J. Wysocki" <rjw@rjwysocki.net>,
        Robin Murphy <robin.murphy@arm.com>,
        Stephen Boyd <sboyd@kernel.org>,
        Tony Luck <tony.luck@intel.com>,
        Viresh Kumar <viresh.kumar@linaro.org>,
        Will Deacon <will@kernel.org>
Subject: [RFC PATCH 08/11] clk: Remove Calxeda driver
Date: Tue, 18 Feb 2020 11:13:18 -0600
Message-Id: <20200218171321.30990-9-robh@kernel.org>
X-Mailer: git-send-email 2.20.1
In-Reply-To: <20200218171321.30990-1-robh@kernel.org>
References: <20200218171321.30990-1-robh@kernel.org>
MIME-Version: 1.0
Sender: kvm-owner@vger.kernel.org
Precedence: bulk
List-ID: <kvm.vger.kernel.org>
X-Mailing-List: kvm@vger.kernel.org

Cc: Stephen Boyd <sboyd@kernel.org>
Cc: linux-clk@vger.kernel.org
Signed-off-by: Rob Herring <robh@kernel.org>
---
Do not apply yet.

 drivers/clk/Makefile       |   1 -
 drivers/clk/clk-highbank.c | 329 -------------------------------------
 2 files changed, 330 deletions(-)
 delete mode 100644 drivers/clk/clk-highbank.c

--
2.20.1

diff --git a/drivers/clk/Makefile b/drivers/clk/Makefile
index f4169cc2fd31..cb71dfaf1ac7 100644
--- a/drivers/clk/Makefile
+++ b/drivers/clk/Makefile
@@ -33,7 +33,6 @@ obj-$(CONFIG_COMMON_CLK_FSL_SAI)	+= clk-fsl-sai.o
 obj-$(CONFIG_COMMON_CLK_GEMINI)		+= clk-gemini.o
 obj-$(CONFIG_COMMON_CLK_ASPEED)		+= clk-aspeed.o
 obj-$(CONFIG_MACH_ASPEED_G6)		+= clk-ast2600.o
-obj-$(CONFIG_ARCH_HIGHBANK)		+= clk-highbank.o
 obj-$(CONFIG_CLK_HSDK)			+= clk-hsdk-pll.o
 obj-$(CONFIG_COMMON_CLK_LOCHNAGAR)	+= clk-lochnagar.o
 obj-$(CONFIG_COMMON_CLK_MAX77686)	+= clk-max77686.o
diff --git a/drivers/clk/clk-highbank.c b/drivers/clk/clk-highbank.c
deleted file mode 100644
index 2a0cea2946f9..000000000000
--- a/drivers/clk/clk-highbank.c
+++ /dev/null
@@ -1,329 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0-only
-/*
- * Copyright 2011-2012 Calxeda, Inc.
- */
-
-#include <linux/kernel.h>
-#include <linux/slab.h>
-#include <linux/err.h>
-#include <linux/clk-provider.h>
-#include <linux/io.h>
-#include <linux/of.h>
-#include <linux/of_address.h>
-
-#define HB_PLL_LOCK_500		0x20000000
-#define HB_PLL_LOCK		0x10000000
-#define HB_PLL_DIVF_SHIFT	20
-#define HB_PLL_DIVF_MASK	0x0ff00000
-#define HB_PLL_DIVQ_SHIFT	16
-#define HB_PLL_DIVQ_MASK	0x00070000
-#define HB_PLL_DIVR_SHIFT	8
-#define HB_PLL_DIVR_MASK	0x00001f00
-#define HB_PLL_RANGE_SHIFT	4
-#define HB_PLL_RANGE_MASK	0x00000070
-#define HB_PLL_BYPASS		0x00000008
-#define HB_PLL_RESET		0x00000004
-#define HB_PLL_EXT_BYPASS	0x00000002
-#define HB_PLL_EXT_ENA		0x00000001
-
-#define HB_PLL_VCO_MIN_FREQ	2133000000
-#define HB_PLL_MAX_FREQ		HB_PLL_VCO_MIN_FREQ
-#define HB_PLL_MIN_FREQ		(HB_PLL_VCO_MIN_FREQ / 64)
-
-#define HB_A9_BCLK_DIV_MASK	0x00000006
-#define HB_A9_BCLK_DIV_SHIFT	1
-#define HB_A9_PCLK_DIV		0x00000001
-
-struct hb_clk {
-        struct clk_hw	hw;
-	void __iomem	*reg;
-	char *parent_name;
-};
-#define to_hb_clk(p) container_of(p, struct hb_clk, hw)
-
-static int clk_pll_prepare(struct clk_hw *hwclk)
-	{
-	struct hb_clk *hbclk = to_hb_clk(hwclk);
-	u32 reg;
-
-	reg = readl(hbclk->reg);
-	reg &= ~HB_PLL_RESET;
-	writel(reg, hbclk->reg);
-
-	while ((readl(hbclk->reg) & HB_PLL_LOCK) == 0)
-		;
-	while ((readl(hbclk->reg) & HB_PLL_LOCK_500) == 0)
-		;
-
-	return 0;
-}
-
-static void clk_pll_unprepare(struct clk_hw *hwclk)
-{
-	struct hb_clk *hbclk = to_hb_clk(hwclk);
-	u32 reg;
-
-	reg = readl(hbclk->reg);
-	reg |= HB_PLL_RESET;
-	writel(reg, hbclk->reg);
-}
-
-static int clk_pll_enable(struct clk_hw *hwclk)
-{
-	struct hb_clk *hbclk = to_hb_clk(hwclk);
-	u32 reg;
-
-	reg = readl(hbclk->reg);
-	reg |= HB_PLL_EXT_ENA;
-	writel(reg, hbclk->reg);
-
-	return 0;
-}
-
-static void clk_pll_disable(struct clk_hw *hwclk)
-{
-	struct hb_clk *hbclk = to_hb_clk(hwclk);
-	u32 reg;
-
-	reg = readl(hbclk->reg);
-	reg &= ~HB_PLL_EXT_ENA;
-	writel(reg, hbclk->reg);
-}
-
-static unsigned long clk_pll_recalc_rate(struct clk_hw *hwclk,
-					 unsigned long parent_rate)
-{
-	struct hb_clk *hbclk = to_hb_clk(hwclk);
-	unsigned long divf, divq, vco_freq, reg;
-
-	reg = readl(hbclk->reg);
-	if (reg & HB_PLL_EXT_BYPASS)
-		return parent_rate;
-
-	divf = (reg & HB_PLL_DIVF_MASK) >> HB_PLL_DIVF_SHIFT;
-	divq = (reg & HB_PLL_DIVQ_MASK) >> HB_PLL_DIVQ_SHIFT;
-	vco_freq = parent_rate * (divf + 1);
-
-	return vco_freq / (1 << divq);
-}
-
-static void clk_pll_calc(unsigned long rate, unsigned long ref_freq,
-			u32 *pdivq, u32 *pdivf)
-{
-	u32 divq, divf;
-	unsigned long vco_freq;
-
-	if (rate < HB_PLL_MIN_FREQ)
-		rate = HB_PLL_MIN_FREQ;
-	if (rate > HB_PLL_MAX_FREQ)
-		rate = HB_PLL_MAX_FREQ;
-
-	for (divq = 1; divq <= 6; divq++) {
-		if ((rate * (1 << divq)) >= HB_PLL_VCO_MIN_FREQ)
-			break;
-	}
-
-	vco_freq = rate * (1 << divq);
-	divf = (vco_freq + (ref_freq / 2)) / ref_freq;
-	divf--;
-
-	*pdivq = divq;
-	*pdivf = divf;
-}
-
-static long clk_pll_round_rate(struct clk_hw *hwclk, unsigned long rate,
-			       unsigned long *parent_rate)
-{
-	u32 divq, divf;
-	unsigned long ref_freq = *parent_rate;
-
-	clk_pll_calc(rate, ref_freq, &divq, &divf);
-
-	return (ref_freq * (divf + 1)) / (1 << divq);
-}
-
-static int clk_pll_set_rate(struct clk_hw *hwclk, unsigned long rate,
-			    unsigned long parent_rate)
-{
-	struct hb_clk *hbclk = to_hb_clk(hwclk);
-	u32 divq, divf;
-	u32 reg;
-
-	clk_pll_calc(rate, parent_rate, &divq, &divf);
-
-	reg = readl(hbclk->reg);
-	if (divf != ((reg & HB_PLL_DIVF_MASK) >> HB_PLL_DIVF_SHIFT)) {
-		/* Need to re-lock PLL, so put it into bypass mode */
-		reg |= HB_PLL_EXT_BYPASS;
-		writel(reg | HB_PLL_EXT_BYPASS, hbclk->reg);
-
-		writel(reg | HB_PLL_RESET, hbclk->reg);
-		reg &= ~(HB_PLL_DIVF_MASK | HB_PLL_DIVQ_MASK);
-		reg |= (divf << HB_PLL_DIVF_SHIFT) | (divq << HB_PLL_DIVQ_SHIFT);
-		writel(reg | HB_PLL_RESET, hbclk->reg);
-		writel(reg, hbclk->reg);
-
-		while ((readl(hbclk->reg) & HB_PLL_LOCK) == 0)
-			;
-		while ((readl(hbclk->reg) & HB_PLL_LOCK_500) == 0)
-			;
-		reg |= HB_PLL_EXT_ENA;
-		reg &= ~HB_PLL_EXT_BYPASS;
-	} else {
-		writel(reg | HB_PLL_EXT_BYPASS, hbclk->reg);
-		reg &= ~HB_PLL_DIVQ_MASK;
-		reg |= divq << HB_PLL_DIVQ_SHIFT;
-		writel(reg | HB_PLL_EXT_BYPASS, hbclk->reg);
-	}
-	writel(reg, hbclk->reg);
-
-	return 0;
-}
-
-static const struct clk_ops clk_pll_ops = {
-	.prepare = clk_pll_prepare,
-	.unprepare = clk_pll_unprepare,
-	.enable = clk_pll_enable,
-	.disable = clk_pll_disable,
-	.recalc_rate = clk_pll_recalc_rate,
-	.round_rate = clk_pll_round_rate,
-	.set_rate = clk_pll_set_rate,
-};
-
-static unsigned long clk_cpu_periphclk_recalc_rate(struct clk_hw *hwclk,
-						   unsigned long parent_rate)
-{
-	struct hb_clk *hbclk = to_hb_clk(hwclk);
-	u32 div = (readl(hbclk->reg) & HB_A9_PCLK_DIV) ? 8 : 4;
-	return parent_rate / div;
-}
-
-static const struct clk_ops a9periphclk_ops = {
-	.recalc_rate = clk_cpu_periphclk_recalc_rate,
-};
-
-static unsigned long clk_cpu_a9bclk_recalc_rate(struct clk_hw *hwclk,
-						unsigned long parent_rate)
-{
-	struct hb_clk *hbclk = to_hb_clk(hwclk);
-	u32 div = (readl(hbclk->reg) & HB_A9_BCLK_DIV_MASK) >> HB_A9_BCLK_DIV_SHIFT;
-
-	return parent_rate / (div + 2);
-}
-
-static const struct clk_ops a9bclk_ops = {
-	.recalc_rate = clk_cpu_a9bclk_recalc_rate,
-};
-
-static unsigned long clk_periclk_recalc_rate(struct clk_hw *hwclk,
-					     unsigned long parent_rate)
-{
-	struct hb_clk *hbclk = to_hb_clk(hwclk);
-	u32 div;
-
-	div = readl(hbclk->reg) & 0x1f;
-	div++;
-	div *= 2;
-
-	return parent_rate / div;
-}
-
-static long clk_periclk_round_rate(struct clk_hw *hwclk, unsigned long rate,
-				   unsigned long *parent_rate)
-{
-	u32 div;
-
-	div = *parent_rate / rate;
-	div++;
-	div &= ~0x1;
-
-	return *parent_rate / div;
-}
-
-static int clk_periclk_set_rate(struct clk_hw *hwclk, unsigned long rate,
-				unsigned long parent_rate)
-{
-	struct hb_clk *hbclk = to_hb_clk(hwclk);
-	u32 div;
-
-	div = parent_rate / rate;
-	if (div & 0x1)
-		return -EINVAL;
-
-	writel(div >> 1, hbclk->reg);
-	return 0;
-}
-
-static const struct clk_ops periclk_ops = {
-	.recalc_rate = clk_periclk_recalc_rate,
-	.round_rate = clk_periclk_round_rate,
-	.set_rate = clk_periclk_set_rate,
-};
-
-static void __init hb_clk_init(struct device_node *node, const struct clk_ops *ops, unsigned long clkflags)
-{
-	u32 reg;
-	struct hb_clk *hb_clk;
-	const char *clk_name = node->name;
-	const char *parent_name;
-	struct clk_init_data init;
-	struct device_node *srnp;
-	int rc;
-
-	rc = of_property_read_u32(node, "reg", &reg);
-	if (WARN_ON(rc))
-		return;
-
-	hb_clk = kzalloc(sizeof(*hb_clk), GFP_KERNEL);
-	if (WARN_ON(!hb_clk))
-		return;
-
-	/* Map system registers */
-	srnp = of_find_compatible_node(NULL, NULL, "calxeda,hb-sregs");
-	hb_clk->reg = of_iomap(srnp, 0);
-	of_node_put(srnp);
-	BUG_ON(!hb_clk->reg);
-	hb_clk->reg += reg;
-
-	of_property_read_string(node, "clock-output-names", &clk_name);
-
-	init.name = clk_name;
-	init.ops = ops;
-	init.flags = clkflags;
-	parent_name = of_clk_get_parent_name(node, 0);
-	init.parent_names = &parent_name;
-	init.num_parents = 1;
-
-	hb_clk->hw.init = &init;
-
-	rc = clk_hw_register(NULL, &hb_clk->hw);
-	if (WARN_ON(rc)) {
-		kfree(hb_clk);
-		return;
-	}
-	of_clk_add_hw_provider(node, of_clk_hw_simple_get, &hb_clk->hw);
-}
-
-static void __init hb_pll_init(struct device_node *node)
-{
-	hb_clk_init(node, &clk_pll_ops, 0);
-}
-CLK_OF_DECLARE(hb_pll, "calxeda,hb-pll-clock", hb_pll_init);
-
-static void __init hb_a9periph_init(struct device_node *node)
-{
-	hb_clk_init(node, &a9periphclk_ops, 0);
-}
-CLK_OF_DECLARE(hb_a9periph, "calxeda,hb-a9periph-clock", hb_a9periph_init);
-
-static void __init hb_a9bus_init(struct device_node *node)
-{
-	hb_clk_init(node, &a9bclk_ops, CLK_IS_CRITICAL);
-}
-CLK_OF_DECLARE(hb_a9bus, "calxeda,hb-a9bus-clock", hb_a9bus_init);
-
-static void __init hb_emmc_init(struct device_node *node)
-{
-	hb_clk_init(node, &periclk_ops, 0);
-}
-CLK_OF_DECLARE(hb_emmc, "calxeda,hb-emmc-clock", hb_emmc_init);

From patchwork Tue Feb 18 17:13:19 2020
Content-Type: text/plain; charset="utf-8"
MIME-Version: 1.0
Content-Transfer-Encoding: 7bit
X-Patchwork-Submitter: Rob Herring <robh@kernel.org>
X-Patchwork-Id: 11389057
Return-Path: <SRS0=NRU2=4G=vger.kernel.org=kvm-owner@kernel.org>
Received: from mail.kernel.org (pdx-korg-mail-1.web.codeaurora.org
 [172.30.200.123])
	by pdx-korg-patchwork-2.web.codeaurora.org (Postfix) with ESMTP id B73DE17F0
	for <patchwork-kvm@patchwork.kernel.org>;
 Tue, 18 Feb 2020 17:14:12 +0000 (UTC)
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.kernel.org (Postfix) with ESMTP id 8F89E24682
	for <patchwork-kvm@patchwork.kernel.org>;
 Tue, 18 Feb 2020 17:14:12 +0000 (UTC)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple; d=kernel.org;
	s=default; t=1582046052;
	bh=16ZF0cCZbV5kwDCFQUoY69KQyr41LZYil0YEJqkGGFI=;
	h=From:To:Cc:Subject:Date:In-Reply-To:References:List-ID:From;
	b=mJom6yD10hSNTYznJCQCkQrYSKYq/L5tZwIl3l3/Si3p+T5K29oj61r+Z9JEhYFp+
	 Z8PmfDfK9WE3p9mXcXomh5CuGH/xeQ5XO6CZNpVxzVrNeJPJMKgKH40M1Ek9GfaCET
	 g11glM8GKTaivN+aPpwjdmP38VR6gefcI0HlFSGA=
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S1727885AbgBRROE (ORCPT
        <rfc822;patchwork-kvm@patchwork.kernel.org>);
        Tue, 18 Feb 2020 12:14:04 -0500
Received: from mail-oi1-f196.google.com ([209.85.167.196]:43175 "EHLO
        mail-oi1-f196.google.com" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S1727636AbgBRRNk (ORCPT <rfc822;kvm@vger.kernel.org>);
        Tue, 18 Feb 2020 12:13:40 -0500
Received: by mail-oi1-f196.google.com with SMTP id p125so20818028oif.10;
        Tue, 18 Feb 2020 09:13:39 -0800 (PST)
X-Google-DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
        d=1e100.net; s=20161025;
        h=x-gm-message-state:from:to:cc:subject:date:message-id:in-reply-to
         :references:mime-version:content-transfer-encoding;
        bh=OfSjz0SY3gB9vvqANcu/VWw8bhc0UxSKC0tVnm3NpGk=;
        b=L1AGWk8BpgWHL5guD5QdhRD713FXIpInZBcfX2DHLO7iWUSArEo13izgAJ9OBj+qep
         2HtrjqwuB7bSRzniiWuFenijkHqzWyGvLHi6hgNBQZ12nRoWqwC17sxAtK+pAMLVbAiW
         Au76CT7uz7ONcymB/idAwc0a09v0kPeflhhxdxC87TDfomwYOQQK6frOWwiPPVJjJRZA
         d6531oOLaF3begNXV8t148fnQuFjIbobAPK4/a7Iuoz2afRNfyVt1rHPfzNJ+TwUVqI4
         sYnZcmRMVbBENJKqoLeY6aR8c5HulGNNIA4GmY2r43teZaK6juSMddPcjjQS0SWNkcqP
         Epew==
X-Gm-Message-State: APjAAAWCPwf1qPbc4fvrusGEB3/MJb7aBU9/QEcKet8Jbca4/pM1Sgzj
        58/G6gJX5wWWoDxV8t8tyw==
X-Google-Smtp-Source: 
 APXvYqxbphi1K6W3rxnH0g40QxVSz6sF58VircIrd+GanSZMoZoTlalIrudHTPYPIyhAT1DhIrluPg==
X-Received: by 2002:aca:f305:: with SMTP id r5mr1981696oih.174.1582046018439;
        Tue, 18 Feb 2020 09:13:38 -0800 (PST)
Received: from xps15.herring.priv (24-155-109-49.dyn.grandenetworks.net.
 [24.155.109.49])
        by smtp.googlemail.com with ESMTPSA id
 y25sm1545755oto.27.2020.02.18.09.13.36
        (version=TLS1_3 cipher=TLS_AES_256_GCM_SHA384 bits=256/256);
        Tue, 18 Feb 2020 09:13:37 -0800 (PST)
From: Rob Herring <robh@kernel.org>
To: linux-arm-kernel@lists.infradead.org, linux-kernel@vger.kernel.org,
        soc@kernel.org, Andre Przywara <andre.przywara@arm.com>,
        Robert Richter <rrichter@marvell.com>,
        Jon Loeliger <jdl@jdl.com>, Alexander Graf <graf@amazon.com>,
        Matthias Brugger <mbrugger@suse.com>,
        Mark Langsdorf <mlangsdo@redhat.com>
Cc: Alex Williamson <alex.williamson@redhat.com>,
        Borislav Petkov <bp@alien8.de>,
        Cornelia Huck <cohuck@redhat.com>,
        Daniel Lezcano <daniel.lezcano@linaro.org>,
        "David S. Miller" <davem@davemloft.net>,
        devicetree@vger.kernel.org, Eric Auger <eric.auger@redhat.com>,
        iommu@lists.linux-foundation.org,
        James Morse <james.morse@arm.com>,
        Jens Axboe <axboe@kernel.dk>, Joerg Roedel <joro@8bytes.org>,
        kvm@vger.kernel.org, linux-clk@vger.kernel.org,
        linux-edac@vger.kernel.org, linux-ide@vger.kernel.org,
        linux-pm@vger.kernel.org,
        Mauro Carvalho Chehab <mchehab@kernel.org>,
        netdev@vger.kernel.org, "Rafael J. Wysocki" <rjw@rjwysocki.net>,
        Robin Murphy <robin.murphy@arm.com>,
        Stephen Boyd <sboyd@kernel.org>,
        Tony Luck <tony.luck@intel.com>,
        Viresh Kumar <viresh.kumar@linaro.org>,
        Will Deacon <will@kernel.org>
Subject: [RFC PATCH 09/11] ARM: Remove Calxeda platform support
Date: Tue, 18 Feb 2020 11:13:19 -0600
Message-Id: <20200218171321.30990-10-robh@kernel.org>
X-Mailer: git-send-email 2.20.1
In-Reply-To: <20200218171321.30990-1-robh@kernel.org>
References: <20200218171321.30990-1-robh@kernel.org>
MIME-Version: 1.0
Sender: kvm-owner@vger.kernel.org
Precedence: bulk
List-ID: <kvm.vger.kernel.org>
X-Mailing-List: kvm@vger.kernel.org

Signed-off-by: Rob Herring <robh@kernel.org>
---
 MAINTAINERS                         |   8 --
 arch/arm/Kconfig                    |   2 -
 arch/arm/Kconfig.debug              |  12 +-
 arch/arm/Makefile                   |   1 -
 arch/arm/configs/multi_v7_defconfig |   5 -
 arch/arm/mach-highbank/Kconfig      |  19 ---
 arch/arm/mach-highbank/Makefile     |   4 -
 arch/arm/mach-highbank/core.h       |  18 ---
 arch/arm/mach-highbank/highbank.c   | 175 ----------------------------
 arch/arm/mach-highbank/pm.c         |  49 --------
 arch/arm/mach-highbank/smc.S        |  25 ----
 arch/arm/mach-highbank/sysregs.h    |  75 ------------
 arch/arm/mach-highbank/system.c     |  22 ----
 13 files changed, 1 insertion(+), 414 deletions(-)
 delete mode 100644 arch/arm/mach-highbank/Kconfig
 delete mode 100644 arch/arm/mach-highbank/Makefile
 delete mode 100644 arch/arm/mach-highbank/core.h
 delete mode 100644 arch/arm/mach-highbank/highbank.c
 delete mode 100644 arch/arm/mach-highbank/pm.c
 delete mode 100644 arch/arm/mach-highbank/smc.S
 delete mode 100644 arch/arm/mach-highbank/sysregs.h
 delete mode 100644 arch/arm/mach-highbank/system.c

diff --git a/MAINTAINERS b/MAINTAINERS
index 4732bb268299..551aaa9d2dab 100644
--- a/MAINTAINERS
+++ b/MAINTAINERS
@@ -1604,14 +1604,6 @@ F:	Documentation/devicetree/bindings/arm/bitmain.yaml
 F:	Documentation/devicetree/bindings/clock/bitmain,bm1880-clk.yaml
 F:	Documentation/devicetree/bindings/pinctrl/bitmain,bm1880-pinctrl.txt
 
-ARM/CALXEDA HIGHBANK ARCHITECTURE
-M:	Rob Herring <robh@kernel.org>
-L:	linux-arm-kernel@lists.infradead.org (moderated for non-subscribers)
-S:	Maintained
-F:	arch/arm/mach-highbank/
-F:	arch/arm/boot/dts/highbank.dts
-F:	arch/arm/boot/dts/ecx-*.dts*
-
 ARM/CAVIUM NETWORKS CNS3XXX MACHINE SUPPORT
 M:	Krzysztof Halasa <khalasa@piap.pl>
 S:	Maintained
diff --git a/arch/arm/Kconfig b/arch/arm/Kconfig
index 97864aabc2a6..6f8ce7b38a46 100644
--- a/arch/arm/Kconfig
+++ b/arch/arm/Kconfig
@@ -640,8 +640,6 @@ source "arch/arm/mach-footbridge/Kconfig"
 
 source "arch/arm/mach-gemini/Kconfig"
 
-source "arch/arm/mach-highbank/Kconfig"
-
 source "arch/arm/mach-hisi/Kconfig"
 
 source "arch/arm/mach-imx/Kconfig"
diff --git a/arch/arm/Kconfig.debug b/arch/arm/Kconfig.debug
index b70d7debf5ca..66413f98cae9 100644
--- a/arch/arm/Kconfig.debug
+++ b/arch/arm/Kconfig.debug
@@ -346,14 +346,6 @@ choice
 		  Say Y here if you want kernel low-level debugging support
 		  on HI3620 UART.
 
-	config DEBUG_HIGHBANK_UART
-		bool "Kernel low-level debugging messages via Highbank UART"
-		depends on ARCH_HIGHBANK
-		select DEBUG_UART_PL01X
-		help
-		  Say Y here if you want the debug print routines to direct
-		  their output to the UART on Highbank based devices.
-
 	config DEBUG_HIP01_UART
 		bool "Hisilicon Hip01 Debug UART"
 		depends on ARCH_HIP01
@@ -1692,7 +1684,6 @@ config DEBUG_UART_PHYS
 	default 0xffc03000 if DEBUG_SOCFPGA_CYCLONE5_UART1
 	default 0xffe40000 if DEBUG_RCAR_GEN1_SCIF0
 	default 0xffe42000 if DEBUG_RCAR_GEN1_SCIF2
-	default 0xfff36000 if DEBUG_HIGHBANK_UART
 	default 0xfffb0000 if DEBUG_OMAP1UART1 || DEBUG_OMAP7XXUART1
 	default 0xfffb0800 if DEBUG_OMAP1UART2 || DEBUG_OMAP7XXUART2
 	default 0xfffb9800 if DEBUG_OMAP1UART3 || DEBUG_OMAP7XXUART3
@@ -1810,7 +1801,6 @@ config DEBUG_UART_VIRT
 	default 0xfee20000 if DEBUG_NSPIRE_CLASSIC_UART || DEBUG_NSPIRE_CX_UART
 	default 0xfef00000 if ARCH_IXP4XX && !CPU_BIG_ENDIAN
 	default 0xfef00003 if ARCH_IXP4XX && CPU_BIG_ENDIAN
-	default 0xfef36000 if DEBUG_HIGHBANK_UART
 	default 0xfefb0000 if DEBUG_OMAP1UART1 || DEBUG_OMAP7XXUART1
 	default 0xfefb0800 if DEBUG_OMAP1UART2 || DEBUG_OMAP7XXUART2
 	default 0xfefb9800 if DEBUG_OMAP1UART3 || DEBUG_OMAP7XXUART3
@@ -1873,7 +1863,7 @@ config DEBUG_UNCOMPRESS
 	  When this option is set, the selected DEBUG_LL output method
 	  will be re-used for normal decompressor output on multiplatform
 	  kernels.
-	  
+
 
 config UNCOMPRESS_INCLUDE
 	string
diff --git a/arch/arm/Makefile b/arch/arm/Makefile
index db857d07114f..fa3bc920e3ac 100644
--- a/arch/arm/Makefile
+++ b/arch/arm/Makefile
@@ -178,7 +178,6 @@ machine-$(CONFIG_ARCH_EP93XX)		+= ep93xx
 machine-$(CONFIG_ARCH_EXYNOS)		+= exynos
 machine-$(CONFIG_ARCH_FOOTBRIDGE)	+= footbridge
 machine-$(CONFIG_ARCH_GEMINI)		+= gemini
-machine-$(CONFIG_ARCH_HIGHBANK)		+= highbank
 machine-$(CONFIG_ARCH_HISI)		+= hisi
 machine-$(CONFIG_ARCH_INTEGRATOR)	+= integrator
 machine-$(CONFIG_ARCH_IOP32X)		+= iop32x
diff --git a/arch/arm/configs/multi_v7_defconfig b/arch/arm/configs/multi_v7_defconfig
index 017d65f86eba..69eb62f831c7 100644
--- a/arch/arm/configs/multi_v7_defconfig
+++ b/arch/arm/configs/multi_v7_defconfig
@@ -31,7 +31,6 @@ CONFIG_MACH_BERLIN_BG2CD=y
 CONFIG_MACH_BERLIN_BG2Q=y
 CONFIG_ARCH_DIGICOLOR=y
 CONFIG_ARCH_EXYNOS=y
-CONFIG_ARCH_HIGHBANK=y
 CONFIG_ARCH_HISI=y
 CONFIG_ARCH_HI3xxx=y
 CONFIG_ARCH_HIP01=y
@@ -236,7 +235,6 @@ CONFIG_AHCI_ST=y
 CONFIG_AHCI_IMX=y
 CONFIG_AHCI_SUNXI=y
 CONFIG_AHCI_TEGRA=y
-CONFIG_SATA_HIGHBANK=y
 CONFIG_SATA_MV=y
 CONFIG_SATA_RCAR=y
 CONFIG_NETDEVICES=y
@@ -250,7 +248,6 @@ CONFIG_BCMGENET=m
 CONFIG_BGMAC_BCMA=y
 CONFIG_SYSTEMPORT=m
 CONFIG_MACB=y
-CONFIG_NET_CALXEDA_XGMAC=y
 CONFIG_FTGMAC100=m
 CONFIG_GIANFAR=y
 CONFIG_HIX5HD2_GMAC=y
@@ -866,8 +863,6 @@ CONFIG_LEDS_TRIGGER_DEFAULT_ON=y
 CONFIG_LEDS_TRIGGER_TRANSIENT=y
 CONFIG_LEDS_TRIGGER_CAMERA=y
 CONFIG_EDAC=y
-CONFIG_EDAC_HIGHBANK_MC=y
-CONFIG_EDAC_HIGHBANK_L2=y
 CONFIG_RTC_CLASS=y
 CONFIG_RTC_DRV_AC100=y
 CONFIG_RTC_DRV_AS3722=y
diff --git a/arch/arm/mach-highbank/Kconfig b/arch/arm/mach-highbank/Kconfig
deleted file mode 100644
index 1bc68913d62c..000000000000
--- a/arch/arm/mach-highbank/Kconfig
+++ /dev/null
@@ -1,19 +0,0 @@
-# SPDX-License-Identifier: GPL-2.0-only
-config ARCH_HIGHBANK
-	bool "Calxeda ECX-1000/2000 (Highbank/Midway)"
-	depends on ARCH_MULTI_V7
-	select ARCH_HAS_HOLES_MEMORYMODEL
-	select ARCH_SUPPORTS_BIG_ENDIAN
-	select ARM_AMBA
-	select ARM_ERRATA_764369 if SMP
-	select ARM_ERRATA_775420
-	select ARM_ERRATA_798181 if SMP
-	select ARM_GIC
-	select ARM_PSCI
-	select ARM_TIMER_SP804
-	select CACHE_L2X0
-	select HAVE_ARM_SCU
-	select HAVE_ARM_TWD if SMP
-	select MAILBOX
-	select PL320_MBOX
-	select ZONE_DMA if ARM_LPAE
diff --git a/arch/arm/mach-highbank/Makefile b/arch/arm/mach-highbank/Makefile
deleted file mode 100644
index 71cc68041d92..000000000000
--- a/arch/arm/mach-highbank/Makefile
+++ /dev/null
@@ -1,4 +0,0 @@
-# SPDX-License-Identifier: GPL-2.0-only
-obj-y					:= highbank.o system.o smc.o
-
-obj-$(CONFIG_PM_SLEEP)			+= pm.o
diff --git a/arch/arm/mach-highbank/core.h b/arch/arm/mach-highbank/core.h
deleted file mode 100644
index 3991a6594ae5..000000000000
--- a/arch/arm/mach-highbank/core.h
+++ /dev/null
@@ -1,18 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __HIGHBANK_CORE_H
-#define __HIGHBANK_CORE_H
-
-#include <linux/reboot.h>
-
-extern void highbank_restart(enum reboot_mode, const char *);
-extern void __iomem *scu_base_addr;
-
-#ifdef CONFIG_PM_SLEEP
-extern void highbank_pm_init(void);
-#else
-static inline void highbank_pm_init(void) {}
-#endif
-
-extern void highbank_smc1(int fn, int arg);
-
-#endif
diff --git a/arch/arm/mach-highbank/highbank.c b/arch/arm/mach-highbank/highbank.c
deleted file mode 100644
index 56bf29523c65..000000000000
--- a/arch/arm/mach-highbank/highbank.c
+++ /dev/null
@@ -1,175 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0-only
-/*
- * Copyright 2010-2011 Calxeda, Inc.
- */
-#include <linux/clk.h>
-#include <linux/clkdev.h>
-#include <linux/clocksource.h>
-#include <linux/dma-mapping.h>
-#include <linux/input.h>
-#include <linux/io.h>
-#include <linux/irqchip.h>
-#include <linux/pl320-ipc.h>
-#include <linux/of.h>
-#include <linux/of_irq.h>
-#include <linux/of_address.h>
-#include <linux/reboot.h>
-#include <linux/amba/bus.h>
-#include <linux/platform_device.h>
-#include <linux/psci.h>
-
-#include <asm/hardware/cache-l2x0.h>
-#include <asm/mach/arch.h>
-#include <asm/mach/map.h>
-
-#include "core.h"
-#include "sysregs.h"
-
-void __iomem *sregs_base;
-void __iomem *scu_base_addr;
-
-static void __init highbank_scu_map_io(void)
-{
-	unsigned long base;
-
-	/* Get SCU base */
-	asm("mrc p15, 4, %0, c15, c0, 0" : "=r" (base));
-
-	scu_base_addr = ioremap(base, SZ_4K);
-}
-
-
-static void highbank_l2c310_write_sec(unsigned long val, unsigned reg)
-{
-	if (reg == L2X0_CTRL)
-		highbank_smc1(0x102, val);
-	else
-		WARN_ONCE(1, "Highbank L2C310: ignoring write to reg 0x%x\n",
-			  reg);
-}
-
-static void __init highbank_init_irq(void)
-{
-	irqchip_init();
-
-	if (of_find_compatible_node(NULL, NULL, "arm,cortex-a9"))
-		highbank_scu_map_io();
-}
-
-static void highbank_power_off(void)
-{
-	highbank_set_pwr_shutdown();
-
-	while (1)
-		cpu_do_idle();
-}
-
-static int highbank_platform_notifier(struct notifier_block *nb,
-				  unsigned long event, void *__dev)
-{
-	struct resource *res;
-	int reg = -1;
-	u32 val;
-	struct device *dev = __dev;
-
-	if (event != BUS_NOTIFY_ADD_DEVICE)
-		return NOTIFY_DONE;
-
-	if (of_device_is_compatible(dev->of_node, "calxeda,hb-ahci"))
-		reg = 0xc;
-	else if (of_device_is_compatible(dev->of_node, "calxeda,hb-sdhci"))
-		reg = 0x18;
-	else if (of_device_is_compatible(dev->of_node, "arm,pl330"))
-		reg = 0x20;
-	else if (of_device_is_compatible(dev->of_node, "calxeda,hb-xgmac")) {
-		res = platform_get_resource(to_platform_device(dev),
-					    IORESOURCE_MEM, 0);
-		if (res) {
-			if (res->start == 0xfff50000)
-				reg = 0;
-			else if (res->start == 0xfff51000)
-				reg = 4;
-		}
-	}
-
-	if (reg < 0)
-		return NOTIFY_DONE;
-
-	if (of_property_read_bool(dev->of_node, "dma-coherent")) {
-		val = readl(sregs_base + reg);
-		writel(val | 0xff01, sregs_base + reg);
-		set_dma_ops(dev, &arm_coherent_dma_ops);
-	}
-
-	return NOTIFY_OK;
-}
-
-static struct notifier_block highbank_amba_nb = {
-	.notifier_call = highbank_platform_notifier,
-};
-
-static struct notifier_block highbank_platform_nb = {
-	.notifier_call = highbank_platform_notifier,
-};
-
-static struct platform_device highbank_cpuidle_device = {
-	.name = "cpuidle-calxeda",
-};
-
-static int hb_keys_notifier(struct notifier_block *nb, unsigned long event, void *data)
-{
-	u32 key = *(u32 *)data;
-
-	if (event != 0x1000)
-		return 0;
-
-	if (key == KEY_POWER)
-		orderly_poweroff(false);
-	else if (key == 0xffff)
-		ctrl_alt_del();
-
-	return 0;
-}
-static struct notifier_block hb_keys_nb = {
-	.notifier_call = hb_keys_notifier,
-};
-
-static void __init highbank_init(void)
-{
-	struct device_node *np;
-
-	/* Map system registers */
-	np = of_find_compatible_node(NULL, NULL, "calxeda,hb-sregs");
-	sregs_base = of_iomap(np, 0);
-	WARN_ON(!sregs_base);
-
-	pm_power_off = highbank_power_off;
-	highbank_pm_init();
-
-	bus_register_notifier(&platform_bus_type, &highbank_platform_nb);
-	bus_register_notifier(&amba_bustype, &highbank_amba_nb);
-
-	pl320_ipc_register_notifier(&hb_keys_nb);
-
-	if (psci_ops.cpu_suspend)
-		platform_device_register(&highbank_cpuidle_device);
-}
-
-static const char *const highbank_match[] __initconst = {
-	"calxeda,highbank",
-	"calxeda,ecx-2000",
-	NULL,
-};
-
-DT_MACHINE_START(HIGHBANK, "Highbank")
-#if defined(CONFIG_ZONE_DMA) && defined(CONFIG_ARM_LPAE)
-	.dma_zone_size	= (4ULL * SZ_1G),
-#endif
-	.l2c_aux_val	= 0,
-	.l2c_aux_mask	= ~0,
-	.l2c_write_sec	= highbank_l2c310_write_sec,
-	.init_irq	= highbank_init_irq,
-	.init_machine	= highbank_init,
-	.dt_compat	= highbank_match,
-	.restart	= highbank_restart,
-MACHINE_END
diff --git a/arch/arm/mach-highbank/pm.c b/arch/arm/mach-highbank/pm.c
deleted file mode 100644
index 561941baeda9..000000000000
--- a/arch/arm/mach-highbank/pm.c
+++ /dev/null
@@ -1,49 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0-only
-/*
- * Copyright 2011 Calxeda, Inc.
- */
-
-#include <linux/cpu_pm.h>
-#include <linux/init.h>
-#include <linux/psci.h>
-#include <linux/suspend.h>
-
-#include <asm/suspend.h>
-
-#include <uapi/linux/psci.h>
-
-#define HIGHBANK_SUSPEND_PARAM \
-	((0 << PSCI_0_2_POWER_STATE_ID_SHIFT) | \
-	 (1 << PSCI_0_2_POWER_STATE_AFFL_SHIFT) | \
-	 (PSCI_POWER_STATE_TYPE_POWER_DOWN << PSCI_0_2_POWER_STATE_TYPE_SHIFT))
-
-static int highbank_suspend_finish(unsigned long val)
-{
-	return psci_ops.cpu_suspend(HIGHBANK_SUSPEND_PARAM, __pa(cpu_resume));
-}
-
-static int highbank_pm_enter(suspend_state_t state)
-{
-	cpu_pm_enter();
-	cpu_cluster_pm_enter();
-
-	cpu_suspend(0, highbank_suspend_finish);
-
-	cpu_cluster_pm_exit();
-	cpu_pm_exit();
-
-	return 0;
-}
-
-static const struct platform_suspend_ops highbank_pm_ops = {
-	.enter = highbank_pm_enter,
-	.valid = suspend_valid_only_mem,
-};
-
-void __init highbank_pm_init(void)
-{
-	if (!psci_ops.cpu_suspend)
-		return;
-
-	suspend_set_ops(&highbank_pm_ops);
-}
diff --git a/arch/arm/mach-highbank/smc.S b/arch/arm/mach-highbank/smc.S
deleted file mode 100644
index 78b3f19e7f37..000000000000
--- a/arch/arm/mach-highbank/smc.S
+++ /dev/null
@@ -1,25 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0-only */
-/*
- * Copied from omap44xx-smc.S Copyright (C) 2010 Texas Instruments, Inc.
- * Copyright 2012 Calxeda, Inc.
- */
-
-#include <linux/linkage.h>
-
-/*
- * This is common routine to manage secure monitor API
- * used to modify the PL310 secure registers.
- * 'r0' contains the value to be modified and 'r12' contains
- * the monitor API number.
- * Function signature : void highbank_smc1(u32 fn, u32 arg)
- */
-	.arch armv7-a
-	.arch_extension sec
-ENTRY(highbank_smc1)
-	stmfd   sp!, {r4-r11, lr}
-	mov	r12, r0
-	mov 	r0, r1
-	dsb
-	smc	#0
-	ldmfd   sp!, {r4-r11, pc}
-ENDPROC(highbank_smc1)
diff --git a/arch/arm/mach-highbank/sysregs.h b/arch/arm/mach-highbank/sysregs.h
deleted file mode 100644
index 3c13fdcafb1e..000000000000
--- a/arch/arm/mach-highbank/sysregs.h
+++ /dev/null
@@ -1,75 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0-only */
-/*
- * Copyright 2011 Calxeda, Inc.
- */
-#ifndef _MACH_HIGHBANK__SYSREGS_H_
-#define _MACH_HIGHBANK__SYSREGS_H_
-
-#include <linux/io.h>
-#include <linux/smp.h>
-#include <asm/smp_plat.h>
-#include <asm/smp_scu.h>
-#include "core.h"
-
-extern void __iomem *sregs_base;
-
-#define HB_SREG_A9_PWR_REQ		0xf00
-#define HB_SREG_A9_BOOT_STAT		0xf04
-#define HB_SREG_A9_BOOT_DATA		0xf08
-
-#define HB_PWR_SUSPEND			0
-#define HB_PWR_SOFT_RESET		1
-#define HB_PWR_HARD_RESET		2
-#define HB_PWR_SHUTDOWN			3
-
-#define SREG_CPU_PWR_CTRL(c)		(0x200 + ((c) * 4))
-
-static inline void highbank_set_core_pwr(void)
-{
-	int cpu = MPIDR_AFFINITY_LEVEL(cpu_logical_map(smp_processor_id()), 0);
-	if (scu_base_addr)
-		scu_power_mode(scu_base_addr, SCU_PM_POWEROFF);
-	else
-		writel_relaxed(1, sregs_base + SREG_CPU_PWR_CTRL(cpu));
-}
-
-static inline void highbank_clear_core_pwr(void)
-{
-	int cpu = MPIDR_AFFINITY_LEVEL(cpu_logical_map(smp_processor_id()), 0);
-	if (scu_base_addr)
-		scu_power_mode(scu_base_addr, SCU_PM_NORMAL);
-	else
-		writel_relaxed(0, sregs_base + SREG_CPU_PWR_CTRL(cpu));
-}
-
-static inline void highbank_set_pwr_suspend(void)
-{
-	writel(HB_PWR_SUSPEND, sregs_base + HB_SREG_A9_PWR_REQ);
-	highbank_set_core_pwr();
-}
-
-static inline void highbank_set_pwr_shutdown(void)
-{
-	writel(HB_PWR_SHUTDOWN, sregs_base + HB_SREG_A9_PWR_REQ);
-	highbank_set_core_pwr();
-}
-
-static inline void highbank_set_pwr_soft_reset(void)
-{
-	writel(HB_PWR_SOFT_RESET, sregs_base + HB_SREG_A9_PWR_REQ);
-	highbank_set_core_pwr();
-}
-
-static inline void highbank_set_pwr_hard_reset(void)
-{
-	writel(HB_PWR_HARD_RESET, sregs_base + HB_SREG_A9_PWR_REQ);
-	highbank_set_core_pwr();
-}
-
-static inline void highbank_clear_pwr_request(void)
-{
-	writel(~0UL, sregs_base + HB_SREG_A9_PWR_REQ);
-	highbank_clear_core_pwr();
-}
-
-#endif
diff --git a/arch/arm/mach-highbank/system.c b/arch/arm/mach-highbank/system.c
deleted file mode 100644
index b749c4a6ddf5..000000000000
--- a/arch/arm/mach-highbank/system.c
+++ /dev/null
@@ -1,22 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0-only
-/*
- * Copyright 2011 Calxeda, Inc.
- */
-#include <linux/io.h>
-#include <asm/proc-fns.h>
-#include <linux/reboot.h>
-
-#include "core.h"
-#include "sysregs.h"
-
-void highbank_restart(enum reboot_mode mode, const char *cmd)
-{
-	if (mode == REBOOT_HARD)
-		highbank_set_pwr_hard_reset();
-	else
-		highbank_set_pwr_soft_reset();
-
-	while (1)
-		cpu_do_idle();
-}
-

From patchwork Tue Feb 18 17:13:20 2020
Content-Type: text/plain; charset="utf-8"
MIME-Version: 1.0
Content-Transfer-Encoding: 7bit
X-Patchwork-Submitter: Rob Herring <robh@kernel.org>
X-Patchwork-Id: 11389035
Return-Path: <SRS0=NRU2=4G=vger.kernel.org=kvm-owner@kernel.org>
Received: from mail.kernel.org (pdx-korg-mail-1.web.codeaurora.org
 [172.30.200.123])
	by pdx-korg-patchwork-2.web.codeaurora.org (Postfix) with ESMTP id 2537217F0
	for <patchwork-kvm@patchwork.kernel.org>;
 Tue, 18 Feb 2020 17:13:50 +0000 (UTC)
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.kernel.org (Postfix) with ESMTP id E90B7208C4
	for <patchwork-kvm@patchwork.kernel.org>;
 Tue, 18 Feb 2020 17:13:49 +0000 (UTC)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple; d=kernel.org;
	s=default; t=1582046030;
	bh=bM8YN2ZfJudIpOdoYqa4P1Zkj3Pg0uPLLJygiEJ4s1o=;
	h=From:To:Cc:Subject:Date:In-Reply-To:References:List-ID:From;
	b=mDoloOKCFN34ePPDVkYvaGkDOApbu80Y94YNVZLzZx+EVWn4UyCcqiHykNQFsbSPi
	 TezT4quEt9uABBHStuAVwQyoxIFginb0Mx0Rphwpxmzf2Bu9g0pFn6VnghMC+DER8a
	 Bi46zzIxnr3/kBF6xxMsP9J/Ibz19dwXrvjnrK+c=
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S1727780AbgBRRNn (ORCPT
        <rfc822;patchwork-kvm@patchwork.kernel.org>);
        Tue, 18 Feb 2020 12:13:43 -0500
Received: from mail-ot1-f65.google.com ([209.85.210.65]:34869 "EHLO
        mail-ot1-f65.google.com" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S1727727AbgBRRNm (ORCPT <rfc822;kvm@vger.kernel.org>);
        Tue, 18 Feb 2020 12:13:42 -0500
Received: by mail-ot1-f65.google.com with SMTP id r16so20278718otd.2;
        Tue, 18 Feb 2020 09:13:40 -0800 (PST)
X-Google-DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
        d=1e100.net; s=20161025;
        h=x-gm-message-state:from:to:cc:subject:date:message-id:in-reply-to
         :references:mime-version:content-transfer-encoding;
        bh=FoqaseM22NqKzdP6diWbwHzzLAglDjPvVApnWfidhno=;
        b=cVH/YljX8Fkq2glbR+L1DlM9yhbPK0scnU/5LTLA5XkubLGU8P23KmW/yU8PSbXXuT
         kEz/+jI7IYaGu1/kI1WHtiMHqBAxM+jG4gvzaplsQrjJv5snxsdW69BsvD1o1K+udpSp
         1i+tilKQsTu1Yqgem8z+zPgmy8GYDcMLgdNb2Za90ouceJT9W9EVMRL4JSPYDjJX0KKe
         XDMk3WnKcPmOXCDCnYOPqi4AMUZ7hO6/u9WYvu9TeC624hz8W06GnxqpYKYLVSXpoDtZ
         Qau8/bQlxCkcpqlqt6XY6qL0UEVdjtK3iQYXP+J3xcpChDmddLuFbgzrZTa7mBd/XezD
         Nw0Q==
X-Gm-Message-State: APjAAAU/Bo3DNEb119gvRHV8oWRbfH0a9rj1BfKSzYyN9+v515fXluYZ
        XVHIKwobc9LDb0NXKoSlaw==
X-Google-Smtp-Source: 
 APXvYqw4vgSmdpsSYxMVMymSrQmGp8BN32RULVNjVRuf9KGXenrEyhdhKj6dTUd1/cfRh69w0KzQXA==
X-Received: by 2002:a9d:de9:: with SMTP id 96mr16562460ots.222.1582046020074;
        Tue, 18 Feb 2020 09:13:40 -0800 (PST)
Received: from xps15.herring.priv (24-155-109-49.dyn.grandenetworks.net.
 [24.155.109.49])
        by smtp.googlemail.com with ESMTPSA id
 y25sm1545755oto.27.2020.02.18.09.13.38
        (version=TLS1_3 cipher=TLS_AES_256_GCM_SHA384 bits=256/256);
        Tue, 18 Feb 2020 09:13:39 -0800 (PST)
From: Rob Herring <robh@kernel.org>
To: linux-arm-kernel@lists.infradead.org, linux-kernel@vger.kernel.org,
        soc@kernel.org, Andre Przywara <andre.przywara@arm.com>,
        Robert Richter <rrichter@marvell.com>,
        Jon Loeliger <jdl@jdl.com>, Alexander Graf <graf@amazon.com>,
        Matthias Brugger <mbrugger@suse.com>,
        Mark Langsdorf <mlangsdo@redhat.com>
Cc: Alex Williamson <alex.williamson@redhat.com>,
        Borislav Petkov <bp@alien8.de>,
        Cornelia Huck <cohuck@redhat.com>,
        Daniel Lezcano <daniel.lezcano@linaro.org>,
        "David S. Miller" <davem@davemloft.net>,
        devicetree@vger.kernel.org, Eric Auger <eric.auger@redhat.com>,
        iommu@lists.linux-foundation.org,
        James Morse <james.morse@arm.com>,
        Jens Axboe <axboe@kernel.dk>, Joerg Roedel <joro@8bytes.org>,
        kvm@vger.kernel.org, linux-clk@vger.kernel.org,
        linux-edac@vger.kernel.org, linux-ide@vger.kernel.org,
        linux-pm@vger.kernel.org,
        Mauro Carvalho Chehab <mchehab@kernel.org>,
        netdev@vger.kernel.org, "Rafael J. Wysocki" <rjw@rjwysocki.net>,
        Robin Murphy <robin.murphy@arm.com>,
        Stephen Boyd <sboyd@kernel.org>,
        Tony Luck <tony.luck@intel.com>,
        Viresh Kumar <viresh.kumar@linaro.org>,
        Will Deacon <will@kernel.org>
Subject: [RFC PATCH 10/11] ARM: dts: Remove Calxeda platforms
Date: Tue, 18 Feb 2020 11:13:20 -0600
Message-Id: <20200218171321.30990-11-robh@kernel.org>
X-Mailer: git-send-email 2.20.1
In-Reply-To: <20200218171321.30990-1-robh@kernel.org>
References: <20200218171321.30990-1-robh@kernel.org>
MIME-Version: 1.0
Sender: kvm-owner@vger.kernel.org
Precedence: bulk
List-ID: <kvm.vger.kernel.org>
X-Mailing-List: kvm@vger.kernel.org

Cc: devicetree@vger.kernel.org
Signed-off-by: Rob Herring <robh@kernel.org>
---
 arch/arm/boot/dts/Makefile        |   3 -
 arch/arm/boot/dts/ecx-2000.dts    | 103 -------------
 arch/arm/boot/dts/ecx-common.dtsi | 230 ------------------------------
 arch/arm/boot/dts/highbank.dts    | 161 ---------------------
 4 files changed, 497 deletions(-)
 delete mode 100644 arch/arm/boot/dts/ecx-2000.dts
 delete mode 100644 arch/arm/boot/dts/ecx-common.dtsi
 delete mode 100644 arch/arm/boot/dts/highbank.dts

diff --git a/arch/arm/boot/dts/Makefile b/arch/arm/boot/dts/Makefile
index d6546d2676b9..a78da2e25966 100644
--- a/arch/arm/boot/dts/Makefile
+++ b/arch/arm/boot/dts/Makefile
@@ -224,9 +224,6 @@ dtb-$(CONFIG_ARCH_GEMINI) += \
 	gemini-wbd222.dtb
 dtb-$(CONFIG_ARCH_HI3xxx) += \
 	hi3620-hi4511.dtb
-dtb-$(CONFIG_ARCH_HIGHBANK) += \
-	highbank.dtb \
-	ecx-2000.dtb
 dtb-$(CONFIG_ARCH_HIP01) += \
 	hip01-ca9x2.dtb
 dtb-$(CONFIG_ARCH_HIP04) += \
diff --git a/arch/arm/boot/dts/ecx-2000.dts b/arch/arm/boot/dts/ecx-2000.dts
deleted file mode 100644
index 5651ae6dc969..000000000000
--- a/arch/arm/boot/dts/ecx-2000.dts
+++ /dev/null
@@ -1,103 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0-only
-/*
- * Copyright 2011-2012 Calxeda, Inc.
- */
-
-/dts-v1/;
-
-/* First 4KB has pen for secondary cores. */
-/memreserve/ 0x00000000 0x0001000;
-
-/ {
-	model = "Calxeda ECX-2000";
-	compatible = "calxeda,ecx-2000";
-	#address-cells = <2>;
-	#size-cells = <2>;
-	clock-ranges;
-
-	cpus {
-		#address-cells = <1>;
-		#size-cells = <0>;
-
-		cpu@0 {
-			compatible = "arm,cortex-a15";
-			device_type = "cpu";
-			reg = <0>;
-			clocks = <&a9pll>;
-			clock-names = "cpu";
-		};
-
-		cpu@1 {
-			compatible = "arm,cortex-a15";
-			device_type = "cpu";
-			reg = <1>;
-			clocks = <&a9pll>;
-			clock-names = "cpu";
-		};
-
-		cpu@2 {
-			compatible = "arm,cortex-a15";
-			device_type = "cpu";
-			reg = <2>;
-			clocks = <&a9pll>;
-			clock-names = "cpu";
-		};
-
-		cpu@3 {
-			compatible = "arm,cortex-a15";
-			device_type = "cpu";
-			reg = <3>;
-			clocks = <&a9pll>;
-			clock-names = "cpu";
-		};
-	};
-
-	memory@0 {
-		name = "memory";
-		device_type = "memory";
-		reg = <0x00000000 0x00000000 0x00000000 0xff800000>;
-	};
-
-	memory@200000000 {
-		name = "memory";
-		device_type = "memory";
-		reg = <0x00000002 0x00000000 0x00000003 0x00000000>;
-	};
-
-	soc {
-		ranges = <0x00000000 0x00000000 0x00000000 0xffffffff>;
-
-		timer {
-			compatible = "arm,cortex-a15-timer", "arm,armv7-timer"; 			interrupts = <1 13 0xf08>,
-				<1 14 0xf08>,
-				<1 11 0xf08>,
-				<1 10 0xf08>;
-		};
-
-		memory-controller@fff00000 {
-			compatible = "calxeda,ecx-2000-ddr-ctrl";
-			reg = <0xfff00000 0x1000>;
-			interrupts = <0 91 4>;
-		};
-
-		intc: interrupt-controller@fff11000 {
-			compatible = "arm,cortex-a15-gic";
-			#interrupt-cells = <3>;
-			#size-cells = <0>;
-			#address-cells = <1>;
-			interrupt-controller;
-			interrupts = <1 9 0xf04>;
-			reg = <0xfff11000 0x1000>,
-			      <0xfff12000 0x2000>,
-			      <0xfff14000 0x2000>,
-			      <0xfff16000 0x2000>;
-		};
-
-		pmu {
-			compatible = "arm,cortex-a9-pmu";
-			interrupts = <0 76 4  0 75 4  0 74 4  0 73 4>;
-		};
-	};
-};
-
-/include/ "ecx-common.dtsi"
diff --git a/arch/arm/boot/dts/ecx-common.dtsi b/arch/arm/boot/dts/ecx-common.dtsi
deleted file mode 100644
index 66ee1d34f72b..000000000000
--- a/arch/arm/boot/dts/ecx-common.dtsi
+++ /dev/null
@@ -1,230 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0-only
-/*
- * Copyright 2011-2012 Calxeda, Inc.
- */
-
-/ {
-	chosen {
-		bootargs = "console=ttyAMA0";
-	};
-
-	psci {
-		compatible	= "arm,psci";
-		method		= "smc";
-		cpu_suspend	= <0x84000002>;
-		cpu_off		= <0x84000004>;
-		cpu_on		= <0x84000006>;
-	};
-
-	soc {
-		#address-cells = <1>;
-		#size-cells = <1>;
-		compatible = "simple-bus";
-		interrupt-parent = <&intc>;
-
-		sata@ffe08000 {
-			compatible = "calxeda,hb-ahci";
-			reg = <0xffe08000 0x10000>;
-			interrupts = <0 83 4>;
-			dma-coherent;
-			calxeda,port-phys = <&combophy5 0 &combophy0 0
-					     &combophy0 1 &combophy0 2
-					     &combophy0 3>;
-			calxeda,sgpio-gpio =<&gpioh 5 1 &gpioh 6 1 &gpioh 7 1>;
-			calxeda,led-order = <4 0 1 2 3>;
-		};
-
-		sdhci@ffe0e000 {
-			compatible = "calxeda,hb-sdhci";
-			reg = <0xffe0e000 0x1000>;
-			interrupts = <0 90 4>;
-			clocks = <&eclk>;
-			status = "disabled";
-		};
-
-		ipc@fff20000 {
-			compatible = "arm,pl320", "arm,primecell";
-			reg = <0xfff20000 0x1000>;
-			interrupts = <0 7 4>;
-			clocks = <&pclk>;
-			clock-names = "apb_pclk";
-		};
-
-		gpioe: gpio@fff30000 {
-			#gpio-cells = <2>;
-			compatible = "arm,pl061", "arm,primecell";
-			gpio-controller;
-			reg = <0xfff30000 0x1000>;
-			interrupts = <0 14 4>;
-			clocks = <&pclk>;
-			clock-names = "apb_pclk";
-			status = "disabled";
-		};
-
-		gpiof: gpio@fff31000 {
-			#gpio-cells = <2>;
-			compatible = "arm,pl061", "arm,primecell";
-			gpio-controller;
-			reg = <0xfff31000 0x1000>;
-			interrupts = <0 15 4>;
-			clocks = <&pclk>;
-			clock-names = "apb_pclk";
-			status = "disabled";
-		};
-
-		gpiog: gpio@fff32000 {
-			#gpio-cells = <2>;
-			compatible = "arm,pl061", "arm,primecell";
-			gpio-controller;
-			reg = <0xfff32000 0x1000>;
-			interrupts = <0 16 4>;
-			clocks = <&pclk>;
-			clock-names = "apb_pclk";
-			status = "disabled";
-		};
-
-		gpioh: gpio@fff33000 {
-			#gpio-cells = <2>;
-			compatible = "arm,pl061", "arm,primecell";
-			gpio-controller;
-			reg = <0xfff33000 0x1000>;
-			interrupts = <0 17 4>;
-			clocks = <&pclk>;
-			clock-names = "apb_pclk";
-			status = "disabled";
-		};
-
-		timer@fff34000 {
-			compatible = "arm,sp804", "arm,primecell";
-			reg = <0xfff34000 0x1000>;
-			interrupts = <0 18 4>;
-			clocks = <&pclk>;
-			clock-names = "apb_pclk";
-		};
-
-		rtc@fff35000 {
-			compatible = "arm,pl031", "arm,primecell";
-			reg = <0xfff35000 0x1000>;
-			interrupts = <0 19 4>;
-			clocks = <&pclk>;
-			clock-names = "apb_pclk";
-		};
-
-		serial@fff36000 {
-			compatible = "arm,pl011", "arm,primecell";
-			reg = <0xfff36000 0x1000>;
-			interrupts = <0 20 4>;
-			clocks = <&pclk>;
-			clock-names = "apb_pclk";
-		};
-
-		smic@fff3a000 {
-			compatible = "ipmi-smic";
-			device_type = "ipmi";
-			reg = <0xfff3a000 0x1000>;
-			interrupts = <0 24 4>;
-			reg-size = <4>;
-			reg-spacing = <4>;
-		};
-
-		sregs@fff3c000 {
-			compatible = "calxeda,hb-sregs";
-			reg = <0xfff3c000 0x1000>;
-
-			clocks {
-				#address-cells = <1>;
-				#size-cells = <0>;
-
-				osc: oscillator {
-					#clock-cells = <0>;
-					compatible = "fixed-clock";
-					clock-frequency = <33333000>;
-				};
-
-				ddrpll: ddrpll {
-					#clock-cells = <0>;
-					compatible = "calxeda,hb-pll-clock";
-					clocks = <&osc>;
-					reg = <0x108>;
-				};
-
-				a9pll: a9pll {
-					#clock-cells = <0>;
-					compatible = "calxeda,hb-pll-clock";
-					clocks = <&osc>;
-					reg = <0x100>;
-				};
-
-				a9periphclk: a9periphclk {
-					#clock-cells = <0>;
-					compatible = "calxeda,hb-a9periph-clock";
-					clocks = <&a9pll>;
-					reg = <0x104>;
-				};
-
-				a9bclk: a9bclk {
-					#clock-cells = <0>;
-					compatible = "calxeda,hb-a9bus-clock";
-					clocks = <&a9pll>;
-					reg = <0x104>;
-				};
-
-				emmcpll: emmcpll {
-					#clock-cells = <0>;
-					compatible = "calxeda,hb-pll-clock";
-					clocks = <&osc>;
-					reg = <0x10C>;
-				};
-
-				eclk: eclk {
-					#clock-cells = <0>;
-					compatible = "calxeda,hb-emmc-clock";
-					clocks = <&emmcpll>;
-					reg = <0x114>;
-				};
-
-				pclk: pclk {
-					#clock-cells = <0>;
-					compatible = "fixed-clock";
-					clock-frequency = <150000000>;
-				};
-			};
-		};
-
-		dma@fff3d000 {
-			compatible = "arm,pl330", "arm,primecell";
-			reg = <0xfff3d000 0x1000>;
-			interrupts = <0 92 4>;
-			clocks = <&pclk>;
-			clock-names = "apb_pclk";
-		};
-
-		ethernet@fff50000 {
-			compatible = "calxeda,hb-xgmac";
-			reg = <0xfff50000 0x1000>;
-			interrupts = <0 77 4  0 78 4  0 79 4>;
-			dma-coherent;
-		};
-
-		ethernet@fff51000 {
-			compatible = "calxeda,hb-xgmac";
-			reg = <0xfff51000 0x1000>;
-			interrupts = <0 80 4  0 81 4  0 82 4>;
-			dma-coherent;
-		};
-
-		combophy0: combo-phy@fff58000 {
-			compatible = "calxeda,hb-combophy";
-			#phy-cells = <1>;
-			reg = <0xfff58000 0x1000>;
-			phydev = <5>;
-		};
-
-		combophy5: combo-phy@fff5d000 {
-			compatible = "calxeda,hb-combophy";
-			#phy-cells = <1>;
-			reg = <0xfff5d000 0x1000>;
-			phydev = <31>;
-		};
-	};
-};
diff --git a/arch/arm/boot/dts/highbank.dts b/arch/arm/boot/dts/highbank.dts
deleted file mode 100644
index f4e4dca6f7e7..000000000000
--- a/arch/arm/boot/dts/highbank.dts
+++ /dev/null
@@ -1,161 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0-only
-/*
- * Copyright 2011-2012 Calxeda, Inc.
- */
-
-/dts-v1/;
-
-/* First 4KB has pen for secondary cores. */
-/memreserve/ 0x00000000 0x0001000;
-
-/ {
-	model = "Calxeda Highbank";
-	compatible = "calxeda,highbank";
-	#address-cells = <1>;
-	#size-cells = <1>;
-	clock-ranges;
-
-	cpus {
-		#address-cells = <1>;
-		#size-cells = <0>;
-
-		cpu@900 {
-			compatible = "arm,cortex-a9";
-			device_type = "cpu";
-			reg = <0x900>;
-			next-level-cache = <&L2>;
-			clocks = <&a9pll>;
-			clock-names = "cpu";
-			operating-points = <
-				/* kHz    ignored */
-				 1300000  1000000
-				 1200000  1000000
-				 1100000  1000000
-				  800000  1000000
-				  400000  1000000
-				  200000  1000000
-			>;
-			clock-latency = <100000>;
-		};
-
-		cpu@901 {
-			compatible = "arm,cortex-a9";
-			device_type = "cpu";
-			reg = <0x901>;
-			next-level-cache = <&L2>;
-			clocks = <&a9pll>;
-			clock-names = "cpu";
-			operating-points = <
-				/* kHz    ignored */
-				 1300000  1000000
-				 1200000  1000000
-				 1100000  1000000
-				  800000  1000000
-				  400000  1000000
-				  200000  1000000
-			>;
-			clock-latency = <100000>;
-		};
-
-		cpu@902 {
-			compatible = "arm,cortex-a9";
-			device_type = "cpu";
-			reg = <0x902>;
-			next-level-cache = <&L2>;
-			clocks = <&a9pll>;
-			clock-names = "cpu";
-			operating-points = <
-				/* kHz    ignored */
-				 1300000  1000000
-				 1200000  1000000
-				 1100000  1000000
-				  800000  1000000
-				  400000  1000000
-				  200000  1000000
-			>;
-			clock-latency = <100000>;
-		};
-
-		cpu@903 {
-			compatible = "arm,cortex-a9";
-			device_type = "cpu";
-			reg = <0x903>;
-			next-level-cache = <&L2>;
-			clocks = <&a9pll>;
-			clock-names = "cpu";
-			operating-points = <
-				/* kHz    ignored */
-				 1300000  1000000
-				 1200000  1000000
-				 1100000  1000000
-				  800000  1000000
-				  400000  1000000
-				  200000  1000000
-			>;
-			clock-latency = <100000>;
-		};
-	};
-
-	memory {
-		name = "memory";
-		device_type = "memory";
-		reg = <0x00000000 0xff900000>;
-	};
-
-	soc {
-		ranges = <0x00000000 0x00000000 0xffffffff>;
-
-		memory-controller@fff00000 {
-			compatible = "calxeda,hb-ddr-ctrl";
-			reg = <0xfff00000 0x1000>;
-			interrupts = <0 91 4>;
-		};
-
-		timer@fff10600 {
-			compatible = "arm,cortex-a9-twd-timer";
-			reg = <0xfff10600 0x20>;
-			interrupts = <1 13 0xf01>;
-			clocks = <&a9periphclk>;
-		};
-
-		watchdog@fff10620 {
-			compatible = "arm,cortex-a9-twd-wdt";
-			reg = <0xfff10620 0x20>;
-			interrupts = <1 14 0xf01>;
-			clocks = <&a9periphclk>;
-		};
-
-		intc: interrupt-controller@fff11000 {
-			compatible = "arm,cortex-a9-gic";
-			#interrupt-cells = <3>;
-			#size-cells = <0>;
-			#address-cells = <1>;
-			interrupt-controller;
-			reg = <0xfff11000 0x1000>,
-			      <0xfff10100 0x100>;
-		};
-
-		L2: l2-cache {
-			compatible = "arm,pl310-cache";
-			reg = <0xfff12000 0x1000>;
-			interrupts = <0 70 4>;
-			cache-unified;
-			cache-level = <2>;
-		};
-
-		pmu {
-			compatible = "arm,cortex-a9-pmu";
-			interrupts = <0 76 4  0 75 4  0 74 4  0 73 4>;
-		};
-
-
-		sregs@fff3c200 {
-			compatible = "calxeda,hb-sregs-l2-ecc";
-			reg = <0xfff3c200 0x100>;
-			interrupts = <0 71 4  0 72 4>;
-		};
-
-	};
-};
-
-/include/ "ecx-common.dtsi"

From patchwork Tue Feb 18 17:13:21 2020
Content-Type: text/plain; charset="utf-8"
MIME-Version: 1.0
Content-Transfer-Encoding: 7bit
X-Patchwork-Submitter: Rob Herring <robh@kernel.org>
X-Patchwork-Id: 11389045
Return-Path: <SRS0=NRU2=4G=vger.kernel.org=kvm-owner@kernel.org>
Received: from mail.kernel.org (pdx-korg-mail-1.web.codeaurora.org
 [172.30.200.123])
	by pdx-korg-patchwork-2.web.codeaurora.org (Postfix) with ESMTP id 067FA924
	for <patchwork-kvm@patchwork.kernel.org>;
 Tue, 18 Feb 2020 17:13:55 +0000 (UTC)
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.kernel.org (Postfix) with ESMTP id CA7CC24673
	for <patchwork-kvm@patchwork.kernel.org>;
 Tue, 18 Feb 2020 17:13:54 +0000 (UTC)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple; d=kernel.org;
	s=default; t=1582046034;
	bh=UusfSUX6YlwdDq5hWBwBGVRzhhQoFnGE6ujZq0EIJFo=;
	h=From:To:Cc:Subject:Date:In-Reply-To:References:List-ID:From;
	b=ZKZOfBLLygLjEBL9twPCOzM0LX1DsBwJOYumLwx7wzDwGnbsmajpZYOhorUvezfd5
	 6QHaEswVVuc2YdaFsehxBCK2GolbnQX+Nlc6UTIWDCdIljWR2+HQuYdNKTm/3ssR06
	 M+jyGoEs06fysEUgqx8BaOchJlUDIz4+TcNJMEbo=
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S1727838AbgBRRNx (ORCPT
        <rfc822;patchwork-kvm@patchwork.kernel.org>);
        Tue, 18 Feb 2020 12:13:53 -0500
Received: from mail-ot1-f66.google.com ([209.85.210.66]:45050 "EHLO
        mail-ot1-f66.google.com" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S1727749AbgBRRNn (ORCPT <rfc822;kvm@vger.kernel.org>);
        Tue, 18 Feb 2020 12:13:43 -0500
Received: by mail-ot1-f66.google.com with SMTP id h9so20198887otj.11;
        Tue, 18 Feb 2020 09:13:42 -0800 (PST)
X-Google-DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
        d=1e100.net; s=20161025;
        h=x-gm-message-state:from:to:cc:subject:date:message-id:in-reply-to
         :references:mime-version:content-transfer-encoding;
        bh=9rvVQxjEcVSUPCQUA8Lpt3skYnAzdX5d/I/sFEuvNBI=;
        b=uBMnaRfczyLxcN3svxXKbC1iOPpBGrsH9zyO8CZRpu44hzBnCnOU4Is1fWPlAHlmKL
         vrJhKDiU7buY+1QwlLA89Z5tk/1EtuEy9Pj8s5iaEgCMulDJD1AEptNuAigwUK90i6p/
         dRzOdjRjZVGXjr5mdowuymtH3PZ3Np9Ix6HF/1efVq4oJLrqErItGwKGDuwPRa5e/9H1
         0oSAlIdHjesfgFSmuOSAKZadIw4/LrpjFUqJIpyz5kunl7/I55WwguLoRZCGqnoUeJOi
         RGFa8DDbvQc++CGXKG0SRTjCG3RvelBG0FCWeuaZmsKQuFfGZnivdoSNFMvK1mTcjPAv
         YW7A==
X-Gm-Message-State: APjAAAXob4iuZhEaA4neQU1Ltaxzm4FxVE2Utqh34QeNGofc10VMjSoT
        jJq6GGaWxdcftZDnP/0mpA==
X-Google-Smtp-Source: 
 APXvYqwA7mxMXzEdUlX4eeVusmEzMBWCscl1LrX6G+t9T9zWzSOg5CEef2pK0PwwCFSogRLqNYvU8w==
X-Received: by 2002:a05:6830:18c4:: with SMTP id
 v4mr15986958ote.265.1582046021808;
        Tue, 18 Feb 2020 09:13:41 -0800 (PST)
Received: from xps15.herring.priv (24-155-109-49.dyn.grandenetworks.net.
 [24.155.109.49])
        by smtp.googlemail.com with ESMTPSA id
 y25sm1545755oto.27.2020.02.18.09.13.40
        (version=TLS1_3 cipher=TLS_AES_256_GCM_SHA384 bits=256/256);
        Tue, 18 Feb 2020 09:13:41 -0800 (PST)
From: Rob Herring <robh@kernel.org>
To: linux-arm-kernel@lists.infradead.org, linux-kernel@vger.kernel.org,
        soc@kernel.org, Andre Przywara <andre.przywara@arm.com>,
        Robert Richter <rrichter@marvell.com>,
        Jon Loeliger <jdl@jdl.com>, Alexander Graf <graf@amazon.com>,
        Matthias Brugger <mbrugger@suse.com>,
        Mark Langsdorf <mlangsdo@redhat.com>
Cc: Alex Williamson <alex.williamson@redhat.com>,
        Borislav Petkov <bp@alien8.de>,
        Cornelia Huck <cohuck@redhat.com>,
        Daniel Lezcano <daniel.lezcano@linaro.org>,
        "David S. Miller" <davem@davemloft.net>,
        devicetree@vger.kernel.org, Eric Auger <eric.auger@redhat.com>,
        iommu@lists.linux-foundation.org,
        James Morse <james.morse@arm.com>,
        Jens Axboe <axboe@kernel.dk>, Joerg Roedel <joro@8bytes.org>,
        kvm@vger.kernel.org, linux-clk@vger.kernel.org,
        linux-edac@vger.kernel.org, linux-ide@vger.kernel.org,
        linux-pm@vger.kernel.org,
        Mauro Carvalho Chehab <mchehab@kernel.org>,
        netdev@vger.kernel.org, "Rafael J. Wysocki" <rjw@rjwysocki.net>,
        Robin Murphy <robin.murphy@arm.com>,
        Stephen Boyd <sboyd@kernel.org>,
        Tony Luck <tony.luck@intel.com>,
        Viresh Kumar <viresh.kumar@linaro.org>,
        Will Deacon <will@kernel.org>
Subject: [RFC PATCH 11/11] dt-bindings: Remove Calxeda platforms bindings
Date: Tue, 18 Feb 2020 11:13:21 -0600
Message-Id: <20200218171321.30990-12-robh@kernel.org>
X-Mailer: git-send-email 2.20.1
In-Reply-To: <20200218171321.30990-1-robh@kernel.org>
References: <20200218171321.30990-1-robh@kernel.org>
MIME-Version: 1.0
Sender: kvm-owner@vger.kernel.org
Precedence: bulk
List-ID: <kvm.vger.kernel.org>
X-Mailing-List: kvm@vger.kernel.org

Cc: devicetree@vger.kernel.org
Signed-off-by: Rob Herring <robh@kernel.org>
---
 .../devicetree/bindings/arm/calxeda.yaml      | 22 ----------
 .../devicetree/bindings/arm/calxeda/l2ecc.txt | 15 -------
 .../devicetree/bindings/ata/sata_highbank.txt | 44 -------------------
 .../devicetree/bindings/clock/calxeda.txt     | 17 -------
 .../memory-controllers/calxeda-ddr-ctrlr.txt  | 16 -------
 .../devicetree/bindings/net/calxeda-xgmac.txt | 18 --------
 .../bindings/phy/calxeda-combophy.txt         | 17 -------
 7 files changed, 149 deletions(-)
 delete mode 100644 Documentation/devicetree/bindings/arm/calxeda.yaml
 delete mode 100644 Documentation/devicetree/bindings/arm/calxeda/l2ecc.txt
 delete mode 100644 Documentation/devicetree/bindings/ata/sata_highbank.txt
 delete mode 100644 Documentation/devicetree/bindings/clock/calxeda.txt
 delete mode 100644 Documentation/devicetree/bindings/memory-controllers/calxeda-ddr-ctrlr.txt
 delete mode 100644 Documentation/devicetree/bindings/net/calxeda-xgmac.txt
 delete mode 100644 Documentation/devicetree/bindings/phy/calxeda-combophy.txt

diff --git a/Documentation/devicetree/bindings/arm/calxeda.yaml b/Documentation/devicetree/bindings/arm/calxeda.yaml
deleted file mode 100644
index aa5571d23c39..000000000000
--- a/Documentation/devicetree/bindings/arm/calxeda.yaml
+++ /dev/null
@@ -1,22 +0,0 @@
-# SPDX-License-Identifier: (GPL-2.0 OR BSD-2-Clause)
-%YAML 1.2
----
-$id: http://devicetree.org/schemas/arm/calxeda.yaml#
-$schema: http://devicetree.org/meta-schemas/core.yaml#
-
-title: Calxeda Platforms Device Tree Bindings
-
-maintainers:
-  - Rob Herring <robh@kernel.org>
-description: |+
-  Bindings for boards with Calxeda Cortex-A9 based ECX-1000 (Highbank) SOC
-  or Cortex-A15 based ECX-2000 SOCs
-
-properties:
-  $nodename:
-    const: '/'
-  compatible:
-    items:
-      - enum:
-          - calxeda,highbank
-          - calxeda,ecx-2000
diff --git a/Documentation/devicetree/bindings/arm/calxeda/l2ecc.txt b/Documentation/devicetree/bindings/arm/calxeda/l2ecc.txt
deleted file mode 100644
index 94e642a33db0..000000000000
--- a/Documentation/devicetree/bindings/arm/calxeda/l2ecc.txt
+++ /dev/null
@@ -1,15 +0,0 @@
-Calxeda Highbank L2 cache ECC
-
-Properties:
-- compatible : Should be "calxeda,hb-sregs-l2-ecc"
-- reg : Address and size for ECC error interrupt clear registers.
-- interrupts : Should be single bit error interrupt, then double bit error
-	interrupt.
-
-Example:
-
-	sregs@fff3c200 {
-		compatible = "calxeda,hb-sregs-l2-ecc";
-		reg = <0xfff3c200 0x100>;
-		interrupts = <0 71 4  0 72 4>;
-	};
diff --git a/Documentation/devicetree/bindings/ata/sata_highbank.txt b/Documentation/devicetree/bindings/ata/sata_highbank.txt
deleted file mode 100644
index aa83407cb7a4..000000000000
--- a/Documentation/devicetree/bindings/ata/sata_highbank.txt
+++ /dev/null
@@ -1,44 +0,0 @@
-* Calxeda AHCI SATA Controller
-
-SATA nodes are defined to describe on-chip Serial ATA controllers.
-The Calxeda SATA controller mostly conforms to the AHCI interface
-with some special extensions to add functionality.
-Each SATA controller should have its own node.
-
-Required properties:
-- compatible        : compatible list, contains "calxeda,hb-ahci"
-- interrupts        : <interrupt mapping for SATA IRQ>
-- reg               : <registers mapping>
-
-Optional properties:
-- dma-coherent      : Present if dma operations are coherent
-- calxeda,port-phys : phandle-combophy and lane assignment, which maps each
-			SATA port to a combophy and a lane within that
-			combophy
-- calxeda,sgpio-gpio: phandle-gpio bank, bit offset, and default on or off,
-			which indicates that the driver supports SGPIO
-			indicator lights using the indicated GPIOs
-- calxeda,led-order : a u32 array that map port numbers to offsets within the
-			SGPIO bitstream.
-- calxeda,tx-atten  : a u32 array that contains TX attenuation override
-			codes, one per port. The upper 3 bytes are always
-			0 and thus ignored.
-- calxeda,pre-clocks : a u32 that indicates the number of additional clock
-			cycles to transmit before sending an SGPIO pattern
-- calxeda,post-clocks: a u32 that indicates the number of additional clock
-			cycles to transmit after sending an SGPIO pattern
-
-Example:
-        sata@ffe08000 {
-		compatible = "calxeda,hb-ahci";
-		reg = <0xffe08000 0x1000>;
-		interrupts = <115>;
-		dma-coherent;
-		calxeda,port-phys = <&combophy5 0 &combophy0 0 &combophy0 1
-					&combophy0 2 &combophy0 3>;
-		calxeda,sgpio-gpio =<&gpioh 5 1 &gpioh 6 1 &gpioh 7 1>;
-		calxeda,led-order = <4 0 1 2 3>;
-		calxeda,tx-atten = <0xff 22 0xff 0xff 23>;
-		calxeda,pre-clocks = <10>;
-		calxeda,post-clocks = <0>;
-        };
diff --git a/Documentation/devicetree/bindings/clock/calxeda.txt b/Documentation/devicetree/bindings/clock/calxeda.txt
deleted file mode 100644
index 0a6ac1bdcda1..000000000000
--- a/Documentation/devicetree/bindings/clock/calxeda.txt
+++ /dev/null
@@ -1,17 +0,0 @@
-Device Tree Clock bindings for Calxeda highbank platform
-
-This binding uses the common clock binding[1].
-
-[1] Documentation/devicetree/bindings/clock/clock-bindings.txt
-
-Required properties:
-- compatible : shall be one of the following:
-	"calxeda,hb-pll-clock" - for a PLL clock
-	"calxeda,hb-a9periph-clock" - The A9 peripheral clock divided from the
-		A9 clock.
-	"calxeda,hb-a9bus-clock" - The A9 bus clock divided from the A9 clock.
-	"calxeda,hb-emmc-clock" - Divided clock for MMC/SD controller.
-- reg : shall be the control register offset from SYSREGs base for the clock.
-- clocks : shall be the input parent clock phandle for the clock. This is
-	either an oscillator or a pll output.
-- #clock-cells : from common clock binding; shall be set to 0.
diff --git a/Documentation/devicetree/bindings/memory-controllers/calxeda-ddr-ctrlr.txt b/Documentation/devicetree/bindings/memory-controllers/calxeda-ddr-ctrlr.txt
deleted file mode 100644
index 049675944b78..000000000000
--- a/Documentation/devicetree/bindings/memory-controllers/calxeda-ddr-ctrlr.txt
+++ /dev/null
@@ -1,16 +0,0 @@
-Calxeda DDR memory controller
-
-Properties:
-- compatible : Should be:
-  - "calxeda,hb-ddr-ctrl" for ECX-1000
-  - "calxeda,ecx-2000-ddr-ctrl" for ECX-2000
-- reg : Address and size for DDR controller registers.
-- interrupts : Interrupt for DDR controller.
-
-Example:
-
-	memory-controller@fff00000 {
-		compatible = "calxeda,hb-ddr-ctrl";
-		reg = <0xfff00000 0x1000>;
-		interrupts = <0 91 4>;
-	};
diff --git a/Documentation/devicetree/bindings/net/calxeda-xgmac.txt b/Documentation/devicetree/bindings/net/calxeda-xgmac.txt
deleted file mode 100644
index c8ae996bd8f2..000000000000
--- a/Documentation/devicetree/bindings/net/calxeda-xgmac.txt
+++ /dev/null
@@ -1,18 +0,0 @@
-* Calxeda Highbank 10Gb XGMAC Ethernet
-
-Required properties:
-- compatible : Should be "calxeda,hb-xgmac"
-- reg : Address and length of the register set for the device
-- interrupts : Should contain 3 xgmac interrupts. The 1st is main interrupt.
-  The 2nd is pwr mgt interrupt. The 3rd is low power state interrupt.
-
-Optional properties:
-- dma-coherent      : Present if dma operations are coherent
-
-Example:
-
-ethernet@fff50000 {
-        compatible = "calxeda,hb-xgmac";
-        reg = <0xfff50000 0x1000>;
-        interrupts = <0 77 4  0 78 4  0 79 4>;
-};
diff --git a/Documentation/devicetree/bindings/phy/calxeda-combophy.txt b/Documentation/devicetree/bindings/phy/calxeda-combophy.txt
deleted file mode 100644
index 6622bdb2e8bc..000000000000
--- a/Documentation/devicetree/bindings/phy/calxeda-combophy.txt
+++ /dev/null
@@ -1,17 +0,0 @@
-Calxeda Highbank Combination Phys for SATA
-
-Properties:
-- compatible : Should be "calxeda,hb-combophy"
-- #phy-cells: Should be 1.
-- reg : Address and size for Combination Phy registers.
-- phydev: device ID for programming the combophy.
-
-Example:
-
-	combophy5: combo-phy@fff5d000 {
-		compatible = "calxeda,hb-combophy";
-		#phy-cells = <1>;
-		reg = <0xfff5d000 0x1000>;
-		phydev = <31>;
-	};
-
