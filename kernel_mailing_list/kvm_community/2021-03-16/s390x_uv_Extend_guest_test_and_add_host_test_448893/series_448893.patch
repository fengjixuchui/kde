From patchwork Tue Mar 16 09:16:49 2021
Content-Type: text/plain; charset="utf-8"
MIME-Version: 1.0
Content-Transfer-Encoding: 7bit
X-Patchwork-Submitter: Janosch Frank <frankja@linux.ibm.com>
X-Patchwork-Id: 12141511
Return-Path: <kvm-owner@kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-16.8 required=3.0 tests=BAYES_00,DKIM_SIGNED,
	DKIM_VALID,HEADER_FROM_DIFFERENT_DOMAINS,INCLUDES_CR_TRAILER,INCLUDES_PATCH,
	MAILING_LIST_MULTI,SPF_HELO_NONE,SPF_PASS,USER_AGENT_GIT
	autolearn=unavailable autolearn_force=no version=3.4.0
Received: from mail.kernel.org (mail.kernel.org [198.145.29.99])
	by smtp.lore.kernel.org (Postfix) with ESMTP id 8D459C43332
	for <kvm@archiver.kernel.org>; Tue, 16 Mar 2021 09:20:52 +0000 (UTC)
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by mail.kernel.org (Postfix) with ESMTP id 6C82065023
	for <kvm@archiver.kernel.org>; Tue, 16 Mar 2021 09:20:52 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S235988AbhCPJU1 (ORCPT <rfc822;kvm@archiver.kernel.org>);
        Tue, 16 Mar 2021 05:20:27 -0400
Received: from mx0a-001b2d01.pphosted.com ([148.163.156.1]:39296 "EHLO
        mx0a-001b2d01.pphosted.com" rhost-flags-OK-OK-OK-OK)
        by vger.kernel.org with ESMTP id S232584AbhCPJUF (ORCPT
        <rfc822;kvm@vger.kernel.org>); Tue, 16 Mar 2021 05:20:05 -0400
Received: from pps.filterd (m0098409.ppops.net [127.0.0.1])
        by mx0a-001b2d01.pphosted.com (8.16.0.43/8.16.0.43) with SMTP id
 12G93B0S047405;
        Tue, 16 Mar 2021 05:20:05 -0400
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=ibm.com;
 h=from : to : cc : subject
 : date : message-id : in-reply-to : references : mime-version :
 content-transfer-encoding; s=pp1;
 bh=n98KZT57rRerIs5/wFjWGc8mi2iOF4J+0ZSNe9MRX70=;
 b=gwFCHn+n0c6y2FgQMXv7mXx30Vv7/eISyxqvT+sSIgkyQVLzeFakoOMKvMzXCYDIrTy6
 4j6F3D18RwgTqJOhWmZ6pbUiLN7tDdojKFg7LNe8wkLJ+TvIznABhxIIRKKpKpVXCSxj
 2ebGoLpW3u4dzHSmWoZUyvMCML57MilQZieBAQJfSh020jly9PsW9HrNZ3+Mkemo7XIH
 bNkYLHslnQBjEyEuXA9ACRxlMwZ2EBC4+xWVO3lL0T33NWoJtecG8l2kbDtFRo+tBFCi
 R8D7psKRHQusKcei16a5Im4C/ji9jRyHzYGNtbiGKweX/w1CfWibnL18iTfquVcmAgWG fw==
Received: from pps.reinject (localhost [127.0.0.1])
        by mx0a-001b2d01.pphosted.com with ESMTP id 37arhuafmt-1
        (version=TLSv1.2 cipher=ECDHE-RSA-AES256-GCM-SHA384 bits=256
 verify=NOT);
        Tue, 16 Mar 2021 05:20:05 -0400
Received: from m0098409.ppops.net (m0098409.ppops.net [127.0.0.1])
        by pps.reinject (8.16.0.43/8.16.0.43) with SMTP id 12G93Axr047299;
        Tue, 16 Mar 2021 05:20:04 -0400
Received: from ppma06ams.nl.ibm.com (66.31.33a9.ip4.static.sl-reverse.com
 [169.51.49.102])
        by mx0a-001b2d01.pphosted.com with ESMTP id 37arhuafkp-1
        (version=TLSv1.2 cipher=ECDHE-RSA-AES256-GCM-SHA384 bits=256
 verify=NOT);
        Tue, 16 Mar 2021 05:20:04 -0400
Received: from pps.filterd (ppma06ams.nl.ibm.com [127.0.0.1])
        by ppma06ams.nl.ibm.com (8.16.0.43/8.16.0.43) with SMTP id
 12G9C3EP005481;
        Tue, 16 Mar 2021 09:20:02 GMT
Received: from b06cxnps4075.portsmouth.uk.ibm.com
 (d06relay12.portsmouth.uk.ibm.com [9.149.109.197])
        by ppma06ams.nl.ibm.com with ESMTP id 378mnh2pfw-1
        (version=TLSv1.2 cipher=ECDHE-RSA-AES256-GCM-SHA384 bits=256
 verify=NOT);
        Tue, 16 Mar 2021 09:20:02 +0000
Received: from d06av22.portsmouth.uk.ibm.com (d06av22.portsmouth.uk.ibm.com
 [9.149.105.58])
        by b06cxnps4075.portsmouth.uk.ibm.com (8.14.9/8.14.9/NCO v10.0) with
 ESMTP id 12G9K02a2753156
        (version=TLSv1/SSLv3 cipher=DHE-RSA-AES256-GCM-SHA384 bits=256
 verify=OK);
        Tue, 16 Mar 2021 09:20:00 GMT
Received: from d06av22.portsmouth.uk.ibm.com (unknown [127.0.0.1])
        by IMSVA (Postfix) with ESMTP id 271DA4C058;
        Tue, 16 Mar 2021 09:20:00 +0000 (GMT)
Received: from d06av22.portsmouth.uk.ibm.com (unknown [127.0.0.1])
        by IMSVA (Postfix) with ESMTP id E62464C040;
        Tue, 16 Mar 2021 09:19:58 +0000 (GMT)
Received: from localhost.localdomain (unknown [9.145.146.129])
        by d06av22.portsmouth.uk.ibm.com (Postfix) with ESMTP;
        Tue, 16 Mar 2021 09:19:58 +0000 (GMT)
From: Janosch Frank <frankja@linux.ibm.com>
To: kvm@vger.kernel.org
Cc: linux-s390@vger.kernel.org, thuth@redhat.com, david@redhat.com,
        imbrenda@linux.ibm.com
Subject: [kvm-unit-tests PATCH 1/6] s390x: uv-guest: Add invalid share
 location test
Date: Tue, 16 Mar 2021 09:16:49 +0000
Message-Id: <20210316091654.1646-2-frankja@linux.ibm.com>
X-Mailer: git-send-email 2.27.0
In-Reply-To: <20210316091654.1646-1-frankja@linux.ibm.com>
References: <20210316091654.1646-1-frankja@linux.ibm.com>
MIME-Version: 1.0
X-TM-AS-GCONF: 00
X-Proofpoint-Virus-Version: vendor=fsecure engine=2.50.10434:6.0.369,18.0.761
 definitions=2021-03-16_03:2021-03-15,2021-03-16 signatures=0
X-Proofpoint-Spam-Details: rule=outbound_notspam policy=outbound score=0
 lowpriorityscore=0
 malwarescore=0 bulkscore=0 spamscore=0 clxscore=1015 mlxscore=0
 phishscore=0 impostorscore=0 suspectscore=0 adultscore=0 mlxlogscore=999
 priorityscore=1501 classifier=spam adjust=0 reason=mlx scancount=1
 engine=8.12.0-2009150000 definitions=main-2103160063
Precedence: bulk
List-ID: <kvm.vger.kernel.org>
X-Mailing-List: kvm@vger.kernel.org

Let's also test sharing unavailable memory.

Signed-off-by: Janosch Frank <frankja@linux.ibm.com>
---
 s390x/uv-guest.c | 5 +++++
 1 file changed, 5 insertions(+)

diff --git a/s390x/uv-guest.c b/s390x/uv-guest.c
index 99544442..a13669ab 100644
--- a/s390x/uv-guest.c
+++ b/s390x/uv-guest.c
@@ -15,6 +15,7 @@
 #include <asm/interrupt.h>
 #include <asm/facility.h>
 #include <asm/uv.h>
+#include <sclp.h>
 
 static unsigned long page;
 
@@ -99,6 +100,10 @@ static void test_sharing(void)
 	uvcb.header.len = sizeof(uvcb);
 	cc = uv_call(0, (u64)&uvcb);
 	report(cc == 0 && uvcb.header.rc == UVC_RC_EXECUTED, "share");
+	uvcb.paddr = get_ram_size() + PAGE_SIZE;
+	cc = uv_call(0, (u64)&uvcb);
+	report(cc == 1 && uvcb.header.rc == 0x101, "invalid memory");
+	uvcb.paddr = page;
 	report_prefix_pop();
 
 	report_prefix_push("unshare");

From patchwork Tue Mar 16 09:16:50 2021
Content-Type: text/plain; charset="utf-8"
MIME-Version: 1.0
Content-Transfer-Encoding: 7bit
X-Patchwork-Submitter: Janosch Frank <frankja@linux.ibm.com>
X-Patchwork-Id: 12141513
Return-Path: <kvm-owner@kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-16.8 required=3.0 tests=BAYES_00,DKIM_SIGNED,
	DKIM_VALID,HEADER_FROM_DIFFERENT_DOMAINS,INCLUDES_CR_TRAILER,INCLUDES_PATCH,
	MAILING_LIST_MULTI,SPF_HELO_NONE,SPF_PASS,USER_AGENT_GIT
	autolearn=unavailable autolearn_force=no version=3.4.0
Received: from mail.kernel.org (mail.kernel.org [198.145.29.99])
	by smtp.lore.kernel.org (Postfix) with ESMTP id 25983C4360C
	for <kvm@archiver.kernel.org>; Tue, 16 Mar 2021 09:20:53 +0000 (UTC)
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by mail.kernel.org (Postfix) with ESMTP id E3B7B64FDC
	for <kvm@archiver.kernel.org>; Tue, 16 Mar 2021 09:20:52 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S235998AbhCPJU2 (ORCPT <rfc822;kvm@archiver.kernel.org>);
        Tue, 16 Mar 2021 05:20:28 -0400
Received: from mx0a-001b2d01.pphosted.com ([148.163.156.1]:25170 "EHLO
        mx0a-001b2d01.pphosted.com" rhost-flags-OK-OK-OK-OK)
        by vger.kernel.org with ESMTP id S232739AbhCPJUJ (ORCPT
        <rfc822;kvm@vger.kernel.org>); Tue, 16 Mar 2021 05:20:09 -0400
Received: from pps.filterd (m0098404.ppops.net [127.0.0.1])
        by mx0a-001b2d01.pphosted.com (8.16.0.43/8.16.0.43) with SMTP id
 12G9AXtc004065;
        Tue, 16 Mar 2021 05:20:09 -0400
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=ibm.com;
 h=from : to : cc : subject
 : date : message-id : in-reply-to : references : mime-version :
 content-transfer-encoding; s=pp1;
 bh=Lij388ad0CUJzIo/qMlXcxq0dy73bGLAiDwnk1Ib5EM=;
 b=tEwMjJsiDwcPSqAiqzmxccSUjMsuIq63tCBgwVvw4bxuJKhC9EUH5gXZU1sWufG29VHB
 1uK9KUgcKKFXHwtbZyiG8R1BrtTeEtkcsIQo2TCMMUqA5dCJGyX6rtMA9CseVA5ulIEn
 760kqRtpJ8SqmDadSoGuAJkCz6QqyY+QGQg79807B3LGEEYgdemq6sfMMnE6mnQ1WNYg
 5ZoiabRa0UeezHEipi//pVHkXwemU5grYbQ6QbQRv/QshTht9QzX6hqJKtYSmy5oebZj
 ytIoVh9fQcV6EwFy+3tnv0/oGB/F809PmAQjhQ3ylNUPR7JQZ/Ty45WpItNya8/N4Kup xA==
Received: from pps.reinject (localhost [127.0.0.1])
        by mx0a-001b2d01.pphosted.com with ESMTP id 37aseh8qjt-1
        (version=TLSv1.2 cipher=ECDHE-RSA-AES256-GCM-SHA384 bits=256
 verify=NOT);
        Tue, 16 Mar 2021 05:20:08 -0400
Received: from m0098404.ppops.net (m0098404.ppops.net [127.0.0.1])
        by pps.reinject (8.16.0.43/8.16.0.43) with SMTP id 12G9BBla008797;
        Tue, 16 Mar 2021 05:20:08 -0400
Received: from ppma04ams.nl.ibm.com (63.31.33a9.ip4.static.sl-reverse.com
 [169.51.49.99])
        by mx0a-001b2d01.pphosted.com with ESMTP id 37aseh8qg7-1
        (version=TLSv1.2 cipher=ECDHE-RSA-AES256-GCM-SHA384 bits=256
 verify=NOT);
        Tue, 16 Mar 2021 05:20:08 -0400
Received: from pps.filterd (ppma04ams.nl.ibm.com [127.0.0.1])
        by ppma04ams.nl.ibm.com (8.16.0.43/8.16.0.43) with SMTP id
 12G9D0TC016859;
        Tue, 16 Mar 2021 09:20:04 GMT
Received: from b06cxnps4076.portsmouth.uk.ibm.com
 (d06relay13.portsmouth.uk.ibm.com [9.149.109.198])
        by ppma04ams.nl.ibm.com with ESMTP id 378n18jp09-1
        (version=TLSv1.2 cipher=ECDHE-RSA-AES256-GCM-SHA384 bits=256
 verify=NOT);
        Tue, 16 Mar 2021 09:20:03 +0000
Received: from d06av22.portsmouth.uk.ibm.com (d06av22.portsmouth.uk.ibm.com
 [9.149.105.58])
        by b06cxnps4076.portsmouth.uk.ibm.com (8.14.9/8.14.9/NCO v10.0) with
 ESMTP id 12G9K19d36503824
        (version=TLSv1/SSLv3 cipher=DHE-RSA-AES256-GCM-SHA384 bits=256
 verify=OK);
        Tue, 16 Mar 2021 09:20:01 GMT
Received: from d06av22.portsmouth.uk.ibm.com (unknown [127.0.0.1])
        by IMSVA (Postfix) with ESMTP id B23E14C052;
        Tue, 16 Mar 2021 09:20:01 +0000 (GMT)
Received: from d06av22.portsmouth.uk.ibm.com (unknown [127.0.0.1])
        by IMSVA (Postfix) with ESMTP id 7C03C4C046;
        Tue, 16 Mar 2021 09:20:00 +0000 (GMT)
Received: from localhost.localdomain (unknown [9.145.146.129])
        by d06av22.portsmouth.uk.ibm.com (Postfix) with ESMTP;
        Tue, 16 Mar 2021 09:20:00 +0000 (GMT)
From: Janosch Frank <frankja@linux.ibm.com>
To: kvm@vger.kernel.org
Cc: linux-s390@vger.kernel.org, thuth@redhat.com, david@redhat.com,
        imbrenda@linux.ibm.com
Subject: [kvm-unit-tests PATCH 2/6] s390x: Add more Ultravisor command
 structure definitions
Date: Tue, 16 Mar 2021 09:16:50 +0000
Message-Id: <20210316091654.1646-3-frankja@linux.ibm.com>
X-Mailer: git-send-email 2.27.0
In-Reply-To: <20210316091654.1646-1-frankja@linux.ibm.com>
References: <20210316091654.1646-1-frankja@linux.ibm.com>
MIME-Version: 1.0
X-TM-AS-GCONF: 00
X-Proofpoint-Virus-Version: vendor=fsecure engine=2.50.10434:6.0.369,18.0.761
 definitions=2021-03-16_03:2021-03-15,2021-03-16 signatures=0
X-Proofpoint-Spam-Details: rule=outbound_notspam policy=outbound score=0
 lowpriorityscore=0
 bulkscore=0 suspectscore=0 impostorscore=0 clxscore=1015 spamscore=0
 mlxlogscore=999 malwarescore=0 phishscore=0 adultscore=0
 priorityscore=1501 mlxscore=0 classifier=spam adjust=0 reason=mlx
 scancount=1 engine=8.12.0-2009150000 definitions=main-2103160063
Precedence: bulk
List-ID: <kvm.vger.kernel.org>
X-Mailing-List: kvm@vger.kernel.org

They are needed in the new UV tests.

As we now extend the size of the query struct, we need to set the
length in the UV guest query test to a constant instead of using
sizeof.

Signed-off-by: Janosch Frank <frankja@linux.ibm.com>
---
 lib/s390x/asm/uv.h | 148 ++++++++++++++++++++++++++++++++++++++++++++-
 s390x/uv-guest.c   |   2 +-
 2 files changed, 148 insertions(+), 2 deletions(-)

diff --git a/lib/s390x/asm/uv.h b/lib/s390x/asm/uv.h
index 9c491844..11f70a9f 100644
--- a/lib/s390x/asm/uv.h
+++ b/lib/s390x/asm/uv.h
@@ -17,16 +17,54 @@
 #define UVC_RC_INV_STATE	0x0003
 #define UVC_RC_INV_LEN		0x0005
 #define UVC_RC_NO_RESUME	0x0007
+#define UVC_RC_INV_GHANDLE	0x0020
+#define UVC_RC_INV_CHANDLE	0x0021
 
 #define UVC_CMD_QUI			0x0001
+#define UVC_CMD_INIT_UV			0x000f
+#define UVC_CMD_CREATE_SEC_CONF		0x0100
+#define UVC_CMD_DESTROY_SEC_CONF	0x0101
+#define UVC_CMD_CREATE_SEC_CPU		0x0120
+#define UVC_CMD_DESTROY_SEC_CPU		0x0121
+#define UVC_CMD_CONV_TO_SEC_STOR	0x0200
+#define UVC_CMD_CONV_FROM_SEC_STOR	0x0201
+#define UVC_CMD_SET_SEC_CONF_PARAMS	0x0300
+#define UVC_CMD_UNPACK_IMG		0x0301
+#define UVC_CMD_VERIFY_IMG		0x0302
+#define UVC_CMD_CPU_RESET		0x0310
+#define UVC_CMD_CPU_RESET_INITIAL	0x0311
+#define UVC_CMD_PERF_CONF_CLEAR_RESET	0x0320
+#define UVC_CMD_CPU_RESET_CLEAR		0x0321
+#define UVC_CMD_CPU_SET_STATE		0x0330
+#define UVC_CMD_SET_UNSHARED_ALL	0x0340
+#define UVC_CMD_PIN_PAGE_SHARED		0x0341
+#define UVC_CMD_UNPIN_PAGE_SHARED	0x0342
 #define UVC_CMD_SET_SHARED_ACCESS	0x1000
 #define UVC_CMD_REMOVE_SHARED_ACCESS	0x1001
 
 /* Bits in installed uv calls */
 enum uv_cmds_inst {
 	BIT_UVC_CMD_QUI = 0,
+	BIT_UVC_CMD_INIT_UV = 1,
+	BIT_UVC_CMD_CREATE_SEC_CONF = 2,
+	BIT_UVC_CMD_DESTROY_SEC_CONF = 3,
+	BIT_UVC_CMD_CREATE_SEC_CPU = 4,
+	BIT_UVC_CMD_DESTROY_SEC_CPU = 5,
+	BIT_UVC_CMD_CONV_TO_SEC_STOR = 6,
+	BIT_UVC_CMD_CONV_FROM_SEC_STOR = 7,
 	BIT_UVC_CMD_SET_SHARED_ACCESS = 8,
 	BIT_UVC_CMD_REMOVE_SHARED_ACCESS = 9,
+	BIT_UVC_CMD_SET_SEC_PARMS = 11,
+	BIT_UVC_CMD_UNPACK_IMG = 13,
+	BIT_UVC_CMD_VERIFY_IMG = 14,
+	BIT_UVC_CMD_CPU_RESET = 15,
+	BIT_UVC_CMD_CPU_RESET_INITIAL = 16,
+	BIT_UVC_CMD_CPU_SET_STATE = 17,
+	BIT_UVC_CMD_PREPARE_CLEAR_RESET = 18,
+	BIT_UVC_CMD_CPU_PERFORM_CLEAR_RESET = 19,
+	BIT_UVC_CMD_UNSHARE_ALL = 20,
+	BIT_UVC_CMD_PIN_PAGE_SHARED = 21,
+	BIT_UVC_CMD_UNPIN_PAGE_SHARED = 22,
 };
 
 struct uv_cb_header {
@@ -36,13 +74,81 @@ struct uv_cb_header {
 	u16 rrc;	/* Return Reason Code */
 } __attribute__((packed))  __attribute__((aligned(8)));
 
+struct uv_cb_init {
+	struct uv_cb_header header;
+	u64 reserved08[2];
+	u64 stor_origin;
+	u64 stor_len;
+	u64 reserved28[4];
+
+} __attribute__((packed))  __attribute__((aligned(8)));
+
 struct uv_cb_qui {
 	struct uv_cb_header header;
 	u64 reserved08;
 	u64 inst_calls_list[4];
-	u64 reserved30[15];
+	u64 reserved30[2];
+	u64 uv_base_stor_len;
+	u64 reserved48;
+	u64 conf_base_phys_stor_len;
+	u64 conf_base_virt_stor_len;
+	u64 conf_virt_var_stor_len;
+	u64 cpu_stor_len;
+	u32 reserved70[3];
+	u32 max_num_sec_conf;
+	u64 max_guest_stor_addr;
+	u8  reserved88[158 - 136];
+	u16 max_guest_cpus;
+	u8  reserveda0[200 - 160];
+}  __attribute__((packed))  __attribute__((aligned(8)));
+
+struct uv_cb_cgc {
+	struct uv_cb_header header;
+	u64 reserved08[2];
+	u64 guest_handle;
+	u64 conf_base_stor_origin;
+	u64 conf_var_stor_origin;
+	u64 reserved30;
+	u64 guest_stor_origin;
+	u64 guest_stor_len;
+	u64 guest_sca;
+	u64 guest_asce;
+	u64 reserved60[5];
 } __attribute__((packed))  __attribute__((aligned(8)));
 
+struct uv_cb_csc {
+	struct uv_cb_header header;
+	u64 reserved08[2];
+	u64 cpu_handle;
+	u64 guest_handle;
+	u64 stor_origin;
+	u8  reserved30[6];
+	u16 num;
+	u64 state_origin;
+	u64 reserved[4];
+} __attribute__((packed))  __attribute__((aligned(8)));
+
+struct uv_cb_unp {
+	struct uv_cb_header header;
+	u64 reserved08[2];
+	u64 guest_handle;
+	u64 gaddr;
+	u64 tweak[2];
+	u64 reserved38[3];
+} __attribute__((packed))  __attribute__((aligned(8)));
+
+/*
+ * A common UV call struct for the following calls:
+ * Destroy cpu/config
+ * Verify
+ */
+struct uv_cb_nodata {
+	struct uv_cb_header header;
+	u64 reserved08[2];
+	u64 handle;
+	u64 reserved20[4];
+}  __attribute__((packed))  __attribute__((aligned(8)));
+
 struct uv_cb_share {
 	struct uv_cb_header header;
 	u64 reserved08[3];
@@ -50,6 +156,32 @@ struct uv_cb_share {
 	u64 reserved28;
 } __attribute__((packed))  __attribute__((aligned(8)));
 
+/* Convert to Secure */
+struct uv_cb_cts {
+	struct uv_cb_header header;
+	u64 reserved08[2];
+	u64 guest_handle;
+	u64 gaddr;
+}  __attribute__((packed))  __attribute__((aligned(8)));
+
+/* Convert from Secure / Pin Page Shared */
+struct uv_cb_cfs {
+	struct uv_cb_header header;
+	u64 reserved08[2];
+	u64 paddr;
+}  __attribute__((packed))  __attribute__((aligned(8)));
+
+/* Set Secure Config Parameter */
+struct uv_cb_ssc {
+	struct uv_cb_header header;
+	u64 reserved08[2];
+	u64 guest_handle;
+	u64 sec_header_origin;
+	u32 sec_header_len;
+	u32 reserved2c;
+	u64 reserved30[4];
+} __attribute__((packed))  __attribute__((aligned(8)));
+
 static inline int uv_call_once(unsigned long r1, unsigned long r2)
 {
 	int cc;
@@ -118,4 +250,18 @@ static inline int uv_remove_shared(unsigned long addr)
 	return share(addr, UVC_CMD_REMOVE_SHARED_ACCESS);
 }
 
+struct uv_cb_cpu_set_state {
+	struct uv_cb_header header;
+	u64 reserved08[2];
+	u64 cpu_handle;
+	u8  reserved20[7];
+	u8  state;
+	u64 reserved28[5];
+};
+
+#define PV_CPU_STATE_OPR	1
+#define PV_CPU_STATE_STP	2
+#define PV_CPU_STATE_CHKSTP	3
+#define PV_CPU_STATE_OPR_LOAD	5
+
 #endif
diff --git a/s390x/uv-guest.c b/s390x/uv-guest.c
index a13669ab..95a968c5 100644
--- a/s390x/uv-guest.c
+++ b/s390x/uv-guest.c
@@ -59,7 +59,7 @@ static void test_query(void)
 {
 	struct uv_cb_qui uvcb = {
 		.header.cmd = UVC_CMD_QUI,
-		.header.len = sizeof(uvcb) - 8,
+		.header.len = 0xa0,
 	};
 	int cc;
 

From patchwork Tue Mar 16 09:16:51 2021
Content-Type: text/plain; charset="utf-8"
MIME-Version: 1.0
Content-Transfer-Encoding: 7bit
X-Patchwork-Submitter: Janosch Frank <frankja@linux.ibm.com>
X-Patchwork-Id: 12141517
Return-Path: <kvm-owner@kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-16.8 required=3.0 tests=BAYES_00,DKIM_SIGNED,
	DKIM_VALID,HEADER_FROM_DIFFERENT_DOMAINS,INCLUDES_CR_TRAILER,INCLUDES_PATCH,
	MAILING_LIST_MULTI,SPF_HELO_NONE,SPF_PASS,USER_AGENT_GIT
	autolearn=unavailable autolearn_force=no version=3.4.0
Received: from mail.kernel.org (mail.kernel.org [198.145.29.99])
	by smtp.lore.kernel.org (Postfix) with ESMTP id 0C558C43603
	for <kvm@archiver.kernel.org>; Tue, 16 Mar 2021 09:20:53 +0000 (UTC)
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by mail.kernel.org (Postfix) with ESMTP id BA42F65026
	for <kvm@archiver.kernel.org>; Tue, 16 Mar 2021 09:20:52 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S236000AbhCPJU3 (ORCPT <rfc822;kvm@archiver.kernel.org>);
        Tue, 16 Mar 2021 05:20:29 -0400
Received: from mx0a-001b2d01.pphosted.com ([148.163.156.1]:64926 "EHLO
        mx0a-001b2d01.pphosted.com" rhost-flags-OK-OK-OK-OK)
        by vger.kernel.org with ESMTP id S235957AbhCPJUJ (ORCPT
        <rfc822;kvm@vger.kernel.org>); Tue, 16 Mar 2021 05:20:09 -0400
Received: from pps.filterd (m0098396.ppops.net [127.0.0.1])
        by mx0a-001b2d01.pphosted.com (8.16.0.43/8.16.0.43) with SMTP id
 12G93IS9151572;
        Tue, 16 Mar 2021 05:20:09 -0400
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=ibm.com;
 h=from : to : cc : subject
 : date : message-id : in-reply-to : references : mime-version :
 content-transfer-encoding; s=pp1;
 bh=678KBbXoglLoDeDFPqBKjxG2s6voD4yWt6F6ZFdYV7I=;
 b=ClgoeYoy5NLFfd4r/SzClbRC5zQ0okf/kgkyYHyfFJR8SHPq/yzhPWvBY/TlZJgNf3fh
 xKJQQzaPMvMwtj9KrnhsxsUrLHR1PV+C2eLxD6KCtgkG38My3BmMziJRsHAkMKPBpIon
 iblH2aegtmhHOjPGD7W1g8uYVv5Dd5lgutmxWq2zBUkg4mtmPSXhfk4D2dwAN/hp8PIj
 500CEFCmeov9DqZrqq0D//xY6/x6d7LR3fYyd947+I++Y7lECEBtdRminH/nS5aN4fX9
 lhSyqpDiI/wmqhTisRHDJO4vWdbAQgpMNmKFqQ5pgCEoMv2OzDmJHVVMXohM6UsjNkqy EQ==
Received: from pps.reinject (localhost [127.0.0.1])
        by mx0a-001b2d01.pphosted.com with ESMTP id 37arn9j99q-1
        (version=TLSv1.2 cipher=ECDHE-RSA-AES256-GCM-SHA384 bits=256
 verify=NOT);
        Tue, 16 Mar 2021 05:20:09 -0400
Received: from m0098396.ppops.net (m0098396.ppops.net [127.0.0.1])
        by pps.reinject (8.16.0.43/8.16.0.43) with SMTP id 12G93Vhu154833;
        Tue, 16 Mar 2021 05:20:09 -0400
Received: from ppma04ams.nl.ibm.com (63.31.33a9.ip4.static.sl-reverse.com
 [169.51.49.99])
        by mx0a-001b2d01.pphosted.com with ESMTP id 37arn9j98c-1
        (version=TLSv1.2 cipher=ECDHE-RSA-AES256-GCM-SHA384 bits=256
 verify=NOT);
        Tue, 16 Mar 2021 05:20:09 -0400
Received: from pps.filterd (ppma04ams.nl.ibm.com [127.0.0.1])
        by ppma04ams.nl.ibm.com (8.16.0.43/8.16.0.43) with SMTP id
 12G9D4RM016874;
        Tue, 16 Mar 2021 09:20:07 GMT
Received: from b06avi18626390.portsmouth.uk.ibm.com
 (b06avi18626390.portsmouth.uk.ibm.com [9.149.26.192])
        by ppma04ams.nl.ibm.com with ESMTP id 378n18jp0b-1
        (version=TLSv1.2 cipher=ECDHE-RSA-AES256-GCM-SHA384 bits=256
 verify=NOT);
        Tue, 16 Mar 2021 09:20:06 +0000
Received: from d06av22.portsmouth.uk.ibm.com (d06av22.portsmouth.uk.ibm.com
 [9.149.105.58])
        by b06avi18626390.portsmouth.uk.ibm.com (8.14.9/8.14.9/NCO v10.0) with
 ESMTP id 12G9JlQk20054340
        (version=TLSv1/SSLv3 cipher=DHE-RSA-AES256-GCM-SHA384 bits=256
 verify=OK);
        Tue, 16 Mar 2021 09:19:47 GMT
Received: from d06av22.portsmouth.uk.ibm.com (unknown [127.0.0.1])
        by IMSVA (Postfix) with ESMTP id 6A6D34C063;
        Tue, 16 Mar 2021 09:20:03 +0000 (GMT)
Received: from d06av22.portsmouth.uk.ibm.com (unknown [127.0.0.1])
        by IMSVA (Postfix) with ESMTP id 13B0B4C046;
        Tue, 16 Mar 2021 09:20:02 +0000 (GMT)
Received: from localhost.localdomain (unknown [9.145.146.129])
        by d06av22.portsmouth.uk.ibm.com (Postfix) with ESMTP;
        Tue, 16 Mar 2021 09:20:01 +0000 (GMT)
From: Janosch Frank <frankja@linux.ibm.com>
To: kvm@vger.kernel.org
Cc: linux-s390@vger.kernel.org, thuth@redhat.com, david@redhat.com,
        imbrenda@linux.ibm.com
Subject: [kvm-unit-tests PATCH 3/6] s390x: uv: Add UV lib
Date: Tue, 16 Mar 2021 09:16:51 +0000
Message-Id: <20210316091654.1646-4-frankja@linux.ibm.com>
X-Mailer: git-send-email 2.27.0
In-Reply-To: <20210316091654.1646-1-frankja@linux.ibm.com>
References: <20210316091654.1646-1-frankja@linux.ibm.com>
MIME-Version: 1.0
X-TM-AS-GCONF: 00
X-Proofpoint-Virus-Version: vendor=fsecure engine=2.50.10434:6.0.369,18.0.761
 definitions=2021-03-16_03:2021-03-15,2021-03-16 signatures=0
X-Proofpoint-Spam-Details: rule=outbound_notspam policy=outbound score=0
 spamscore=0 mlxscore=0
 malwarescore=0 priorityscore=1501 mlxlogscore=999 suspectscore=0
 clxscore=1015 impostorscore=0 lowpriorityscore=0 bulkscore=0 adultscore=0
 phishscore=0 classifier=spam adjust=0 reason=mlx scancount=1
 engine=8.12.0-2009150000 definitions=main-2103160063
Precedence: bulk
List-ID: <kvm.vger.kernel.org>
X-Mailing-List: kvm@vger.kernel.org

Let's add a UV library to make checking the UV feature bit easier.
In the future this library file can take care of handling UV
initialization and UV guest creation.

Signed-off-by: Janosch Frank <frankja@linux.ibm.com>
---
 lib/s390x/asm/uv.h |  4 ++--
 lib/s390x/io.c     |  2 ++
 lib/s390x/uv.c     | 48 ++++++++++++++++++++++++++++++++++++++++++++++
 lib/s390x/uv.h     | 10 ++++++++++
 s390x/Makefile     |  1 +
 5 files changed, 63 insertions(+), 2 deletions(-)
 create mode 100644 lib/s390x/uv.c
 create mode 100644 lib/s390x/uv.h

diff --git a/lib/s390x/asm/uv.h b/lib/s390x/asm/uv.h
index 11f70a9f..b22cbaa8 100644
--- a/lib/s390x/asm/uv.h
+++ b/lib/s390x/asm/uv.h
@@ -9,8 +9,8 @@
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2.
  */
-#ifndef UV_H
-#define UV_H
+#ifndef ASM_S390X_UV_H
+#define ASM_S390X_UV_H
 
 #define UVC_RC_EXECUTED		0x0001
 #define UVC_RC_INV_CMD		0x0002
diff --git a/lib/s390x/io.c b/lib/s390x/io.c
index ef9f59e3..a4f1b113 100644
--- a/lib/s390x/io.c
+++ b/lib/s390x/io.c
@@ -14,6 +14,7 @@
 #include <asm/facility.h>
 #include <asm/sigp.h>
 #include "sclp.h"
+#include "uv.h"
 #include "smp.h"
 
 extern char ipl_args[];
@@ -38,6 +39,7 @@ void setup(void)
 	sclp_facilities_setup();
 	sclp_console_setup();
 	sclp_memory_setup();
+	uv_setup();
 	smp_setup();
 }
 
diff --git a/lib/s390x/uv.c b/lib/s390x/uv.c
new file mode 100644
index 00000000..a84a85fc
--- /dev/null
+++ b/lib/s390x/uv.c
@@ -0,0 +1,48 @@
+#include <libcflat.h>
+#include <bitops.h>
+#include <alloc.h>
+#include <alloc_page.h>
+#include <asm/page.h>
+#include <asm/arch_def.h>
+
+#include <asm/facility.h>
+#include <asm/uv.h>
+#include <uv.h>
+
+static struct uv_cb_qui uvcb_qui = {
+	.header.cmd = UVC_CMD_QUI,
+	.header.len = sizeof(uvcb_qui),
+};
+
+bool uv_os_is_guest(void)
+{
+	return uv_query_test_feature(BIT_UVC_CMD_SET_SHARED_ACCESS)
+		&& uv_query_test_feature(BIT_UVC_CMD_REMOVE_SHARED_ACCESS);
+}
+
+bool uv_os_is_host(void)
+{
+	return uv_query_test_feature(BIT_UVC_CMD_INIT_UV);
+}
+
+bool uv_query_test_feature(int nr)
+{
+	/* Query needs to be called first */
+	if (!uvcb_qui.header.rc)
+		return false;
+
+	return test_bit_inv(nr, uvcb_qui.inst_calls_list);
+}
+
+int uv_setup(void)
+{
+	int cc;
+
+	if (!test_facility(158))
+		return 0;
+
+	cc = uv_call(0, (u64)&uvcb_qui);
+	assert(cc == 0);
+
+	return cc == 0;
+}
diff --git a/lib/s390x/uv.h b/lib/s390x/uv.h
new file mode 100644
index 00000000..159bf8e5
--- /dev/null
+++ b/lib/s390x/uv.h
@@ -0,0 +1,10 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+#ifndef UV_H
+#define UV_H
+
+bool uv_os_is_guest(void);
+bool uv_os_is_host(void);
+bool uv_query_test_feature(int nr);
+int uv_setup(void);
+
+#endif /* UV_H */
diff --git a/s390x/Makefile b/s390x/Makefile
index b92de9c5..bbf177fa 100644
--- a/s390x/Makefile
+++ b/s390x/Makefile
@@ -67,6 +67,7 @@ cflatobjs += lib/s390x/vm.o
 cflatobjs += lib/s390x/css_dump.o
 cflatobjs += lib/s390x/css_lib.o
 cflatobjs += lib/s390x/malloc_io.o
+cflatobjs += lib/s390x/uv.o
 
 OBJDIRS += lib/s390x
 

From patchwork Tue Mar 16 09:16:52 2021
Content-Type: text/plain; charset="utf-8"
MIME-Version: 1.0
Content-Transfer-Encoding: 7bit
X-Patchwork-Submitter: Janosch Frank <frankja@linux.ibm.com>
X-Patchwork-Id: 12141515
Return-Path: <kvm-owner@kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-16.8 required=3.0 tests=BAYES_00,DKIM_SIGNED,
	DKIM_VALID,HEADER_FROM_DIFFERENT_DOMAINS,INCLUDES_CR_TRAILER,INCLUDES_PATCH,
	MAILING_LIST_MULTI,SPF_HELO_NONE,SPF_PASS,USER_AGENT_GIT
	autolearn=unavailable autolearn_force=no version=3.4.0
Received: from mail.kernel.org (mail.kernel.org [198.145.29.99])
	by smtp.lore.kernel.org (Postfix) with ESMTP id 4CA7FC43619
	for <kvm@archiver.kernel.org>; Tue, 16 Mar 2021 09:20:53 +0000 (UTC)
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by mail.kernel.org (Postfix) with ESMTP id 2B9AC6500F
	for <kvm@archiver.kernel.org>; Tue, 16 Mar 2021 09:20:53 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S236005AbhCPJU3 (ORCPT <rfc822;kvm@archiver.kernel.org>);
        Tue, 16 Mar 2021 05:20:29 -0400
Received: from mx0b-001b2d01.pphosted.com ([148.163.158.5]:21070 "EHLO
        mx0b-001b2d01.pphosted.com" rhost-flags-OK-OK-OK-OK)
        by vger.kernel.org with ESMTP id S235958AbhCPJUK (ORCPT
        <rfc822;kvm@vger.kernel.org>); Tue, 16 Mar 2021 05:20:10 -0400
Received: from pps.filterd (m0098421.ppops.net [127.0.0.1])
        by mx0a-001b2d01.pphosted.com (8.16.0.43/8.16.0.43) with SMTP id
 12G94RQQ030236;
        Tue, 16 Mar 2021 05:20:09 -0400
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=ibm.com;
 h=from : to : cc : subject
 : date : message-id : in-reply-to : references : mime-version :
 content-transfer-encoding; s=pp1;
 bh=SssSl1wjs41a6BgcmEpj3X3SkkIta76MF1NJ44c4Iq0=;
 b=maWPYtEU/yWYpDXzWnauZZ3xdE/OAUdhH3RV58QFx0qRb3/qBaE30HGNeh7Hz0R/TPhm
 ETKJ3/c0VJt60LOMkY0pntCvBhvBIb9i2SauZ8eHHsSEPb5YDhj5APL3+EhuEsydhewS
 BsY2g/XO02qDNcGImYB0KLmUeRbhboLSmzt2eBr4/OzAfjRQ8p1QqprFVGjR6NZyvdiW
 oCygonRv1FIlgkwqAJo+JVVlgTkRmDyPx96frSJ5ddic6fd+ysBrRYa0h9ImzMB5UPPG
 6EGWBh1PXtMn0eNerg+4EGMpOs1rnwq2VyJYjx1uP9qznoR4EBVI+D+Iu8qaVDLfTroL iQ==
Received: from pps.reinject (localhost [127.0.0.1])
        by mx0a-001b2d01.pphosted.com with ESMTP id 37ap2t6ae8-1
        (version=TLSv1.2 cipher=ECDHE-RSA-AES256-GCM-SHA384 bits=256
 verify=NOT);
        Tue, 16 Mar 2021 05:20:09 -0400
Received: from m0098421.ppops.net (m0098421.ppops.net [127.0.0.1])
        by pps.reinject (8.16.0.43/8.16.0.43) with SMTP id 12G952F0036085;
        Tue, 16 Mar 2021 05:20:09 -0400
Received: from ppma06ams.nl.ibm.com (66.31.33a9.ip4.static.sl-reverse.com
 [169.51.49.102])
        by mx0a-001b2d01.pphosted.com with ESMTP id 37ap2t6ad6-1
        (version=TLSv1.2 cipher=ECDHE-RSA-AES256-GCM-SHA384 bits=256
 verify=NOT);
        Tue, 16 Mar 2021 05:20:09 -0400
Received: from pps.filterd (ppma06ams.nl.ibm.com [127.0.0.1])
        by ppma06ams.nl.ibm.com (8.16.0.43/8.16.0.43) with SMTP id
 12G9C2Wx005478;
        Tue, 16 Mar 2021 09:20:07 GMT
Received: from b06cxnps3075.portsmouth.uk.ibm.com
 (d06relay10.portsmouth.uk.ibm.com [9.149.109.195])
        by ppma06ams.nl.ibm.com with ESMTP id 378mnh2pg1-1
        (version=TLSv1.2 cipher=ECDHE-RSA-AES256-GCM-SHA384 bits=256
 verify=NOT);
        Tue, 16 Mar 2021 09:20:07 +0000
Received: from d06av22.portsmouth.uk.ibm.com (d06av22.portsmouth.uk.ibm.com
 [9.149.105.58])
        by b06cxnps3075.portsmouth.uk.ibm.com (8.14.9/8.14.9/NCO v10.0) with
 ESMTP id 12G9K5Dq46596528
        (version=TLSv1/SSLv3 cipher=DHE-RSA-AES256-GCM-SHA384 bits=256
 verify=OK);
        Tue, 16 Mar 2021 09:20:05 GMT
Received: from d06av22.portsmouth.uk.ibm.com (unknown [127.0.0.1])
        by IMSVA (Postfix) with ESMTP id DCBE74C052;
        Tue, 16 Mar 2021 09:20:04 +0000 (GMT)
Received: from d06av22.portsmouth.uk.ibm.com (unknown [127.0.0.1])
        by IMSVA (Postfix) with ESMTP id BD17D4C06A;
        Tue, 16 Mar 2021 09:20:03 +0000 (GMT)
Received: from localhost.localdomain (unknown [9.145.146.129])
        by d06av22.portsmouth.uk.ibm.com (Postfix) with ESMTP;
        Tue, 16 Mar 2021 09:20:03 +0000 (GMT)
From: Janosch Frank <frankja@linux.ibm.com>
To: kvm@vger.kernel.org
Cc: linux-s390@vger.kernel.org, thuth@redhat.com, david@redhat.com,
        imbrenda@linux.ibm.com
Subject: [kvm-unit-tests PATCH 4/6] s390x: Test for share/unshare call support
 before using them
Date: Tue, 16 Mar 2021 09:16:52 +0000
Message-Id: <20210316091654.1646-5-frankja@linux.ibm.com>
X-Mailer: git-send-email 2.27.0
In-Reply-To: <20210316091654.1646-1-frankja@linux.ibm.com>
References: <20210316091654.1646-1-frankja@linux.ibm.com>
MIME-Version: 1.0
X-TM-AS-GCONF: 00
X-Proofpoint-Virus-Version: vendor=fsecure engine=2.50.10434:6.0.369,18.0.761
 definitions=2021-03-16_03:2021-03-15,2021-03-16 signatures=0
X-Proofpoint-Spam-Details: rule=outbound_notspam policy=outbound score=0
 malwarescore=0
 mlxlogscore=999 lowpriorityscore=0 adultscore=0 suspectscore=0
 priorityscore=1501 spamscore=0 mlxscore=0 phishscore=0 clxscore=1015
 impostorscore=0 bulkscore=0 classifier=spam adjust=0 reason=mlx
 scancount=1 engine=8.12.0-2009150000 definitions=main-2103160063
Precedence: bulk
List-ID: <kvm.vger.kernel.org>
X-Mailing-List: kvm@vger.kernel.org

Testing for facility only means the UV Call facility is available.
The UV will only indicate the share/unshare calls for a protected
guest 2, so let's also check that.

Signed-off-by: Janosch Frank <frankja@linux.ibm.com>
---
 lib/s390x/malloc_io.c | 5 +++--
 s390x/uv-guest.c      | 6 ++++++
 2 files changed, 9 insertions(+), 2 deletions(-)

diff --git a/lib/s390x/malloc_io.c b/lib/s390x/malloc_io.c
index 1dcf1691..78582eac 100644
--- a/lib/s390x/malloc_io.c
+++ b/lib/s390x/malloc_io.c
@@ -19,6 +19,7 @@
 #include <alloc_page.h>
 #include <asm/facility.h>
 #include <bitops.h>
+#include <uv.h>
 
 static int share_pages(void *p, int count)
 {
@@ -47,7 +48,7 @@ void *alloc_io_mem(int size, int flags)
 	assert(size);
 
 	p = alloc_pages_flags(order, AREA_DMA31 | flags);
-	if (!p || !test_facility(158))
+	if (!p || !uv_os_is_guest())
 		return p;
 
 	n = share_pages(p, 1 << order);
@@ -65,7 +66,7 @@ void free_io_mem(void *p, int size)
 
 	assert(IS_ALIGNED((uintptr_t)p, PAGE_SIZE));
 
-	if (test_facility(158))
+	if (uv_os_is_guest())
 		unshare_pages(p, 1 << order);
 	free_pages(p);
 }
diff --git a/s390x/uv-guest.c b/s390x/uv-guest.c
index 95a968c5..8915b2f1 100644
--- a/s390x/uv-guest.c
+++ b/s390x/uv-guest.c
@@ -16,6 +16,7 @@
 #include <asm/facility.h>
 #include <asm/uv.h>
 #include <sclp.h>
+#include <uv.h>
 
 static unsigned long page;
 
@@ -141,6 +142,11 @@ int main(void)
 		goto done;
 	}
 
+	if (!uv_os_is_guest()) {
+		report_skip("Not a protected guest");
+		goto done;
+	}
+
 	page = (unsigned long)alloc_page();
 	test_priv();
 	test_invalid();

From patchwork Tue Mar 16 09:16:53 2021
Content-Type: text/plain; charset="utf-8"
MIME-Version: 1.0
Content-Transfer-Encoding: 7bit
X-Patchwork-Submitter: Janosch Frank <frankja@linux.ibm.com>
X-Patchwork-Id: 12141519
Return-Path: <kvm-owner@kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-14.0 required=3.0 tests=BAYES_00,DKIM_SIGNED,
	DKIM_VALID,HEADER_FROM_DIFFERENT_DOMAINS,INCLUDES_CR_TRAILER,INCLUDES_PATCH,
	MAILING_LIST_MULTI,SPF_HELO_NONE,SPF_PASS,UNWANTED_LANGUAGE_BODY,
	USER_AGENT_GIT autolearn=unavailable autolearn_force=no version=3.4.0
Received: from mail.kernel.org (mail.kernel.org [198.145.29.99])
	by smtp.lore.kernel.org (Postfix) with ESMTP id 30073C4361A
	for <kvm@archiver.kernel.org>; Tue, 16 Mar 2021 09:20:53 +0000 (UTC)
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by mail.kernel.org (Postfix) with ESMTP id 0D3E46500D
	for <kvm@archiver.kernel.org>; Tue, 16 Mar 2021 09:20:53 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S236009AbhCPJUa (ORCPT <rfc822;kvm@archiver.kernel.org>);
        Tue, 16 Mar 2021 05:20:30 -0400
Received: from mx0b-001b2d01.pphosted.com ([148.163.158.5]:4746 "EHLO
        mx0a-001b2d01.pphosted.com" rhost-flags-OK-OK-OK-FAIL)
        by vger.kernel.org with ESMTP id S235959AbhCPJUM (ORCPT
        <rfc822;kvm@vger.kernel.org>); Tue, 16 Mar 2021 05:20:12 -0400
Received: from pps.filterd (m0098413.ppops.net [127.0.0.1])
        by mx0b-001b2d01.pphosted.com (8.16.0.43/8.16.0.43) with SMTP id
 12G95Bxe097874;
        Tue, 16 Mar 2021 05:20:11 -0400
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=ibm.com;
 h=from : to : cc : subject
 : date : message-id : in-reply-to : references : mime-version :
 content-transfer-encoding; s=pp1;
 bh=wsP2ILw6mQ9QxIkV5PY3vW/1ExFI16X2vTFM7Z2Skj8=;
 b=qyi9jUVz5bJHErI86FLh7r16Nrmf8tSqW0kwVK+Mc8Y6ogQfaAA30YgMQHwmY9o+MW+4
 jCwMHfwyXQ91Zta+SIEckkXVvVXKiPr/77NtUbdTQ1uEJO7FYzjZjtG/NQCytqqPnxTO
 aFGE8bk+YFJjCVTdsU4tLrDhEY/81R+D2e747z//bWIrk3c6zCGI4JzSYipId8DXqRpB
 25GfctAIe8yZUQBTRhkA1sTlyzgZ00tCOo5L2XWRdZE/S9eqpiTvRAszCce3Gj9z5xa0
 GW57EShv5rL18J8Z5qiUw9Ldak9S5YqfHg12Ax3Tp7IosFgg71yKABgHu9u89Q4MCi1z FQ==
Received: from pps.reinject (localhost [127.0.0.1])
        by mx0b-001b2d01.pphosted.com with ESMTP id 37ap24x74p-1
        (version=TLSv1.2 cipher=ECDHE-RSA-AES256-GCM-SHA384 bits=256
 verify=NOT);
        Tue, 16 Mar 2021 05:20:11 -0400
Received: from m0098413.ppops.net (m0098413.ppops.net [127.0.0.1])
        by pps.reinject (8.16.0.43/8.16.0.43) with SMTP id 12G95Vbl099469;
        Tue, 16 Mar 2021 05:20:11 -0400
Received: from ppma03ams.nl.ibm.com (62.31.33a9.ip4.static.sl-reverse.com
 [169.51.49.98])
        by mx0b-001b2d01.pphosted.com with ESMTP id 37ap24x73s-1
        (version=TLSv1.2 cipher=ECDHE-RSA-AES256-GCM-SHA384 bits=256
 verify=NOT);
        Tue, 16 Mar 2021 05:20:11 -0400
Received: from pps.filterd (ppma03ams.nl.ibm.com [127.0.0.1])
        by ppma03ams.nl.ibm.com (8.16.0.43/8.16.0.43) with SMTP id
 12G9CBVd020014;
        Tue, 16 Mar 2021 09:20:09 GMT
Received: from b06cxnps4075.portsmouth.uk.ibm.com
 (d06relay12.portsmouth.uk.ibm.com [9.149.109.197])
        by ppma03ams.nl.ibm.com with ESMTP id 378n18jnrw-1
        (version=TLSv1.2 cipher=ECDHE-RSA-AES256-GCM-SHA384 bits=256
 verify=NOT);
        Tue, 16 Mar 2021 09:20:09 +0000
Received: from d06av22.portsmouth.uk.ibm.com (d06av22.portsmouth.uk.ibm.com
 [9.149.105.58])
        by b06cxnps4075.portsmouth.uk.ibm.com (8.14.9/8.14.9/NCO v10.0) with
 ESMTP id 12G9K7eV62914820
        (version=TLSv1/SSLv3 cipher=DHE-RSA-AES256-GCM-SHA384 bits=256
 verify=OK);
        Tue, 16 Mar 2021 09:20:07 GMT
Received: from d06av22.portsmouth.uk.ibm.com (unknown [127.0.0.1])
        by IMSVA (Postfix) with ESMTP id D9EA34C040;
        Tue, 16 Mar 2021 09:20:06 +0000 (GMT)
Received: from d06av22.portsmouth.uk.ibm.com (unknown [127.0.0.1])
        by IMSVA (Postfix) with ESMTP id 47A824C044;
        Tue, 16 Mar 2021 09:20:05 +0000 (GMT)
Received: from localhost.localdomain (unknown [9.145.146.129])
        by d06av22.portsmouth.uk.ibm.com (Postfix) with ESMTP;
        Tue, 16 Mar 2021 09:20:05 +0000 (GMT)
From: Janosch Frank <frankja@linux.ibm.com>
To: kvm@vger.kernel.org
Cc: linux-s390@vger.kernel.org, thuth@redhat.com, david@redhat.com,
        imbrenda@linux.ibm.com
Subject: [kvm-unit-tests PATCH 5/6] s390x: uv-guest: Test invalid commands
Date: Tue, 16 Mar 2021 09:16:53 +0000
Message-Id: <20210316091654.1646-6-frankja@linux.ibm.com>
X-Mailer: git-send-email 2.27.0
In-Reply-To: <20210316091654.1646-1-frankja@linux.ibm.com>
References: <20210316091654.1646-1-frankja@linux.ibm.com>
MIME-Version: 1.0
X-TM-AS-GCONF: 00
X-Proofpoint-Virus-Version: vendor=fsecure engine=2.50.10434:6.0.369,18.0.761
 definitions=2021-03-16_03:2021-03-15,2021-03-16 signatures=0
X-Proofpoint-Spam-Details: rule=outbound_notspam policy=outbound score=0
 adultscore=0
 priorityscore=1501 suspectscore=0 spamscore=0 lowpriorityscore=0
 malwarescore=0 impostorscore=0 phishscore=0 mlxscore=0 mlxlogscore=999
 clxscore=1015 bulkscore=0 classifier=spam adjust=0 reason=mlx scancount=1
 engine=8.12.0-2009150000 definitions=main-2103160063
Precedence: bulk
List-ID: <kvm.vger.kernel.org>
X-Mailing-List: kvm@vger.kernel.org

Let's check if the commands that are not indicated as available
produce a invalid command error.

Signed-off-by: Janosch Frank <frankja@linux.ibm.com>
---
 s390x/uv-guest.c | 44 +++++++++++++++++++++++++++++++++++++-------
 1 file changed, 37 insertions(+), 7 deletions(-)

diff --git a/s390x/uv-guest.c b/s390x/uv-guest.c
index 8915b2f1..517e3c66 100644
--- a/s390x/uv-guest.c
+++ b/s390x/uv-guest.c
@@ -120,16 +120,46 @@ static void test_sharing(void)
 	report_prefix_pop();
 }
 
+static struct {
+	const char *name;
+	uint16_t cmd;
+	uint16_t len;
+} invalid_cmds[] = {
+	{ "bogus", 0x4242, sizeof(struct uv_cb_header) },
+	{ "init", UVC_CMD_INIT_UV, sizeof(struct uv_cb_init) },
+	{ "create conf", UVC_CMD_CREATE_SEC_CONF, sizeof(struct uv_cb_cgc) },
+	{ "destroy conf", UVC_CMD_DESTROY_SEC_CONF, sizeof(struct uv_cb_nodata) },
+	{ "create cpu", UVC_CMD_CREATE_SEC_CPU, sizeof(struct uv_cb_csc) },
+	{ "destroy cpu", UVC_CMD_DESTROY_SEC_CPU, sizeof(struct uv_cb_nodata) },
+	{ "conv to", UVC_CMD_CONV_TO_SEC_STOR, sizeof(struct uv_cb_cts) },
+	{ "conv from", UVC_CMD_CONV_FROM_SEC_STOR, sizeof(struct uv_cb_cfs) },
+	{ "set sec conf", UVC_CMD_SET_SEC_CONF_PARAMS, sizeof(struct uv_cb_ssc) },
+	{ "unpack", UVC_CMD_UNPACK_IMG, sizeof(struct uv_cb_unp) },
+	{ "verify", UVC_CMD_VERIFY_IMG, sizeof(struct uv_cb_nodata) },
+	{ "cpu reset", UVC_CMD_CPU_RESET, sizeof(struct uv_cb_nodata) },
+	{ "cpu initial reset", UVC_CMD_CPU_RESET_INITIAL, sizeof(struct uv_cb_nodata) },
+	{ "conf clear reset", UVC_CMD_PERF_CONF_CLEAR_RESET, sizeof(struct uv_cb_nodata) },
+	{ "cpu clear reset", UVC_CMD_CPU_RESET_CLEAR, sizeof(struct uv_cb_nodata) },
+	{ "cpu set state", UVC_CMD_CPU_SET_STATE, sizeof(struct uv_cb_cpu_set_state) },
+	{ "pin shared", UVC_CMD_PIN_PAGE_SHARED, sizeof(struct uv_cb_cfs) },
+	{ "unpin shared", UVC_CMD_UNPIN_PAGE_SHARED, sizeof(struct uv_cb_cts) },
+	{ NULL, 0, 0 },
+};
+
 static void test_invalid(void)
 {
-	struct uv_cb_header uvcb = {
-		.len = 16,
-		.cmd = 0x4242,
-	};
-	int cc;
+	struct uv_cb_header *hdr = (void *)page;
+	int cc, i;
 
-	cc = uv_call(0, (u64)&uvcb);
-	report(cc == 1 && uvcb.rc == UVC_RC_INV_CMD, "invalid command");
+	report_prefix_push("invalid");
+	for (i = 0; invalid_cmds[i].name; i++) {
+		hdr->cmd = invalid_cmds[i].cmd;
+		hdr->len = invalid_cmds[i].len;
+		cc = uv_call(0, (u64)hdr);
+		report(cc == 1 && hdr->rc == UVC_RC_INV_CMD, "%s",
+		       invalid_cmds[i].name);
+	}
+	report_prefix_pop();
 }
 
 int main(void)

From patchwork Tue Mar 16 09:16:54 2021
Content-Type: text/plain; charset="utf-8"
MIME-Version: 1.0
Content-Transfer-Encoding: 7bit
X-Patchwork-Submitter: Janosch Frank <frankja@linux.ibm.com>
X-Patchwork-Id: 12141521
Return-Path: <kvm-owner@kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-16.8 required=3.0 tests=BAYES_00,DKIM_SIGNED,
	DKIM_VALID,HEADER_FROM_DIFFERENT_DOMAINS,INCLUDES_CR_TRAILER,INCLUDES_PATCH,
	MAILING_LIST_MULTI,SPF_HELO_NONE,SPF_PASS,USER_AGENT_GIT
	autolearn=unavailable autolearn_force=no version=3.4.0
Received: from mail.kernel.org (mail.kernel.org [198.145.29.99])
	by smtp.lore.kernel.org (Postfix) with ESMTP id 655E2C433E0
	for <kvm@archiver.kernel.org>; Tue, 16 Mar 2021 09:20:53 +0000 (UTC)
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by mail.kernel.org (Postfix) with ESMTP id 49E286500D
	for <kvm@archiver.kernel.org>; Tue, 16 Mar 2021 09:20:53 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S236011AbhCPJUa (ORCPT <rfc822;kvm@archiver.kernel.org>);
        Tue, 16 Mar 2021 05:20:30 -0400
Received: from mx0a-001b2d01.pphosted.com ([148.163.156.1]:30430 "EHLO
        mx0a-001b2d01.pphosted.com" rhost-flags-OK-OK-OK-OK)
        by vger.kernel.org with ESMTP id S235960AbhCPJUO (ORCPT
        <rfc822;kvm@vger.kernel.org>); Tue, 16 Mar 2021 05:20:14 -0400
Received: from pps.filterd (m0098393.ppops.net [127.0.0.1])
        by mx0a-001b2d01.pphosted.com (8.16.0.43/8.16.0.43) with SMTP id
 12G94Xia038020;
        Tue, 16 Mar 2021 05:20:14 -0400
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=ibm.com;
 h=from : to : cc : subject
 : date : message-id : in-reply-to : references : mime-version :
 content-transfer-encoding; s=pp1;
 bh=cycb7XFj1yuPEJamzq6o4ILKy1SLODtz6uMPpKE4GWo=;
 b=aElsGbHV5HRejO5ylzpx6Cf834KlDYr8PFaZpq4J0by51TdVa7IkP2xvfy3hbpmDk3e5
 KhyXmVNtxTmZaB/7wYEMq+GCZwerfyi1cA7buSo5kbwZKwkZ7wH8Nslw8cEkd9hb31go
 HcAB2t8WFYzYbcofy7Krca8XIGJn3nL8InAVPTg6Jp6mStvND0Ij2cf6CBDLYIOYFsHF
 KLFXbjklchEIl/Ws15iRtNXzrNvkKabzP1KhfAZUSYu5jGBeedVdUb0xYvBDyR0u+9Fy
 IL2m1Rbi4z8bS2AGsvAQgrkdamdcwn2oS/LcyQeCOFFMQv9xLvAJNSRLdlVaJJwXet0f qg==
Received: from pps.reinject (localhost [127.0.0.1])
        by mx0a-001b2d01.pphosted.com with ESMTP id 37abcxnp3s-1
        (version=TLSv1.2 cipher=ECDHE-RSA-AES256-GCM-SHA384 bits=256
 verify=NOT);
        Tue, 16 Mar 2021 05:20:14 -0400
Received: from m0098393.ppops.net (m0098393.ppops.net [127.0.0.1])
        by pps.reinject (8.16.0.43/8.16.0.43) with SMTP id 12G95LPf042652;
        Tue, 16 Mar 2021 05:20:14 -0400
Received: from ppma03ams.nl.ibm.com (62.31.33a9.ip4.static.sl-reverse.com
 [169.51.49.98])
        by mx0a-001b2d01.pphosted.com with ESMTP id 37abcxnp2j-1
        (version=TLSv1.2 cipher=ECDHE-RSA-AES256-GCM-SHA384 bits=256
 verify=NOT);
        Tue, 16 Mar 2021 05:20:13 -0400
Received: from pps.filterd (ppma03ams.nl.ibm.com [127.0.0.1])
        by ppma03ams.nl.ibm.com (8.16.0.43/8.16.0.43) with SMTP id
 12G9CAAU020011;
        Tue, 16 Mar 2021 09:20:11 GMT
Received: from b06cxnps4076.portsmouth.uk.ibm.com
 (d06relay13.portsmouth.uk.ibm.com [9.149.109.198])
        by ppma03ams.nl.ibm.com with ESMTP id 378n18jns0-1
        (version=TLSv1.2 cipher=ECDHE-RSA-AES256-GCM-SHA384 bits=256
 verify=NOT);
        Tue, 16 Mar 2021 09:20:11 +0000
Received: from d06av22.portsmouth.uk.ibm.com (d06av22.portsmouth.uk.ibm.com
 [9.149.105.58])
        by b06cxnps4076.portsmouth.uk.ibm.com (8.14.9/8.14.9/NCO v10.0) with
 ESMTP id 12G9K8VP24445216
        (version=TLSv1/SSLv3 cipher=DHE-RSA-AES256-GCM-SHA384 bits=256
 verify=OK);
        Tue, 16 Mar 2021 09:20:08 GMT
Received: from d06av22.portsmouth.uk.ibm.com (unknown [127.0.0.1])
        by IMSVA (Postfix) with ESMTP id AED334C046;
        Tue, 16 Mar 2021 09:20:08 +0000 (GMT)
Received: from d06av22.portsmouth.uk.ibm.com (unknown [127.0.0.1])
        by IMSVA (Postfix) with ESMTP id 44F014C04A;
        Tue, 16 Mar 2021 09:20:07 +0000 (GMT)
Received: from localhost.localdomain (unknown [9.145.146.129])
        by d06av22.portsmouth.uk.ibm.com (Postfix) with ESMTP;
        Tue, 16 Mar 2021 09:20:07 +0000 (GMT)
From: Janosch Frank <frankja@linux.ibm.com>
To: kvm@vger.kernel.org
Cc: linux-s390@vger.kernel.org, thuth@redhat.com, david@redhat.com,
        imbrenda@linux.ibm.com
Subject: [kvm-unit-tests PATCH 6/6] s390x: Add UV host test
Date: Tue, 16 Mar 2021 09:16:54 +0000
Message-Id: <20210316091654.1646-7-frankja@linux.ibm.com>
X-Mailer: git-send-email 2.27.0
In-Reply-To: <20210316091654.1646-1-frankja@linux.ibm.com>
References: <20210316091654.1646-1-frankja@linux.ibm.com>
MIME-Version: 1.0
X-TM-AS-GCONF: 00
X-Proofpoint-Virus-Version: vendor=fsecure engine=2.50.10434:6.0.369,18.0.761
 definitions=2021-03-16_03:2021-03-15,2021-03-16 signatures=0
X-Proofpoint-Spam-Details: rule=outbound_notspam policy=outbound score=0
 suspectscore=0 phishscore=0
 mlxlogscore=999 spamscore=0 impostorscore=0 malwarescore=0 adultscore=0
 mlxscore=0 priorityscore=1501 bulkscore=0 lowpriorityscore=0 clxscore=1015
 classifier=spam adjust=0 reason=mlx scancount=1 engine=8.12.0-2009150000
 definitions=main-2103160063
Precedence: bulk
List-ID: <kvm.vger.kernel.org>
X-Mailing-List: kvm@vger.kernel.org

Let's also test the UV host interfaces.

Signed-off-by: Janosch Frank <frankja@linux.ibm.com>
---
 s390x/Makefile  |   1 +
 s390x/uv-host.c | 513 ++++++++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 514 insertions(+)
 create mode 100644 s390x/uv-host.c

diff --git a/s390x/Makefile b/s390x/Makefile
index bbf177fa..8de926ab 100644
--- a/s390x/Makefile
+++ b/s390x/Makefile
@@ -21,6 +21,7 @@ tests += $(TEST_DIR)/css.elf
 tests += $(TEST_DIR)/uv-guest.elf
 tests += $(TEST_DIR)/sie.elf
 tests += $(TEST_DIR)/mvpg.elf
+tests += $(TEST_DIR)/uv-host.elf
 
 tests_binary = $(patsubst %.elf,%.bin,$(tests))
 ifneq ($(HOST_KEY_DOCUMENT),)
diff --git a/s390x/uv-host.c b/s390x/uv-host.c
new file mode 100644
index 00000000..746abd8e
--- /dev/null
+++ b/s390x/uv-host.c
@@ -0,0 +1,513 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Guest Ultravisor Call tests
+ *
+ * Copyright (c) 2021 IBM Corp
+ *
+ * Authors:
+ *  Janosch Frank <frankja@linux.ibm.com>
+ */
+
+#include <libcflat.h>
+#include <alloc.h>
+#include <vmalloc.h>
+#include <sclp.h>
+#include <smp.h>
+#include <asm/page.h>
+#include <asm/sigp.h>
+#include <asm/pgtable.h>
+#include <asm/asm-offsets.h>
+#include <asm/interrupt.h>
+#include <asm/facility.h>
+#include <asm/uv.h>
+#include <asm-generic/barrier.h>
+
+static struct uv_cb_qui uvcb_qui;
+static struct uv_cb_init uvcb_init;
+static struct uv_cb_cgc uvcb_cgc;
+static struct uv_cb_csc uvcb_csc;
+
+extern int diag308_load_reset(u64 code);
+
+struct cmd_list{
+	const char *name;
+	uint16_t cmd;
+	uint16_t len;
+};
+
+static void cpu_loop(void)
+{
+	for (;;) {}
+}
+
+static struct cmd_list cmds[] = {
+	{ "init", UVC_CMD_INIT_UV, sizeof(struct uv_cb_init) },
+	{ "create conf", UVC_CMD_CREATE_SEC_CONF, sizeof(struct uv_cb_cgc) },
+	{ "destroy conf", UVC_CMD_DESTROY_SEC_CONF, sizeof(struct uv_cb_nodata) },
+	{ "create cpu", UVC_CMD_CREATE_SEC_CPU, sizeof(struct uv_cb_csc) },
+	{ "destroy cpu", UVC_CMD_DESTROY_SEC_CPU, sizeof(struct uv_cb_nodata) },
+	{ "conv to", UVC_CMD_CONV_TO_SEC_STOR, sizeof(struct uv_cb_cts) },
+	{ "conv from", UVC_CMD_CONV_FROM_SEC_STOR, sizeof(struct uv_cb_cfs) },
+	{ "set sec conf", UVC_CMD_SET_SEC_CONF_PARAMS, sizeof(struct uv_cb_ssc) },
+	{ "unpack", UVC_CMD_UNPACK_IMG, sizeof(struct uv_cb_unp) },
+	{ "verify", UVC_CMD_VERIFY_IMG, sizeof(struct uv_cb_nodata) },
+	{ "cpu reset", UVC_CMD_CPU_RESET, sizeof(struct uv_cb_nodata) },
+	{ "cpu initial reset", UVC_CMD_CPU_RESET_INITIAL, sizeof(struct uv_cb_nodata) },
+	{ "conf clear reset", UVC_CMD_PERF_CONF_CLEAR_RESET, sizeof(struct uv_cb_nodata) },
+	{ "cpu clear reset", UVC_CMD_CPU_RESET_CLEAR, sizeof(struct uv_cb_nodata) },
+	{ "cpu set state", UVC_CMD_CPU_SET_STATE, sizeof(struct uv_cb_cpu_set_state) },
+	{ "pin shared", UVC_CMD_PIN_PAGE_SHARED, sizeof(struct uv_cb_cfs) },
+	{ "unpin shared", UVC_CMD_UNPIN_PAGE_SHARED, sizeof(struct uv_cb_cts) },
+	{ NULL, 0, 0 },
+};
+
+static void test_priv(void)
+{
+	struct uv_cb_header uvcb = {};
+	uint16_t pgm;
+	int i;
+
+	report_prefix_push("privileged");
+	for (i = 0; cmds[i].name; i++) {
+		expect_pgm_int();
+		uvcb.cmd = cmds[i].cmd;
+		uvcb.len = cmds[i].len;
+		enter_pstate();
+		uv_call(0, (uint64_t)&uvcb);
+		pgm = clear_pgm_int();
+		report(pgm == PGM_INT_CODE_PRIVILEGED_OPERATION, "%s", cmds[i].name);
+	}
+	report_prefix_pop();
+}
+
+static void test_config_destroy(void)
+{
+	int rc;
+	struct uv_cb_nodata uvcb = {
+		.header.cmd = UVC_CMD_DESTROY_SEC_CONF,
+		.header.len = sizeof(uvcb),
+		.handle = uvcb_cgc.guest_handle,
+	};
+
+	report_prefix_push("dsc");
+	uvcb.header.len -= 8;
+	rc = uv_call(0, (uint64_t)&uvcb);
+	report(rc == 1 && uvcb.header.rc == UVC_RC_INV_LEN,
+	       "hdr invalid length");
+	uvcb.header.len += 8;
+
+	uvcb.handle += 1;
+	rc = uv_call(0, (uint64_t)&uvcb);
+	report(rc == 1 && uvcb.header.rc == UVC_RC_INV_GHANDLE, "invalid handle");
+	uvcb.handle -= 1;
+
+	rc = uv_call(0, (uint64_t)&uvcb);
+	report(rc == 0 && uvcb.header.rc == UVC_RC_EXECUTED, "success");
+	report_prefix_pop();
+}
+
+static void test_cpu_destroy(void)
+{
+	int rc;
+	struct uv_cb_nodata uvcb = {
+		.header.len = sizeof(uvcb),
+		.header.cmd = UVC_CMD_DESTROY_SEC_CPU,
+		.handle = uvcb_csc.cpu_handle,
+	};
+
+	report_prefix_push("dcpu");
+
+	uvcb.header.len -= 8;
+	rc = uv_call(0, (uint64_t)&uvcb);
+	report(rc == 1 && uvcb.header.rc == UVC_RC_INV_LEN,
+	       "hdr invalid length");
+	uvcb.header.len += 8;
+
+	uvcb.handle += 1;
+	rc = uv_call(0, (uint64_t)&uvcb);
+	report(rc == 1 && uvcb.header.rc == UVC_RC_INV_CHANDLE, "invalid handle");
+	uvcb.handle -= 1;
+
+	rc = uv_call(0, (uint64_t)&uvcb);
+	report(rc == 0 && uvcb.header.rc == UVC_RC_EXECUTED, "success");
+
+	report_prefix_pop();
+}
+
+static void test_cpu_create(void)
+{
+	int rc;
+	unsigned long tmp;
+
+	report_prefix_push("csc");
+	uvcb_csc.header.len = sizeof(uvcb_csc);
+	uvcb_csc.header.cmd = UVC_CMD_CREATE_SEC_CPU;
+	uvcb_csc.guest_handle = uvcb_cgc.guest_handle;
+	uvcb_csc.stor_origin = (unsigned long)memalign(PAGE_SIZE, uvcb_qui.cpu_stor_len);
+	uvcb_csc.state_origin = (unsigned long)memalign(PAGE_SIZE, PAGE_SIZE);
+
+	uvcb_csc.header.len -= 8;
+	rc = uv_call(0, (uint64_t)&uvcb_csc);
+	report(uvcb_csc.header.rc == UVC_RC_INV_LEN && rc == 1 &&
+	       !uvcb_csc.cpu_handle, "hdr invalid length");
+	uvcb_csc.header.len += 8;
+
+	uvcb_csc.guest_handle += 1;
+	rc = uv_call(0, (uint64_t)&uvcb_csc);
+	report(uvcb_csc.header.rc == UVC_RC_INV_GHANDLE && rc == 1,
+	       "invalid guest handle");
+	uvcb_csc.guest_handle -= 1;
+
+	uvcb_csc.num = uvcb_qui.max_guest_cpus + 1;
+	rc = uv_call(0, (uint64_t)&uvcb_csc);
+	report(uvcb_csc.header.rc == 0x103 && rc == 1,
+	       "invalid cpu #");
+	uvcb_csc.num = 0;
+
+	tmp = uvcb_csc.stor_origin;
+	uvcb_csc.stor_origin = get_max_ram_size() + PAGE_SIZE;
+	rc = uv_call(0, (uint64_t)&uvcb_csc);
+	report(uvcb_csc.header.rc == 0x105 && rc == 1,
+	       "cpu stor inaccessible");
+	uvcb_csc.stor_origin = tmp;
+
+	tmp = uvcb_csc.stor_origin;
+	uvcb_csc.stor_origin = 0;
+	rc = uv_call(0, (uint64_t)&uvcb_csc);
+	report(uvcb_csc.header.rc == 0x106 && rc == 1,
+	       "cpu stor in lowcore");
+	uvcb_csc.stor_origin = tmp;
+
+	tmp = uvcb_csc.state_origin;
+	uvcb_csc.state_origin = get_max_ram_size() + PAGE_SIZE;
+	rc = uv_call(0, (uint64_t)&uvcb_csc);
+	report(uvcb_csc.header.rc == 0x107 && rc == 1,
+	       "SIE SD inaccessible");
+	uvcb_csc.state_origin = tmp;
+
+	rc = uv_call(0, (uint64_t)&uvcb_csc);
+	report(rc == 0 && uvcb_csc.header.rc == UVC_RC_EXECUTED &&
+	       uvcb_csc.cpu_handle, "success");
+
+	tmp = uvcb_csc.stor_origin;
+	uvcb_csc.stor_origin = (unsigned long)memalign(PAGE_SIZE, uvcb_qui.cpu_stor_len);
+	rc = uv_call(0, (uint64_t)&uvcb_csc);
+	report(rc == 1 && uvcb_csc.header.rc == 0x104, "already defined");
+	uvcb_csc.stor_origin = tmp;
+	report_prefix_pop();
+}
+
+static void test_config_create(void)
+{
+	int rc;
+	unsigned long vsize, tmp;
+	static struct uv_cb_cgc uvcb;
+
+	uvcb_cgc.header.cmd = UVC_CMD_CREATE_SEC_CONF;
+	uvcb_cgc.header.len = sizeof(uvcb_cgc);
+	report_prefix_push("cgc");
+
+	uvcb_cgc.guest_stor_origin = 0;
+	uvcb_cgc.guest_stor_len = 42 * (1UL << 20);
+	vsize = uvcb_qui.conf_base_virt_stor_len +
+		((uvcb_cgc.guest_stor_len / (1UL << 20)) * uvcb_qui.conf_virt_var_stor_len);
+
+	uvcb_cgc.conf_base_stor_origin = (uint64_t)memalign(PAGE_SIZE * 4, uvcb_qui.conf_base_phys_stor_len);
+	uvcb_cgc.conf_var_stor_origin = (uint64_t)memalign(PAGE_SIZE, vsize);
+	uvcb_cgc.guest_asce = (uint64_t)memalign(PAGE_SIZE, 4 * PAGE_SIZE) | ASCE_DT_SEGMENT | REGION_TABLE_LENGTH | ASCE_P;
+	uvcb_cgc.guest_sca = (uint64_t)memalign(PAGE_SIZE * 4, PAGE_SIZE * 4);
+
+	uvcb_cgc.header.len -= 8;
+	rc = uv_call(0, (uint64_t)&uvcb_cgc);
+	report(uvcb_cgc.header.rc == UVC_RC_INV_LEN && rc == 1 &&
+	       !uvcb_cgc.guest_handle, "hdr invalid length");
+	uvcb_cgc.header.len += 8;
+
+	uvcb_cgc.guest_stor_origin = uvcb_qui.max_guest_stor_addr + (1UL << 20) * 2 + 1;
+	rc = uv_call(0, (uint64_t)&uvcb_cgc);
+	report(uvcb_cgc.header.rc == 0x101 && rc == 1,
+	       "MSO > max guest addr");
+	uvcb_cgc.guest_stor_origin = 0;
+
+	uvcb_cgc.guest_stor_origin = uvcb_qui.max_guest_stor_addr - (1UL << 20);
+	rc = uv_call(0, (uint64_t)&uvcb_cgc);
+	report(uvcb_cgc.header.rc == 0x102 && rc == 1,
+	       "MSO + MSL > max guest addr");
+	uvcb_cgc.guest_stor_origin = 0;
+
+	uvcb_cgc.guest_asce &= ~ASCE_P;
+	rc = uv_call(0, (uint64_t)&uvcb_cgc);
+	report(uvcb_cgc.header.rc == 0x105 && rc == 1,
+	       "ASCE private bit missing");
+	uvcb_cgc.guest_asce |= ASCE_P;
+
+	uvcb_cgc.guest_asce |= 0x20;
+	rc = uv_call(0, (uint64_t)&uvcb_cgc);
+	report(uvcb_cgc.header.rc == 0x105 && rc == 1,
+	       "ASCE bit 58 set");
+	uvcb_cgc.guest_asce &= ~0x20;
+
+	tmp = uvcb_cgc.conf_base_stor_origin;
+	uvcb_cgc.conf_base_stor_origin = get_max_ram_size() + 8;
+	rc = uv_call(0, (uint64_t)&uvcb_cgc);
+	report(uvcb_cgc.header.rc == 0x108 && rc == 1,
+	       "base storage origin > available memory");
+	uvcb_cgc.conf_base_stor_origin = tmp;
+
+	tmp = uvcb_cgc.conf_base_stor_origin;
+	uvcb_cgc.conf_base_stor_origin = 0x1000;
+	rc = uv_call(0, (uint64_t)&uvcb_cgc);
+	report(uvcb_cgc.header.rc == 0x109 && rc == 1,
+	       "base storage origin contains lowcore");
+	uvcb_cgc.conf_base_stor_origin = tmp;
+
+	if (smp_query_num_cpus() == 1) {
+		sigp_retry(1, SIGP_SET_PREFIX,
+			   uvcb_cgc.conf_var_stor_origin + PAGE_SIZE, NULL);
+		rc = uv_call(0, (uint64_t)&uvcb_cgc);
+		report(uvcb_cgc.header.rc == 0x10e && rc == 1 &&
+		       !uvcb_cgc.guest_handle, "variable storage area contains lowcore");
+		sigp_retry(1, SIGP_SET_PREFIX, 0x0, NULL);
+	}
+
+	tmp = uvcb_cgc.guest_sca;
+	uvcb_cgc.guest_sca = 0;
+	rc = uv_call(0, (uint64_t)&uvcb_cgc);
+	report(uvcb_cgc.header.rc == 0x10c && rc == 1,
+	       "sca == 0");
+	uvcb_cgc.guest_sca = tmp;
+
+	tmp = uvcb_cgc.guest_sca;
+	uvcb_cgc.guest_sca = get_max_ram_size() + + PAGE_SIZE * 4;
+	rc = uv_call(0, (uint64_t)&uvcb_cgc);
+	report(uvcb_cgc.header.rc == 0x10d && rc == 1,
+	       "sca inaccessible");
+	uvcb_cgc.guest_sca = tmp;
+
+	rc = uv_call(0, (uint64_t)&uvcb_cgc);
+	report(rc == 0 && uvcb_cgc.header.rc == UVC_RC_EXECUTED, "successful");
+
+	uvcb_cgc.header.rc = 0;
+	uvcb_cgc.header.rrc = 0;
+	tmp = uvcb_cgc.guest_handle;
+	uvcb_cgc.guest_handle = 0;
+	rc = uv_call(0, (uint64_t)&uvcb_cgc);
+	report(uvcb_cgc.header.rc >= 0x100 && rc == 1, "reuse uvcb");
+	uvcb_cgc.guest_handle = tmp;
+
+	/* Copy over most data from uvcb_cgc, so we have the ASCE that was used. */
+	memcpy(&uvcb, &uvcb_cgc, sizeof(uvcb));
+
+	/* Reset the header and handle */
+	uvcb.header.rc = 0;
+	uvcb.header.rrc = 0;
+	uvcb.guest_handle = 0;
+
+	/* Use new storage areas. */
+	uvcb.conf_base_stor_origin = (uint64_t)memalign(PAGE_SIZE * 4, uvcb_qui.conf_base_phys_stor_len);
+	uvcb.conf_var_stor_origin = (uint64_t)memalign(PAGE_SIZE, vsize);
+
+	rc = uv_call(0, (uint64_t)&uvcb);
+	report(uvcb.header.rc >= 0x104 && rc == 1 && !uvcb.guest_handle,
+	       "reuse ASCE");
+	free((void *)uvcb.conf_base_stor_origin);
+	free((void *)uvcb.conf_var_stor_origin);
+
+
+	/* Missing: 106, 10a, a0b */
+	report_prefix_pop();
+}
+
+static void test_init(void)
+{
+	int rc;
+	uint64_t mem;
+	struct psw psw;
+
+	/* Donated storage needs to be over 2GB */
+	mem = (uint64_t)memalign(1UL << 31, uvcb_qui.uv_base_stor_len);
+
+	uvcb_init.header.len = sizeof(uvcb_init);
+	uvcb_init.header.cmd = UVC_CMD_INIT_UV;
+	uvcb_init.stor_origin = mem;
+	uvcb_init.stor_len = uvcb_qui.uv_base_stor_len;
+
+	report_prefix_push("init");
+	uvcb_init.header.len -= 8;
+	rc = uv_call(0, (uint64_t)&uvcb_init);
+	report(rc == 1 && uvcb_init.header.rc == UVC_RC_INV_LEN,
+	       "hdr invalid length");
+	uvcb_init.header.len += 8;
+
+	uvcb_init.stor_len -= 8;
+	rc = uv_call(0, (uint64_t)&uvcb_init);
+	report(rc == 1 && uvcb_init.header.rc == 0x103,
+	       "storage invalid length");
+	uvcb_init.stor_len += 8;
+
+	uvcb_init.stor_origin =  get_max_ram_size() + 8;
+	rc = uv_call(0, (uint64_t)&uvcb_init);
+	report(rc == 1 && uvcb_init.header.rc == 0x104,
+	       "storage origin invalid");
+	uvcb_init.stor_origin = mem;
+
+	uvcb_init.stor_origin = get_max_ram_size() - 8;
+	rc = uv_call(0, (uint64_t)&uvcb_init);
+	report(rc == 1 && uvcb_init.header.rc == 0x105,
+	       "storage + length invalid");
+	uvcb_init.stor_origin = mem;
+
+	uvcb_init.stor_origin = 1UL << 30;
+	rc = uv_call(0, (uint64_t)&uvcb_init);
+	report(rc == 1 && uvcb_init.header.rc == 0x108,
+	       "storage below 2GB");
+	uvcb_init.stor_origin = mem;
+
+	psw.mask = extract_psw_mask();
+	psw.addr = (unsigned long)cpu_loop;
+	smp_cpu_setup(1, psw);
+	rc = uv_call(0, (uint64_t)&uvcb_init);
+	report(rc == 1 && uvcb_init.header.rc == 0x102,
+	       "too many running cpus");
+	smp_cpu_stop(1);
+
+	rc = uv_call(0, (uint64_t)&uvcb_init);
+	report(rc == 0 && uvcb_init.header.rc == UVC_RC_EXECUTED, "successful");
+
+	mem = (uint64_t)memalign(1UL << 31, uvcb_qui.uv_base_stor_len);
+	rc = uv_call(0, (uint64_t)&uvcb_init);
+	report(rc == 1 && uvcb_init.header.rc == 0x101, "double init");
+	free((void *)mem);
+
+	report_prefix_pop();
+}
+
+static void test_query(void)
+{
+	uvcb_qui.header.cmd = UVC_CMD_QUI;
+	uvcb_qui.header.len = sizeof(uvcb_qui);
+	uint64_t *call_list = &uvcb_qui.inst_calls_list[0];
+
+	report_prefix_push("query");
+	uvcb_qui.header.len = 0xa0;
+	uv_call(0, (uint64_t)&uvcb_qui);
+	report(uvcb_qui.header.rc == UVC_RC_INV_LEN, "length");
+
+	uvcb_qui.header.len = 0xa8;
+	uv_call(0, (uint64_t)&uvcb_qui);
+	report(uvcb_qui.header.rc == 0x100, "insf length");
+
+	uvcb_qui.header.len = sizeof(uvcb_qui);
+	uv_call(0, (uint64_t)&uvcb_qui);
+	report(uvcb_qui.header.rc == UVC_RC_EXECUTED, "successful query");
+
+	report(test_bit_inv(BIT_UVC_CMD_QUI, call_list) &&
+	       test_bit_inv(BIT_UVC_CMD_INIT_UV, call_list),
+	       "query and init indicated");
+
+	report(test_bit_inv(BIT_UVC_CMD_CREATE_SEC_CONF, call_list) &&
+	       test_bit_inv(BIT_UVC_CMD_DESTROY_SEC_CONF, call_list),
+	       "create/destroy vm indicated");
+
+	report(test_bit_inv(BIT_UVC_CMD_CREATE_SEC_CPU, call_list) &&
+	       test_bit_inv(BIT_UVC_CMD_DESTROY_SEC_CPU, call_list),
+	       "create/destroy cpu indicated");
+
+	report(test_bit_inv(BIT_UVC_CMD_CONV_TO_SEC_STOR, call_list) &&
+	       test_bit_inv(BIT_UVC_CMD_CONV_FROM_SEC_STOR, call_list),
+	       "convert to/from secure storage indicated");
+
+	report(test_bit_inv(BIT_UVC_CMD_SET_SEC_PARMS, call_list) &&
+	       test_bit_inv(BIT_UVC_CMD_UNPACK_IMG, call_list) &&
+	       test_bit_inv(BIT_UVC_CMD_CPU_SET_STATE, call_list) &&
+	       test_bit_inv(BIT_UVC_CMD_VERIFY_IMG, call_list),
+	       "set sec parm, setcpu state, unpack and verify indicated");
+
+	report(test_bit_inv(BIT_UVC_CMD_CPU_RESET, call_list) &&
+	       test_bit_inv(BIT_UVC_CMD_CPU_RESET_INITIAL, call_list) &&
+	       test_bit_inv(BIT_UVC_CMD_CPU_PERFORM_CLEAR_RESET, call_list),
+	       "resets indicated");
+
+	report(test_bit_inv(BIT_UVC_CMD_PREPARE_CLEAR_RESET, call_list) &&
+	       test_bit_inv(BIT_UVC_CMD_UNSHARE_ALL, call_list),
+	       "prepare reset and unshare all indicated");
+
+	report(test_bit_inv(BIT_UVC_CMD_PIN_PAGE_SHARED, call_list) &&
+	       test_bit_inv(BIT_UVC_CMD_UNPIN_PAGE_SHARED, call_list),
+	       "(un)pin shared page indicated");
+
+	report(!test_bit_inv(BIT_UVC_CMD_SET_SHARED_ACCESS, call_list) &&
+	       !test_bit_inv(BIT_UVC_CMD_REMOVE_SHARED_ACCESS, call_list),
+	       "(un)share not indicated");
+
+	report_prefix_pop();
+}
+
+static struct cmd_list invalid_cmds[] = {
+	{ "bogus", 0x4242, sizeof(struct uv_cb_header) },
+	{ "share", UVC_CMD_SET_SHARED_ACCESS, sizeof(struct uv_cb_share) },
+	{ "unshare", UVC_CMD_REMOVE_SHARED_ACCESS, sizeof(struct uv_cb_share) },
+	{ NULL, 0, 0 },
+};
+
+static void test_invalid(void)
+{
+	struct uv_cb_header hdr = {};
+	int i, cc;
+
+	report_prefix_push("invalid");
+	for (i = 0; invalid_cmds[i].name; i++) {
+		hdr.cmd = invalid_cmds[i].cmd;
+		hdr.len = invalid_cmds[i].len;
+		cc = uv_call(0, (uint64_t)&hdr);
+		report(cc == 1 && hdr.rc == UVC_RC_INV_CMD, "%s",
+		       invalid_cmds[i].name);
+	}
+	report_prefix_pop();
+}
+
+static void test_clear(void)
+{
+	uint64_t *tmp = (void *)uvcb_init.stor_origin;
+
+	diag308_load_reset(1);
+	sclp_console_setup();
+	report(!*tmp, "memory cleared after reset 1");
+}
+
+static void setup_vmem(void)
+{
+	uint64_t asce, mask;
+
+	setup_mmu(get_max_ram_size());
+	asce = stctg(1);
+	lctlg(13, asce);
+	mask = extract_psw_mask() | 0x0000C00000000000UL;
+	load_psw_mask(mask);
+}
+
+int main(void)
+{
+	bool has_uvc = test_facility(158);
+
+	report_prefix_push("uvc");
+	if (!has_uvc) {
+		report_skip("Ultravisor call facility is not available");
+		goto done;
+	}
+
+	test_priv();
+	test_invalid();
+	test_query();
+	test_init();
+
+	setup_vmem();
+	test_config_create();
+	test_cpu_create();
+	test_cpu_destroy();
+	test_config_destroy();
+	test_clear();
+
+done:
+	return report_summary();
+}
