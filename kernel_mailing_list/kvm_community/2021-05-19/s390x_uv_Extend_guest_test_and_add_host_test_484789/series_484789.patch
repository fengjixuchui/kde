From patchwork Wed May 19 07:40:17 2021
Content-Type: text/plain; charset="utf-8"
MIME-Version: 1.0
Content-Transfer-Encoding: 7bit
X-Patchwork-Submitter: Janosch Frank <frankja@linux.ibm.com>
X-Patchwork-Id: 12266501
Return-Path: <kvm-owner@kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-16.8 required=3.0 tests=BAYES_00,DKIM_SIGNED,
	DKIM_VALID,HEADER_FROM_DIFFERENT_DOMAINS,INCLUDES_CR_TRAILER,INCLUDES_PATCH,
	MAILING_LIST_MULTI,SPF_HELO_NONE,SPF_PASS,USER_AGENT_GIT
	autolearn=unavailable autolearn_force=no version=3.4.0
Received: from mail.kernel.org (mail.kernel.org [198.145.29.99])
	by smtp.lore.kernel.org (Postfix) with ESMTP id AF06DC433B4
	for <kvm@archiver.kernel.org>; Wed, 19 May 2021 07:40:43 +0000 (UTC)
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by mail.kernel.org (Postfix) with ESMTP id 89BEC61364
	for <kvm@archiver.kernel.org>; Wed, 19 May 2021 07:40:43 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S240567AbhESHmB (ORCPT <rfc822;kvm@archiver.kernel.org>);
        Wed, 19 May 2021 03:42:01 -0400
Received: from mx0b-001b2d01.pphosted.com ([148.163.158.5]:28416 "EHLO
        mx0a-001b2d01.pphosted.com" rhost-flags-OK-OK-OK-FAIL)
        by vger.kernel.org with ESMTP id S238476AbhESHmB (ORCPT
        <rfc822;kvm@vger.kernel.org>); Wed, 19 May 2021 03:42:01 -0400
Received: from pps.filterd (m0098419.ppops.net [127.0.0.1])
        by mx0b-001b2d01.pphosted.com (8.16.0.43/8.16.0.43) with SMTP id
 14J7Ztdf107203;
        Wed, 19 May 2021 03:40:41 -0400
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=ibm.com;
 h=from : to : cc : subject
 : date : message-id : in-reply-to : references : mime-version :
 content-transfer-encoding; s=pp1;
 bh=3uZmSI77E5TGNyfkRuQlpsM6Hja+QeN+kVV0qwniZ1M=;
 b=PntznEl3JYZ7ruiC+RIQlVLj6KXmcsJPqD/qIURi2Akdd678MNd68qUnPhlwbSZZLjJD
 HxuG9wBKA6iv3MGdBH7CVpZC8gR9OFimu8Y+B0gF2oZ7oPvAzBUWXgIKdtSk/JZLbjYH
 Pbc1WYQYVhCvLvFJ5WwiBd86nbmUobEau1qHroXsYv6bvZCG5xymn9RFU6ABNbCceubU
 Fga/jAfA9WLQ8igtaY30HnJsCnFC4nGCvxIJ+dXQOgrmqk4CuSwLl3wU8c0/PtR2Qe5/
 IiODsjKRESGUOQufoCXIa1MOWx1ut3/l1S0aClQBE9Iy1Acq/7M6kgHd97F+YnvsJAae JQ==
Received: from pps.reinject (localhost [127.0.0.1])
        by mx0b-001b2d01.pphosted.com with ESMTP id 38mx73ggg5-1
        (version=TLSv1.2 cipher=ECDHE-RSA-AES256-GCM-SHA384 bits=256
 verify=NOT);
        Wed, 19 May 2021 03:40:41 -0400
Received: from m0098419.ppops.net (m0098419.ppops.net [127.0.0.1])
        by pps.reinject (8.16.0.43/8.16.0.43) with SMTP id 14J7aMuN108593;
        Wed, 19 May 2021 03:40:41 -0400
Received: from ppma04ams.nl.ibm.com (63.31.33a9.ip4.static.sl-reverse.com
 [169.51.49.99])
        by mx0b-001b2d01.pphosted.com with ESMTP id 38mx73gget-1
        (version=TLSv1.2 cipher=ECDHE-RSA-AES256-GCM-SHA384 bits=256
 verify=NOT);
        Wed, 19 May 2021 03:40:41 -0400
Received: from pps.filterd (ppma04ams.nl.ibm.com [127.0.0.1])
        by ppma04ams.nl.ibm.com (8.16.0.43/8.16.0.43) with SMTP id
 14J7bdQM004010;
        Wed, 19 May 2021 07:40:39 GMT
Received: from b06cxnps4076.portsmouth.uk.ibm.com
 (d06relay13.portsmouth.uk.ibm.com [9.149.109.198])
        by ppma04ams.nl.ibm.com with ESMTP id 38j5x89x73-1
        (version=TLSv1.2 cipher=ECDHE-RSA-AES256-GCM-SHA384 bits=256
 verify=NOT);
        Wed, 19 May 2021 07:40:39 +0000
Received: from b06wcsmtp001.portsmouth.uk.ibm.com
 (b06wcsmtp001.portsmouth.uk.ibm.com [9.149.105.160])
        by b06cxnps4076.portsmouth.uk.ibm.com (8.14.9/8.14.9/NCO v10.0) with
 ESMTP id 14J7eaLB40829338
        (version=TLSv1/SSLv3 cipher=DHE-RSA-AES256-GCM-SHA384 bits=256
 verify=OK);
        Wed, 19 May 2021 07:40:36 GMT
Received: from b06wcsmtp001.portsmouth.uk.ibm.com (unknown [127.0.0.1])
        by IMSVA (Postfix) with ESMTP id 70E3AA4060;
        Wed, 19 May 2021 07:40:36 +0000 (GMT)
Received: from b06wcsmtp001.portsmouth.uk.ibm.com (unknown [127.0.0.1])
        by IMSVA (Postfix) with ESMTP id A38CAA405C;
        Wed, 19 May 2021 07:40:35 +0000 (GMT)
Received: from linux01.pok.stglabs.ibm.com (unknown [9.114.17.81])
        by b06wcsmtp001.portsmouth.uk.ibm.com (Postfix) with ESMTP;
        Wed, 19 May 2021 07:40:35 +0000 (GMT)
From: Janosch Frank <frankja@linux.ibm.com>
To: kvm@vger.kernel.org
Cc: frankja@linux.ibm.com, david@redhat.com, cohuck@redhat.com,
        linux-s390@vger.kernel.org, imbrenda@linux.ibm.com,
        thuth@redhat.com
Subject: [kvm-unit-tests PATCH v3 1/6] s390x: uv-guest: Add invalid share
 location test
Date: Wed, 19 May 2021 07:40:17 +0000
Message-Id: <20210519074022.7368-2-frankja@linux.ibm.com>
X-Mailer: git-send-email 2.30.2
In-Reply-To: <20210519074022.7368-1-frankja@linux.ibm.com>
References: <20210519074022.7368-1-frankja@linux.ibm.com>
MIME-Version: 1.0
X-TM-AS-GCONF: 00
X-Proofpoint-GUID: NcMP3Ne4QutKwu4WEXMCDZ2oYWUkbfzL
X-Proofpoint-ORIG-GUID: OlhwDVqisi7uqM7cQ-BGzNzJcyEVNCzT
X-Proofpoint-Virus-Version: vendor=fsecure engine=2.50.10434:6.0.391,18.0.761
 definitions=2021-05-19_02:2021-05-18,2021-05-19 signatures=0
X-Proofpoint-Spam-Details: rule=outbound_notspam policy=outbound score=0
 suspectscore=0
 mlxlogscore=999 clxscore=1015 impostorscore=0 malwarescore=0
 lowpriorityscore=0 priorityscore=1501 adultscore=0 mlxscore=0 bulkscore=0
 spamscore=0 phishscore=0 classifier=spam adjust=0 reason=mlx scancount=1
 engine=8.12.0-2104190000 definitions=main-2105190055
Precedence: bulk
List-ID: <kvm.vger.kernel.org>
X-Mailing-List: kvm@vger.kernel.org

Let's also test sharing unavailable memory.

Signed-off-by: Janosch Frank <frankja@linux.ibm.com>
Reviewed-by: Claudio Imbrenda <imbrenda@linux.ibm.com>
Reviewed-by: Cornelia Huck <cohuck@redhat.com>
Reviewed-by: Thomas Huth <thuth@redhat.com>
---
 s390x/uv-guest.c | 5 +++++
 1 file changed, 5 insertions(+)

diff --git a/s390x/uv-guest.c b/s390x/uv-guest.c
index 99544442..a13669ab 100644
--- a/s390x/uv-guest.c
+++ b/s390x/uv-guest.c
@@ -15,6 +15,7 @@
 #include <asm/interrupt.h>
 #include <asm/facility.h>
 #include <asm/uv.h>
+#include <sclp.h>
 
 static unsigned long page;
 
@@ -99,6 +100,10 @@ static void test_sharing(void)
 	uvcb.header.len = sizeof(uvcb);
 	cc = uv_call(0, (u64)&uvcb);
 	report(cc == 0 && uvcb.header.rc == UVC_RC_EXECUTED, "share");
+	uvcb.paddr = get_ram_size() + PAGE_SIZE;
+	cc = uv_call(0, (u64)&uvcb);
+	report(cc == 1 && uvcb.header.rc == 0x101, "invalid memory");
+	uvcb.paddr = page;
 	report_prefix_pop();
 
 	report_prefix_push("unshare");

From patchwork Wed May 19 07:40:18 2021
Content-Type: text/plain; charset="utf-8"
MIME-Version: 1.0
Content-Transfer-Encoding: 7bit
X-Patchwork-Submitter: Janosch Frank <frankja@linux.ibm.com>
X-Patchwork-Id: 12266503
Return-Path: <kvm-owner@kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-16.8 required=3.0 tests=BAYES_00,DKIM_SIGNED,
	DKIM_VALID,HEADER_FROM_DIFFERENT_DOMAINS,INCLUDES_CR_TRAILER,INCLUDES_PATCH,
	MAILING_LIST_MULTI,SPF_HELO_NONE,SPF_PASS,USER_AGENT_GIT
	autolearn=unavailable autolearn_force=no version=3.4.0
Received: from mail.kernel.org (mail.kernel.org [198.145.29.99])
	by smtp.lore.kernel.org (Postfix) with ESMTP id 2B39EC43462
	for <kvm@archiver.kernel.org>; Wed, 19 May 2021 07:40:45 +0000 (UTC)
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by mail.kernel.org (Postfix) with ESMTP id 0787C61244
	for <kvm@archiver.kernel.org>; Wed, 19 May 2021 07:40:45 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S240604AbhESHmD (ORCPT <rfc822;kvm@archiver.kernel.org>);
        Wed, 19 May 2021 03:42:03 -0400
Received: from mx0b-001b2d01.pphosted.com ([148.163.158.5]:18834 "EHLO
        mx0a-001b2d01.pphosted.com" rhost-flags-OK-OK-OK-FAIL)
        by vger.kernel.org with ESMTP id S238476AbhESHmC (ORCPT
        <rfc822;kvm@vger.kernel.org>); Wed, 19 May 2021 03:42:02 -0400
Received: from pps.filterd (m0098414.ppops.net [127.0.0.1])
        by mx0b-001b2d01.pphosted.com (8.16.0.43/8.16.0.43) with SMTP id
 14J7a0dV144162;
        Wed, 19 May 2021 03:40:43 -0400
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=ibm.com;
 h=from : to : cc : subject
 : date : message-id : in-reply-to : references : mime-version :
 content-transfer-encoding; s=pp1;
 bh=DfyKGC10dPTZxf0QuIbrSRByq2rJhSJodfyMMUqIesY=;
 b=MFOpTuAq4IyOCXN+4DhvlysDPwyMcKYUTPkkEavJFwFEcKrCyCUgRjNuZQmeZbNAlBsz
 CKD3hm+089DmQddW2SRqY2BMQIAzvWzaRc9TCqRu/3+Fpg0EkoD9FVvjsUDZxqcy1sWW
 f/sszi6BtlLXx3G5uBdzHSBOUxDpWhXZVEkR7HuWN462XA6Ibf7cGVdKbfg2+qGDOJOK
 bi0kBmsfa4CkTikbtmBwD0j2AAZgsqyXCGDLgkajriExqJP9evBGbjV2hmRzuErAs3YS
 /CVNzMHpPPHB7iH64JnxCfJnWyrlKLT9MxgNO4Db4V6b7t5wZ2bvvA93xbrZAyKMnzLb eQ==
Received: from pps.reinject (localhost [127.0.0.1])
        by mx0b-001b2d01.pphosted.com with ESMTP id 38mwx4s9p5-1
        (version=TLSv1.2 cipher=ECDHE-RSA-AES256-GCM-SHA384 bits=256
 verify=NOT);
        Wed, 19 May 2021 03:40:42 -0400
Received: from m0098414.ppops.net (m0098414.ppops.net [127.0.0.1])
        by pps.reinject (8.16.0.43/8.16.0.43) with SMTP id 14J7aQie146579;
        Wed, 19 May 2021 03:40:42 -0400
Received: from ppma04ams.nl.ibm.com (63.31.33a9.ip4.static.sl-reverse.com
 [169.51.49.99])
        by mx0b-001b2d01.pphosted.com with ESMTP id 38mwx4s9mk-1
        (version=TLSv1.2 cipher=ECDHE-RSA-AES256-GCM-SHA384 bits=256
 verify=NOT);
        Wed, 19 May 2021 03:40:42 -0400
Received: from pps.filterd (ppma04ams.nl.ibm.com [127.0.0.1])
        by ppma04ams.nl.ibm.com (8.16.0.43/8.16.0.43) with SMTP id
 14J7b1rR003358;
        Wed, 19 May 2021 07:40:40 GMT
Received: from b06avi18878370.portsmouth.uk.ibm.com
 (b06avi18878370.portsmouth.uk.ibm.com [9.149.26.194])
        by ppma04ams.nl.ibm.com with ESMTP id 38j5x89x74-1
        (version=TLSv1.2 cipher=ECDHE-RSA-AES256-GCM-SHA384 bits=256
 verify=NOT);
        Wed, 19 May 2021 07:40:40 +0000
Received: from b06wcsmtp001.portsmouth.uk.ibm.com
 (b06wcsmtp001.portsmouth.uk.ibm.com [9.149.105.160])
        by b06avi18878370.portsmouth.uk.ibm.com (8.14.9/8.14.9/NCO v10.0) with
 ESMTP id 14J7e95932834014
        (version=TLSv1/SSLv3 cipher=DHE-RSA-AES256-GCM-SHA384 bits=256
 verify=OK);
        Wed, 19 May 2021 07:40:09 GMT
Received: from b06wcsmtp001.portsmouth.uk.ibm.com (unknown [127.0.0.1])
        by IMSVA (Postfix) with ESMTP id 5A6AEA4062;
        Wed, 19 May 2021 07:40:37 +0000 (GMT)
Received: from b06wcsmtp001.portsmouth.uk.ibm.com (unknown [127.0.0.1])
        by IMSVA (Postfix) with ESMTP id 972A1A4060;
        Wed, 19 May 2021 07:40:36 +0000 (GMT)
Received: from linux01.pok.stglabs.ibm.com (unknown [9.114.17.81])
        by b06wcsmtp001.portsmouth.uk.ibm.com (Postfix) with ESMTP;
        Wed, 19 May 2021 07:40:36 +0000 (GMT)
From: Janosch Frank <frankja@linux.ibm.com>
To: kvm@vger.kernel.org
Cc: frankja@linux.ibm.com, david@redhat.com, cohuck@redhat.com,
        linux-s390@vger.kernel.org, imbrenda@linux.ibm.com,
        thuth@redhat.com
Subject: [kvm-unit-tests PATCH v3 2/6] s390x: Add more Ultravisor command
 structure definitions
Date: Wed, 19 May 2021 07:40:18 +0000
Message-Id: <20210519074022.7368-3-frankja@linux.ibm.com>
X-Mailer: git-send-email 2.30.2
In-Reply-To: <20210519074022.7368-1-frankja@linux.ibm.com>
References: <20210519074022.7368-1-frankja@linux.ibm.com>
MIME-Version: 1.0
X-TM-AS-GCONF: 00
X-Proofpoint-GUID: akf0Y71g9dMhnc_slqzWhQ6TaT-vDKzN
X-Proofpoint-ORIG-GUID: jlzKXSZUg_-yNG6Wd-wMA0m-gFy9vvrJ
X-Proofpoint-Virus-Version: vendor=fsecure engine=2.50.10434:6.0.391,18.0.761
 definitions=2021-05-19_02:2021-05-18,2021-05-19 signatures=0
X-Proofpoint-Spam-Details: rule=outbound_notspam policy=outbound score=0
 impostorscore=0 phishscore=0
 spamscore=0 mlxscore=0 malwarescore=0 bulkscore=0 suspectscore=0
 clxscore=1015 priorityscore=1501 lowpriorityscore=0 mlxlogscore=999
 adultscore=0 classifier=spam adjust=0 reason=mlx scancount=1
 engine=8.12.0-2104190000 definitions=main-2105190055
Precedence: bulk
List-ID: <kvm.vger.kernel.org>
X-Mailing-List: kvm@vger.kernel.org

They are needed in the new UV tests.

As we now extend the size of the query struct, we need to set the
length in the UV guest query test to a constant instead of using
sizeof.

Signed-off-by: Janosch Frank <frankja@linux.ibm.com>
Reviewed-by: Claudio Imbrenda <imbrenda@linux.ibm.com>
Acked-by: Cornelia Huck <cohuck@redhat.com>
---
 lib/s390x/asm/uv.h | 148 ++++++++++++++++++++++++++++++++++++++++++++-
 s390x/uv-guest.c   |   3 +-
 2 files changed, 149 insertions(+), 2 deletions(-)

diff --git a/lib/s390x/asm/uv.h b/lib/s390x/asm/uv.h
index 9c491844..11f70a9f 100644
--- a/lib/s390x/asm/uv.h
+++ b/lib/s390x/asm/uv.h
@@ -17,16 +17,54 @@
 #define UVC_RC_INV_STATE	0x0003
 #define UVC_RC_INV_LEN		0x0005
 #define UVC_RC_NO_RESUME	0x0007
+#define UVC_RC_INV_GHANDLE	0x0020
+#define UVC_RC_INV_CHANDLE	0x0021
 
 #define UVC_CMD_QUI			0x0001
+#define UVC_CMD_INIT_UV			0x000f
+#define UVC_CMD_CREATE_SEC_CONF		0x0100
+#define UVC_CMD_DESTROY_SEC_CONF	0x0101
+#define UVC_CMD_CREATE_SEC_CPU		0x0120
+#define UVC_CMD_DESTROY_SEC_CPU		0x0121
+#define UVC_CMD_CONV_TO_SEC_STOR	0x0200
+#define UVC_CMD_CONV_FROM_SEC_STOR	0x0201
+#define UVC_CMD_SET_SEC_CONF_PARAMS	0x0300
+#define UVC_CMD_UNPACK_IMG		0x0301
+#define UVC_CMD_VERIFY_IMG		0x0302
+#define UVC_CMD_CPU_RESET		0x0310
+#define UVC_CMD_CPU_RESET_INITIAL	0x0311
+#define UVC_CMD_PERF_CONF_CLEAR_RESET	0x0320
+#define UVC_CMD_CPU_RESET_CLEAR		0x0321
+#define UVC_CMD_CPU_SET_STATE		0x0330
+#define UVC_CMD_SET_UNSHARED_ALL	0x0340
+#define UVC_CMD_PIN_PAGE_SHARED		0x0341
+#define UVC_CMD_UNPIN_PAGE_SHARED	0x0342
 #define UVC_CMD_SET_SHARED_ACCESS	0x1000
 #define UVC_CMD_REMOVE_SHARED_ACCESS	0x1001
 
 /* Bits in installed uv calls */
 enum uv_cmds_inst {
 	BIT_UVC_CMD_QUI = 0,
+	BIT_UVC_CMD_INIT_UV = 1,
+	BIT_UVC_CMD_CREATE_SEC_CONF = 2,
+	BIT_UVC_CMD_DESTROY_SEC_CONF = 3,
+	BIT_UVC_CMD_CREATE_SEC_CPU = 4,
+	BIT_UVC_CMD_DESTROY_SEC_CPU = 5,
+	BIT_UVC_CMD_CONV_TO_SEC_STOR = 6,
+	BIT_UVC_CMD_CONV_FROM_SEC_STOR = 7,
 	BIT_UVC_CMD_SET_SHARED_ACCESS = 8,
 	BIT_UVC_CMD_REMOVE_SHARED_ACCESS = 9,
+	BIT_UVC_CMD_SET_SEC_PARMS = 11,
+	BIT_UVC_CMD_UNPACK_IMG = 13,
+	BIT_UVC_CMD_VERIFY_IMG = 14,
+	BIT_UVC_CMD_CPU_RESET = 15,
+	BIT_UVC_CMD_CPU_RESET_INITIAL = 16,
+	BIT_UVC_CMD_CPU_SET_STATE = 17,
+	BIT_UVC_CMD_PREPARE_CLEAR_RESET = 18,
+	BIT_UVC_CMD_CPU_PERFORM_CLEAR_RESET = 19,
+	BIT_UVC_CMD_UNSHARE_ALL = 20,
+	BIT_UVC_CMD_PIN_PAGE_SHARED = 21,
+	BIT_UVC_CMD_UNPIN_PAGE_SHARED = 22,
 };
 
 struct uv_cb_header {
@@ -36,13 +74,81 @@ struct uv_cb_header {
 	u16 rrc;	/* Return Reason Code */
 } __attribute__((packed))  __attribute__((aligned(8)));
 
+struct uv_cb_init {
+	struct uv_cb_header header;
+	u64 reserved08[2];
+	u64 stor_origin;
+	u64 stor_len;
+	u64 reserved28[4];
+
+} __attribute__((packed))  __attribute__((aligned(8)));
+
 struct uv_cb_qui {
 	struct uv_cb_header header;
 	u64 reserved08;
 	u64 inst_calls_list[4];
-	u64 reserved30[15];
+	u64 reserved30[2];
+	u64 uv_base_stor_len;
+	u64 reserved48;
+	u64 conf_base_phys_stor_len;
+	u64 conf_base_virt_stor_len;
+	u64 conf_virt_var_stor_len;
+	u64 cpu_stor_len;
+	u32 reserved70[3];
+	u32 max_num_sec_conf;
+	u64 max_guest_stor_addr;
+	u8  reserved88[158 - 136];
+	u16 max_guest_cpus;
+	u8  reserveda0[200 - 160];
+}  __attribute__((packed))  __attribute__((aligned(8)));
+
+struct uv_cb_cgc {
+	struct uv_cb_header header;
+	u64 reserved08[2];
+	u64 guest_handle;
+	u64 conf_base_stor_origin;
+	u64 conf_var_stor_origin;
+	u64 reserved30;
+	u64 guest_stor_origin;
+	u64 guest_stor_len;
+	u64 guest_sca;
+	u64 guest_asce;
+	u64 reserved60[5];
 } __attribute__((packed))  __attribute__((aligned(8)));
 
+struct uv_cb_csc {
+	struct uv_cb_header header;
+	u64 reserved08[2];
+	u64 cpu_handle;
+	u64 guest_handle;
+	u64 stor_origin;
+	u8  reserved30[6];
+	u16 num;
+	u64 state_origin;
+	u64 reserved[4];
+} __attribute__((packed))  __attribute__((aligned(8)));
+
+struct uv_cb_unp {
+	struct uv_cb_header header;
+	u64 reserved08[2];
+	u64 guest_handle;
+	u64 gaddr;
+	u64 tweak[2];
+	u64 reserved38[3];
+} __attribute__((packed))  __attribute__((aligned(8)));
+
+/*
+ * A common UV call struct for the following calls:
+ * Destroy cpu/config
+ * Verify
+ */
+struct uv_cb_nodata {
+	struct uv_cb_header header;
+	u64 reserved08[2];
+	u64 handle;
+	u64 reserved20[4];
+}  __attribute__((packed))  __attribute__((aligned(8)));
+
 struct uv_cb_share {
 	struct uv_cb_header header;
 	u64 reserved08[3];
@@ -50,6 +156,32 @@ struct uv_cb_share {
 	u64 reserved28;
 } __attribute__((packed))  __attribute__((aligned(8)));
 
+/* Convert to Secure */
+struct uv_cb_cts {
+	struct uv_cb_header header;
+	u64 reserved08[2];
+	u64 guest_handle;
+	u64 gaddr;
+}  __attribute__((packed))  __attribute__((aligned(8)));
+
+/* Convert from Secure / Pin Page Shared */
+struct uv_cb_cfs {
+	struct uv_cb_header header;
+	u64 reserved08[2];
+	u64 paddr;
+}  __attribute__((packed))  __attribute__((aligned(8)));
+
+/* Set Secure Config Parameter */
+struct uv_cb_ssc {
+	struct uv_cb_header header;
+	u64 reserved08[2];
+	u64 guest_handle;
+	u64 sec_header_origin;
+	u32 sec_header_len;
+	u32 reserved2c;
+	u64 reserved30[4];
+} __attribute__((packed))  __attribute__((aligned(8)));
+
 static inline int uv_call_once(unsigned long r1, unsigned long r2)
 {
 	int cc;
@@ -118,4 +250,18 @@ static inline int uv_remove_shared(unsigned long addr)
 	return share(addr, UVC_CMD_REMOVE_SHARED_ACCESS);
 }
 
+struct uv_cb_cpu_set_state {
+	struct uv_cb_header header;
+	u64 reserved08[2];
+	u64 cpu_handle;
+	u8  reserved20[7];
+	u8  state;
+	u64 reserved28[5];
+};
+
+#define PV_CPU_STATE_OPR	1
+#define PV_CPU_STATE_STP	2
+#define PV_CPU_STATE_CHKSTP	3
+#define PV_CPU_STATE_OPR_LOAD	5
+
 #endif
diff --git a/s390x/uv-guest.c b/s390x/uv-guest.c
index a13669ab..393d7f5c 100644
--- a/s390x/uv-guest.c
+++ b/s390x/uv-guest.c
@@ -59,7 +59,8 @@ static void test_query(void)
 {
 	struct uv_cb_qui uvcb = {
 		.header.cmd = UVC_CMD_QUI,
-		.header.len = sizeof(uvcb) - 8,
+		/* A dword below the minimum length */
+		.header.len = 0xa0,
 	};
 	int cc;
 

From patchwork Wed May 19 07:40:19 2021
Content-Type: text/plain; charset="utf-8"
MIME-Version: 1.0
Content-Transfer-Encoding: 7bit
X-Patchwork-Submitter: Janosch Frank <frankja@linux.ibm.com>
X-Patchwork-Id: 12266607
Return-Path: <kvm-owner@kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-16.8 required=3.0 tests=BAYES_00,DKIM_SIGNED,
	DKIM_VALID,HEADER_FROM_DIFFERENT_DOMAINS,INCLUDES_CR_TRAILER,INCLUDES_PATCH,
	MAILING_LIST_MULTI,SPF_HELO_NONE,SPF_PASS,USER_AGENT_GIT autolearn=ham
	autolearn_force=no version=3.4.0
Received: from mail.kernel.org (mail.kernel.org [198.145.29.99])
	by smtp.lore.kernel.org (Postfix) with ESMTP id ABBF0C43460
	for <kvm@archiver.kernel.org>; Wed, 19 May 2021 08:07:34 +0000 (UTC)
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by mail.kernel.org (Postfix) with ESMTP id 8599561007
	for <kvm@archiver.kernel.org>; Wed, 19 May 2021 08:07:34 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S236881AbhESIIx (ORCPT <rfc822;kvm@archiver.kernel.org>);
        Wed, 19 May 2021 04:08:53 -0400
Received: from mx0a-001b2d01.pphosted.com ([148.163.156.1]:17480 "EHLO
        mx0a-001b2d01.pphosted.com" rhost-flags-OK-OK-OK-OK)
        by vger.kernel.org with ESMTP id S236657AbhESIIw (ORCPT
        <rfc822;kvm@vger.kernel.org>); Wed, 19 May 2021 04:08:52 -0400
Received: from pps.filterd (m0098394.ppops.net [127.0.0.1])
        by mx0a-001b2d01.pphosted.com (8.16.0.43/8.16.0.43) with SMTP id
 14J83Tnl171535;
        Wed, 19 May 2021 04:07:33 -0400
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=ibm.com;
 h=from : to : cc : subject
 : date : message-id : in-reply-to : references : mime-version :
 content-transfer-encoding; s=pp1;
 bh=O+Ds6cjm8JlScC1POEZ5H1raQcPZpgLxoHngYy0pzYs=;
 b=CDh20TdjwUGbyHA6TH5tDOc9/uk+nXvQmabXj5dvIW0R9I3uHpuF0dE0qYUUSOL2H91r
 3MXYRCBfJridxKqYg/RTLMOZXWqjI91DyFFmv1AaXHmnXPVU7hlft18VcMQJDdCqo4iX
 sYhKEeQQZvvNXlYr1GWKrdZn/pvMRlqSK9Rx5kBbNnLAm2mgFWlWTM5QTBaeA4VdYzQh
 CbDZ3+45jUOsJ47u9WhRrtTrF5fNrIJ/7y9pF/wilNfMtcYIZG8LuVv67hXyFOgL2Em0
 EZGORM638WseMuYUcyz4Z/eJo2okYyVRRnNjKUexvKg8GGQRtkEnCCNfxhL3G5EYmuNv xQ==
Received: from pps.reinject (localhost [127.0.0.1])
        by mx0a-001b2d01.pphosted.com with ESMTP id 38mxryr9p5-1
        (version=TLSv1.2 cipher=ECDHE-RSA-AES256-GCM-SHA384 bits=256
 verify=NOT);
        Wed, 19 May 2021 04:07:32 -0400
Received: from m0098394.ppops.net (m0098394.ppops.net [127.0.0.1])
        by pps.reinject (8.16.0.43/8.16.0.43) with SMTP id 14J83V8D171692;
        Wed, 19 May 2021 04:07:31 -0400
Received: from ppma03fra.de.ibm.com (6b.4a.5195.ip4.static.sl-reverse.com
 [149.81.74.107])
        by mx0a-001b2d01.pphosted.com with ESMTP id 38mxryr9mw-1
        (version=TLSv1.2 cipher=ECDHE-RSA-AES256-GCM-SHA384 bits=256
 verify=NOT);
        Wed, 19 May 2021 04:07:31 -0400
Received: from pps.filterd (ppma03fra.de.ibm.com [127.0.0.1])
        by ppma03fra.de.ibm.com (8.16.0.43/8.16.0.43) with SMTP id
 14J7cD4n025866;
        Wed, 19 May 2021 07:40:41 GMT
Received: from b06avi18626390.portsmouth.uk.ibm.com
 (b06avi18626390.portsmouth.uk.ibm.com [9.149.26.192])
        by ppma03fra.de.ibm.com with ESMTP id 38j5x892gj-1
        (version=TLSv1.2 cipher=ECDHE-RSA-AES256-GCM-SHA384 bits=256
 verify=NOT);
        Wed, 19 May 2021 07:40:41 +0000
Received: from b06wcsmtp001.portsmouth.uk.ibm.com
 (b06wcsmtp001.portsmouth.uk.ibm.com [9.149.105.160])
        by b06avi18626390.portsmouth.uk.ibm.com (8.14.9/8.14.9/NCO v10.0) with
 ESMTP id 14J7eARH34799876
        (version=TLSv1/SSLv3 cipher=DHE-RSA-AES256-GCM-SHA384 bits=256
 verify=OK);
        Wed, 19 May 2021 07:40:10 GMT
Received: from b06wcsmtp001.portsmouth.uk.ibm.com (unknown [127.0.0.1])
        by IMSVA (Postfix) with ESMTP id 44FCBA405C;
        Wed, 19 May 2021 07:40:38 +0000 (GMT)
Received: from b06wcsmtp001.portsmouth.uk.ibm.com (unknown [127.0.0.1])
        by IMSVA (Postfix) with ESMTP id 80FE2A4060;
        Wed, 19 May 2021 07:40:37 +0000 (GMT)
Received: from linux01.pok.stglabs.ibm.com (unknown [9.114.17.81])
        by b06wcsmtp001.portsmouth.uk.ibm.com (Postfix) with ESMTP;
        Wed, 19 May 2021 07:40:37 +0000 (GMT)
From: Janosch Frank <frankja@linux.ibm.com>
To: kvm@vger.kernel.org
Cc: frankja@linux.ibm.com, david@redhat.com, cohuck@redhat.com,
        linux-s390@vger.kernel.org, imbrenda@linux.ibm.com,
        thuth@redhat.com
Subject: [kvm-unit-tests PATCH v3 3/6] s390x: uv: Add UV lib
Date: Wed, 19 May 2021 07:40:19 +0000
Message-Id: <20210519074022.7368-4-frankja@linux.ibm.com>
X-Mailer: git-send-email 2.30.2
In-Reply-To: <20210519074022.7368-1-frankja@linux.ibm.com>
References: <20210519074022.7368-1-frankja@linux.ibm.com>
MIME-Version: 1.0
X-TM-AS-GCONF: 00
X-Proofpoint-GUID: VF4UiOX5Iig2NPt7YQ6zePuGkSAaOO0v
X-Proofpoint-ORIG-GUID: uXxy-NbV36c6MG9UsEtksSJ8q98t_nBW
X-Proofpoint-Virus-Version: vendor=fsecure engine=2.50.10434:6.0.391,18.0.761
 definitions=2021-05-19_02:2021-05-18,2021-05-19 signatures=0
X-Proofpoint-Spam-Details: rule=outbound_notspam policy=outbound score=0
 priorityscore=1501
 impostorscore=0 lowpriorityscore=0 phishscore=0 suspectscore=0
 adultscore=0 mlxlogscore=999 spamscore=0 clxscore=1015 mlxscore=0
 bulkscore=0 malwarescore=0 classifier=spam adjust=0 reason=mlx scancount=1
 engine=8.12.0-2104190000 definitions=main-2105190059
Precedence: bulk
List-ID: <kvm.vger.kernel.org>
X-Mailing-List: kvm@vger.kernel.org

Lets add a UV library to make checking the UV feature bit easier.
In the future this library file can take care of handling UV
initialization and UV guest creation.

Signed-off-by: Janosch Frank <frankja@linux.ibm.com>
Reviewed-by: Claudio Imbrenda <imbrenda@linux.ibm.com>
Reviewed-by: Cornelia Huck <cohuck@redhat.com>
---
 lib/s390x/asm/uv.h |  4 ++--
 lib/s390x/io.c     |  2 ++
 lib/s390x/uv.c     | 45 +++++++++++++++++++++++++++++++++++++++++++++
 lib/s390x/uv.h     | 10 ++++++++++
 s390x/Makefile     |  1 +
 5 files changed, 60 insertions(+), 2 deletions(-)
 create mode 100644 lib/s390x/uv.c
 create mode 100644 lib/s390x/uv.h

diff --git a/lib/s390x/asm/uv.h b/lib/s390x/asm/uv.h
index 11f70a9f..b22cbaa8 100644
--- a/lib/s390x/asm/uv.h
+++ b/lib/s390x/asm/uv.h
@@ -9,8 +9,8 @@
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2.
  */
-#ifndef UV_H
-#define UV_H
+#ifndef ASM_S390X_UV_H
+#define ASM_S390X_UV_H
 
 #define UVC_RC_EXECUTED		0x0001
 #define UVC_RC_INV_CMD		0x0002
diff --git a/lib/s390x/io.c b/lib/s390x/io.c
index ef9f59e3..a4f1b113 100644
--- a/lib/s390x/io.c
+++ b/lib/s390x/io.c
@@ -14,6 +14,7 @@
 #include <asm/facility.h>
 #include <asm/sigp.h>
 #include "sclp.h"
+#include "uv.h"
 #include "smp.h"
 
 extern char ipl_args[];
@@ -38,6 +39,7 @@ void setup(void)
 	sclp_facilities_setup();
 	sclp_console_setup();
 	sclp_memory_setup();
+	uv_setup();
 	smp_setup();
 }
 
diff --git a/lib/s390x/uv.c b/lib/s390x/uv.c
new file mode 100644
index 00000000..0d8c141c
--- /dev/null
+++ b/lib/s390x/uv.c
@@ -0,0 +1,45 @@
+#include <libcflat.h>
+#include <bitops.h>
+#include <alloc.h>
+#include <alloc_page.h>
+#include <asm/page.h>
+#include <asm/arch_def.h>
+
+#include <asm/facility.h>
+#include <asm/uv.h>
+#include <uv.h>
+
+static struct uv_cb_qui uvcb_qui = {
+	.header.cmd = UVC_CMD_QUI,
+	.header.len = sizeof(uvcb_qui),
+};
+
+bool uv_os_is_guest(void)
+{
+	return test_facility(158) &&
+		uv_query_test_call(BIT_UVC_CMD_SET_SHARED_ACCESS) &&
+		uv_query_test_call(BIT_UVC_CMD_REMOVE_SHARED_ACCESS);
+}
+
+bool uv_os_is_host(void)
+{
+	return test_facility(158) && uv_query_test_call(BIT_UVC_CMD_INIT_UV);
+}
+
+bool uv_query_test_call(unsigned int nr)
+{
+	/* Query needs to be called first */
+	assert(uvcb_qui.header.rc);
+	assert(nr < BITS_PER_LONG * ARRAY_SIZE(uvcb_qui.inst_calls_list));
+
+	return test_bit_inv(nr, uvcb_qui.inst_calls_list);
+}
+
+int uv_setup(void)
+{
+	if (!test_facility(158))
+		return 0;
+
+	assert(!uv_call(0, (u64)&uvcb_qui));
+	return 1;
+}
diff --git a/lib/s390x/uv.h b/lib/s390x/uv.h
new file mode 100644
index 00000000..42608a96
--- /dev/null
+++ b/lib/s390x/uv.h
@@ -0,0 +1,10 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+#ifndef UV_H
+#define UV_H
+
+bool uv_os_is_guest(void);
+bool uv_os_is_host(void);
+bool uv_query_test_call(unsigned int nr);
+int uv_setup(void);
+
+#endif /* UV_H */
diff --git a/s390x/Makefile b/s390x/Makefile
index b92de9c5..bbf177fa 100644
--- a/s390x/Makefile
+++ b/s390x/Makefile
@@ -67,6 +67,7 @@ cflatobjs += lib/s390x/vm.o
 cflatobjs += lib/s390x/css_dump.o
 cflatobjs += lib/s390x/css_lib.o
 cflatobjs += lib/s390x/malloc_io.o
+cflatobjs += lib/s390x/uv.o
 
 OBJDIRS += lib/s390x
 

From patchwork Wed May 19 07:40:20 2021
Content-Type: text/plain; charset="utf-8"
MIME-Version: 1.0
Content-Transfer-Encoding: 7bit
X-Patchwork-Submitter: Janosch Frank <frankja@linux.ibm.com>
X-Patchwork-Id: 12266609
Return-Path: <kvm-owner@kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-16.8 required=3.0 tests=BAYES_00,DKIM_SIGNED,
	DKIM_VALID,HEADER_FROM_DIFFERENT_DOMAINS,INCLUDES_CR_TRAILER,INCLUDES_PATCH,
	MAILING_LIST_MULTI,SPF_HELO_NONE,SPF_PASS,USER_AGENT_GIT
	autolearn=unavailable autolearn_force=no version=3.4.0
Received: from mail.kernel.org (mail.kernel.org [198.145.29.99])
	by smtp.lore.kernel.org (Postfix) with ESMTP id C574AC433B4
	for <kvm@archiver.kernel.org>; Wed, 19 May 2021 08:08:46 +0000 (UTC)
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by mail.kernel.org (Postfix) with ESMTP id A8CA661353
	for <kvm@archiver.kernel.org>; Wed, 19 May 2021 08:08:46 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S242074AbhESIKE (ORCPT <rfc822;kvm@archiver.kernel.org>);
        Wed, 19 May 2021 04:10:04 -0400
Received: from mx0b-001b2d01.pphosted.com ([148.163.158.5]:10220 "EHLO
        mx0a-001b2d01.pphosted.com" rhost-flags-OK-OK-OK-FAIL)
        by vger.kernel.org with ESMTP id S236275AbhESIKD (ORCPT
        <rfc822;kvm@vger.kernel.org>); Wed, 19 May 2021 04:10:03 -0400
Received: from pps.filterd (m0098414.ppops.net [127.0.0.1])
        by mx0b-001b2d01.pphosted.com (8.16.0.43/8.16.0.43) with SMTP id
 14J84wd6075432;
        Wed, 19 May 2021 04:08:44 -0400
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=ibm.com;
 h=from : to : cc : subject
 : date : message-id : in-reply-to : references : mime-version :
 content-transfer-encoding; s=pp1;
 bh=zpGtZL01x4yDcHLJjhNGLfaKG3fkyzEMKL400SkQQkU=;
 b=Sr494fCKq3fCZaG/zOmJHzyiJvVoTFdLfiEoREblaROYNaf78H0N/LYAjiDPYJWJimvd
 I3bcBsj9VdsrWbl6eYE72GDOVOKiPPlQ7M/1BYkAJGxiS3ssW3SPFiKVp8eQW4MNvqZd
 J7Ow7EwluDu4R5r2gU0aw5BMjh7NkYSXXRMJW2QudIPpGuTo6HZlZI8J09bJOMLkGfpe
 bN0RmXJ/h4dagSQ/KEPLcFRGu+9JRGa5FOSNyzRiRat6gQWzE1tbIfQ27kWN+56Req8b
 Iu2terXAMHh8DAaGuWvn4q529fbEpgNFOEixhoHj4BibI1ZaJF6a9m16Xx1KPsbubJxu uw==
Received: from pps.reinject (localhost [127.0.0.1])
        by mx0b-001b2d01.pphosted.com with ESMTP id 38mxn48fjg-1
        (version=TLSv1.2 cipher=ECDHE-RSA-AES256-GCM-SHA384 bits=256
 verify=NOT);
        Wed, 19 May 2021 04:08:44 -0400
Received: from m0098414.ppops.net (m0098414.ppops.net [127.0.0.1])
        by pps.reinject (8.16.0.43/8.16.0.43) with SMTP id 14J8589J076526;
        Wed, 19 May 2021 04:08:43 -0400
Received: from ppma06ams.nl.ibm.com (66.31.33a9.ip4.static.sl-reverse.com
 [169.51.49.102])
        by mx0b-001b2d01.pphosted.com with ESMTP id 38mxn48fhd-2
        (version=TLSv1.2 cipher=ECDHE-RSA-AES256-GCM-SHA384 bits=256
 verify=NOT);
        Wed, 19 May 2021 04:08:43 -0400
Received: from pps.filterd (ppma06ams.nl.ibm.com [127.0.0.1])
        by ppma06ams.nl.ibm.com (8.16.0.43/8.16.0.43) with SMTP id
 14J7bhMS018508;
        Wed, 19 May 2021 07:40:42 GMT
Received: from b06cxnps3075.portsmouth.uk.ibm.com
 (d06relay10.portsmouth.uk.ibm.com [9.149.109.195])
        by ppma06ams.nl.ibm.com with ESMTP id 38j5jgsxe7-1
        (version=TLSv1.2 cipher=ECDHE-RSA-AES256-GCM-SHA384 bits=256
 verify=NOT);
        Wed, 19 May 2021 07:40:42 +0000
Received: from b06wcsmtp001.portsmouth.uk.ibm.com
 (b06wcsmtp001.portsmouth.uk.ibm.com [9.149.105.160])
        by b06cxnps3075.portsmouth.uk.ibm.com (8.14.9/8.14.9/NCO v10.0) with
 ESMTP id 14J7edkC31982026
        (version=TLSv1/SSLv3 cipher=DHE-RSA-AES256-GCM-SHA384 bits=256
 verify=OK);
        Wed, 19 May 2021 07:40:39 GMT
Received: from b06wcsmtp001.portsmouth.uk.ibm.com (unknown [127.0.0.1])
        by IMSVA (Postfix) with ESMTP id 2D8CFA4064;
        Wed, 19 May 2021 07:40:39 +0000 (GMT)
Received: from b06wcsmtp001.portsmouth.uk.ibm.com (unknown [127.0.0.1])
        by IMSVA (Postfix) with ESMTP id 6ACE1A405C;
        Wed, 19 May 2021 07:40:38 +0000 (GMT)
Received: from linux01.pok.stglabs.ibm.com (unknown [9.114.17.81])
        by b06wcsmtp001.portsmouth.uk.ibm.com (Postfix) with ESMTP;
        Wed, 19 May 2021 07:40:38 +0000 (GMT)
From: Janosch Frank <frankja@linux.ibm.com>
To: kvm@vger.kernel.org
Cc: frankja@linux.ibm.com, david@redhat.com, cohuck@redhat.com,
        linux-s390@vger.kernel.org, imbrenda@linux.ibm.com,
        thuth@redhat.com
Subject: [kvm-unit-tests PATCH v3 4/6] s390x: Test for share/unshare call
 support before using them
Date: Wed, 19 May 2021 07:40:20 +0000
Message-Id: <20210519074022.7368-5-frankja@linux.ibm.com>
X-Mailer: git-send-email 2.30.2
In-Reply-To: <20210519074022.7368-1-frankja@linux.ibm.com>
References: <20210519074022.7368-1-frankja@linux.ibm.com>
MIME-Version: 1.0
X-TM-AS-GCONF: 00
X-Proofpoint-ORIG-GUID: 42XEBzLrLpmx90qNmMRrt7ODnzjxCdfl
X-Proofpoint-GUID: U8ixECp30DB29FZiTDslUPF0UlBGllwU
X-Proofpoint-Virus-Version: vendor=fsecure engine=2.50.10434:6.0.391,18.0.761
 definitions=2021-05-19_02:2021-05-18,2021-05-19 signatures=0
X-Proofpoint-Spam-Details: rule=outbound_notspam policy=outbound score=0
 priorityscore=1501
 clxscore=1015 suspectscore=0 impostorscore=0 lowpriorityscore=0
 bulkscore=0 mlxlogscore=999 phishscore=0 mlxscore=0 spamscore=0
 adultscore=0 malwarescore=0 classifier=spam adjust=0 reason=mlx
 scancount=1 engine=8.12.0-2104190000 definitions=main-2105190059
Precedence: bulk
List-ID: <kvm.vger.kernel.org>
X-Mailing-List: kvm@vger.kernel.org

Testing for facility only means the UV Call facility is available.
The UV will only indicate the share/unshare calls for a protected
guest 2, so let's also check that.

Signed-off-by: Janosch Frank <frankja@linux.ibm.com>
Reviewed-by: Claudio Imbrenda <imbrenda@linux.ibm.com>
Reviewed-by: Cornelia Huck <cohuck@redhat.com>
---
 lib/s390x/malloc_io.c | 5 +++--
 s390x/uv-guest.c      | 6 ++++++
 2 files changed, 9 insertions(+), 2 deletions(-)

diff --git a/lib/s390x/malloc_io.c b/lib/s390x/malloc_io.c
index 1dcf1691..78582eac 100644
--- a/lib/s390x/malloc_io.c
+++ b/lib/s390x/malloc_io.c
@@ -19,6 +19,7 @@
 #include <alloc_page.h>
 #include <asm/facility.h>
 #include <bitops.h>
+#include <uv.h>
 
 static int share_pages(void *p, int count)
 {
@@ -47,7 +48,7 @@ void *alloc_io_mem(int size, int flags)
 	assert(size);
 
 	p = alloc_pages_flags(order, AREA_DMA31 | flags);
-	if (!p || !test_facility(158))
+	if (!p || !uv_os_is_guest())
 		return p;
 
 	n = share_pages(p, 1 << order);
@@ -65,7 +66,7 @@ void free_io_mem(void *p, int size)
 
 	assert(IS_ALIGNED((uintptr_t)p, PAGE_SIZE));
 
-	if (test_facility(158))
+	if (uv_os_is_guest())
 		unshare_pages(p, 1 << order);
 	free_pages(p);
 }
diff --git a/s390x/uv-guest.c b/s390x/uv-guest.c
index 393d7f5c..e99029a7 100644
--- a/s390x/uv-guest.c
+++ b/s390x/uv-guest.c
@@ -16,6 +16,7 @@
 #include <asm/facility.h>
 #include <asm/uv.h>
 #include <sclp.h>
+#include <uv.h>
 
 static unsigned long page;
 
@@ -142,6 +143,11 @@ int main(void)
 		goto done;
 	}
 
+	if (!uv_os_is_guest()) {
+		report_skip("Not a protected guest");
+		goto done;
+	}
+
 	page = (unsigned long)alloc_page();
 	test_priv();
 	test_invalid();

From patchwork Wed May 19 07:40:21 2021
Content-Type: text/plain; charset="utf-8"
MIME-Version: 1.0
Content-Transfer-Encoding: 7bit
X-Patchwork-Submitter: Janosch Frank <frankja@linux.ibm.com>
X-Patchwork-Id: 12266611
Return-Path: <kvm-owner@kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-16.8 required=3.0 tests=BAYES_00,DKIM_SIGNED,
	DKIM_VALID,HEADER_FROM_DIFFERENT_DOMAINS,INCLUDES_CR_TRAILER,INCLUDES_PATCH,
	MAILING_LIST_MULTI,SPF_HELO_NONE,SPF_PASS,USER_AGENT_GIT autolearn=ham
	autolearn_force=no version=3.4.0
Received: from mail.kernel.org (mail.kernel.org [198.145.29.99])
	by smtp.lore.kernel.org (Postfix) with ESMTP id 66D6BC43460
	for <kvm@archiver.kernel.org>; Wed, 19 May 2021 08:08:47 +0000 (UTC)
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by mail.kernel.org (Postfix) with ESMTP id 4BA6B61007
	for <kvm@archiver.kernel.org>; Wed, 19 May 2021 08:08:47 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S243695AbhESIKF (ORCPT <rfc822;kvm@archiver.kernel.org>);
        Wed, 19 May 2021 04:10:05 -0400
Received: from mx0b-001b2d01.pphosted.com ([148.163.158.5]:13862 "EHLO
        mx0b-001b2d01.pphosted.com" rhost-flags-OK-OK-OK-OK)
        by vger.kernel.org with ESMTP id S240902AbhESIKE (ORCPT
        <rfc822;kvm@vger.kernel.org>); Wed, 19 May 2021 04:10:04 -0400
Received: from pps.filterd (m0127361.ppops.net [127.0.0.1])
        by mx0a-001b2d01.pphosted.com (8.16.0.43/8.16.0.43) with SMTP id
 14J83obQ073817;
        Wed, 19 May 2021 04:08:45 -0400
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=ibm.com;
 h=from : to : cc : subject
 : date : message-id : in-reply-to : references : mime-version :
 content-transfer-encoding; s=pp1;
 bh=mFALUa3fuajBPiOvzejYEozmKRmPbbix5gf/S6TPx3o=;
 b=Htr8z2jrjtuSqxQs7VB3LHikEho1ubNOtoqp2ZhpXEyg23Wo5GYGT7xf/htjsXtUGvQc
 i8+sC8i0oDDxsyYBTryr69vIsuy9DP7Gr4nJJWQljuPY+WE81gfb4xTKMPyb4AKFoAU8
 eGKbnmdxWd2VHP0AqYz11kUHD8LCZUxx+TgqZR1tiFhBxK52/u9PLFQz7Osoy4+QV8O0
 8KkiNJV78lerA4rXiy9ySbo0SEnUEBx5qOGuJ9Ud0vt40LBKi/Jro9R/89ZlbbDXSpGc
 ytKxUWJzuClBr4dJ6MZfo0sijePl4H+dVccioNshSi6c7VEKp7xt+BPGM6bBIlOuy7pR Og==
Received: from pps.reinject (localhost [127.0.0.1])
        by mx0a-001b2d01.pphosted.com with ESMTP id 38mxj10n65-1
        (version=TLSv1.2 cipher=ECDHE-RSA-AES256-GCM-SHA384 bits=256
 verify=NOT);
        Wed, 19 May 2021 04:08:44 -0400
Received: from m0127361.ppops.net (m0127361.ppops.net [127.0.0.1])
        by pps.reinject (8.16.0.43/8.16.0.43) with SMTP id 14J84RUi079001;
        Wed, 19 May 2021 04:08:44 -0400
Received: from ppma06ams.nl.ibm.com (66.31.33a9.ip4.static.sl-reverse.com
 [169.51.49.102])
        by mx0a-001b2d01.pphosted.com with ESMTP id 38mxj10n43-3
        (version=TLSv1.2 cipher=ECDHE-RSA-AES256-GCM-SHA384 bits=256
 verify=NOT);
        Wed, 19 May 2021 04:08:44 -0400
Received: from pps.filterd (ppma06ams.nl.ibm.com [127.0.0.1])
        by ppma06ams.nl.ibm.com (8.16.0.43/8.16.0.43) with SMTP id
 14J7bXPK018342;
        Wed, 19 May 2021 07:40:43 GMT
Received: from b06cxnps4074.portsmouth.uk.ibm.com
 (d06relay11.portsmouth.uk.ibm.com [9.149.109.196])
        by ppma06ams.nl.ibm.com with ESMTP id 38j5jgsxe8-1
        (version=TLSv1.2 cipher=ECDHE-RSA-AES256-GCM-SHA384 bits=256
 verify=NOT);
        Wed, 19 May 2021 07:40:42 +0000
Received: from b06wcsmtp001.portsmouth.uk.ibm.com
 (b06wcsmtp001.portsmouth.uk.ibm.com [9.149.105.160])
        by b06cxnps4074.portsmouth.uk.ibm.com (8.14.9/8.14.9/NCO v10.0) with
 ESMTP id 14J7ee7V37290342
        (version=TLSv1/SSLv3 cipher=DHE-RSA-AES256-GCM-SHA384 bits=256
 verify=OK);
        Wed, 19 May 2021 07:40:40 GMT
Received: from b06wcsmtp001.portsmouth.uk.ibm.com (unknown [127.0.0.1])
        by IMSVA (Postfix) with ESMTP id 176B3A405F;
        Wed, 19 May 2021 07:40:40 +0000 (GMT)
Received: from b06wcsmtp001.portsmouth.uk.ibm.com (unknown [127.0.0.1])
        by IMSVA (Postfix) with ESMTP id 53D04A4054;
        Wed, 19 May 2021 07:40:39 +0000 (GMT)
Received: from linux01.pok.stglabs.ibm.com (unknown [9.114.17.81])
        by b06wcsmtp001.portsmouth.uk.ibm.com (Postfix) with ESMTP;
        Wed, 19 May 2021 07:40:39 +0000 (GMT)
From: Janosch Frank <frankja@linux.ibm.com>
To: kvm@vger.kernel.org
Cc: frankja@linux.ibm.com, david@redhat.com, cohuck@redhat.com,
        linux-s390@vger.kernel.org, imbrenda@linux.ibm.com,
        thuth@redhat.com
Subject: [kvm-unit-tests PATCH v3 5/6] s390x: uv-guest: Test invalid commands
Date: Wed, 19 May 2021 07:40:21 +0000
Message-Id: <20210519074022.7368-6-frankja@linux.ibm.com>
X-Mailer: git-send-email 2.30.2
In-Reply-To: <20210519074022.7368-1-frankja@linux.ibm.com>
References: <20210519074022.7368-1-frankja@linux.ibm.com>
MIME-Version: 1.0
X-TM-AS-GCONF: 00
X-Proofpoint-GUID: E_UfDJHzegGhQol49iTOlTf-GwIhdHnI
X-Proofpoint-ORIG-GUID: HdpMKJISutn9qp8IRG9MBtEkvlCmbJ_d
X-Proofpoint-Virus-Version: vendor=fsecure engine=2.50.10434:6.0.391,18.0.761
 definitions=2021-05-19_02:2021-05-18,2021-05-19 signatures=0
X-Proofpoint-Spam-Details: rule=outbound_notspam policy=outbound score=0
 priorityscore=1501
 malwarescore=0 mlxlogscore=999 impostorscore=0 adultscore=0 bulkscore=0
 clxscore=1015 suspectscore=0 mlxscore=0 spamscore=0 lowpriorityscore=0
 phishscore=0 classifier=spam adjust=0 reason=mlx scancount=1
 engine=8.12.0-2104190000 definitions=main-2105190059
Precedence: bulk
List-ID: <kvm.vger.kernel.org>
X-Mailing-List: kvm@vger.kernel.org

Let's check if the UV calls that should not be available in a
protected guest 2 are actually not available. Also let's check if they
are falsely indicated to be available.

Signed-off-by: Janosch Frank <frankja@linux.ibm.com>
Reviewed-by: Cornelia Huck <cohuck@redhat.com>
Reviewed-by: Claudio Imbrenda <imbrenda@linux.ibm.com>
---
 s390x/uv-guest.c | 46 +++++++++++++++++++++++++++++++++++++++-------
 1 file changed, 39 insertions(+), 7 deletions(-)

diff --git a/s390x/uv-guest.c b/s390x/uv-guest.c
index e99029a7..f05ae4c3 100644
--- a/s390x/uv-guest.c
+++ b/s390x/uv-guest.c
@@ -121,16 +121,48 @@ static void test_sharing(void)
 	report_prefix_pop();
 }
 
+static struct {
+	const char *name;
+	uint16_t cmd;
+	uint16_t len;
+	int call_bit;
+} invalid_cmds[] = {
+	{ "bogus", 0x4242, sizeof(struct uv_cb_header), -1 },
+	{ "init", UVC_CMD_INIT_UV, sizeof(struct uv_cb_init), BIT_UVC_CMD_INIT_UV },
+	{ "create conf", UVC_CMD_CREATE_SEC_CONF, sizeof(struct uv_cb_cgc), BIT_UVC_CMD_CREATE_SEC_CONF },
+	{ "destroy conf", UVC_CMD_DESTROY_SEC_CONF, sizeof(struct uv_cb_nodata), BIT_UVC_CMD_DESTROY_SEC_CONF },
+	{ "create cpu", UVC_CMD_CREATE_SEC_CPU, sizeof(struct uv_cb_csc), BIT_UVC_CMD_CREATE_SEC_CPU },
+	{ "destroy cpu", UVC_CMD_DESTROY_SEC_CPU, sizeof(struct uv_cb_nodata), BIT_UVC_CMD_DESTROY_SEC_CPU },
+	{ "conv to", UVC_CMD_CONV_TO_SEC_STOR, sizeof(struct uv_cb_cts), BIT_UVC_CMD_CONV_TO_SEC_STOR },
+	{ "conv from", UVC_CMD_CONV_FROM_SEC_STOR, sizeof(struct uv_cb_cfs), BIT_UVC_CMD_CONV_FROM_SEC_STOR },
+	{ "set sec conf", UVC_CMD_SET_SEC_CONF_PARAMS, sizeof(struct uv_cb_ssc), BIT_UVC_CMD_SET_SEC_PARMS },
+	{ "unpack", UVC_CMD_UNPACK_IMG, sizeof(struct uv_cb_unp), BIT_UVC_CMD_UNPACK_IMG },
+	{ "verify", UVC_CMD_VERIFY_IMG, sizeof(struct uv_cb_nodata), BIT_UVC_CMD_VERIFY_IMG },
+	{ "cpu reset", UVC_CMD_CPU_RESET, sizeof(struct uv_cb_nodata), BIT_UVC_CMD_CPU_RESET },
+	{ "cpu initial reset", UVC_CMD_CPU_RESET_INITIAL, sizeof(struct uv_cb_nodata), BIT_UVC_CMD_CPU_RESET_INITIAL },
+	{ "conf clear reset", UVC_CMD_PERF_CONF_CLEAR_RESET, sizeof(struct uv_cb_nodata), BIT_UVC_CMD_PREPARE_CLEAR_RESET },
+	{ "cpu clear reset", UVC_CMD_CPU_RESET_CLEAR, sizeof(struct uv_cb_nodata), BIT_UVC_CMD_CPU_PERFORM_CLEAR_RESET },
+	{ "cpu set state", UVC_CMD_CPU_SET_STATE, sizeof(struct uv_cb_cpu_set_state), BIT_UVC_CMD_CPU_SET_STATE },
+	{ "pin shared", UVC_CMD_PIN_PAGE_SHARED, sizeof(struct uv_cb_cfs), BIT_UVC_CMD_PIN_PAGE_SHARED },
+	{ "unpin shared", UVC_CMD_UNPIN_PAGE_SHARED, sizeof(struct uv_cb_cts), BIT_UVC_CMD_UNPIN_PAGE_SHARED },
+	{ NULL, 0, 0 },
+};
+
 static void test_invalid(void)
 {
-	struct uv_cb_header uvcb = {
-		.len = 16,
-		.cmd = 0x4242,
-	};
-	int cc;
+	struct uv_cb_header *hdr = (void *)page;
+	int cc, i;
 
-	cc = uv_call(0, (u64)&uvcb);
-	report(cc == 1 && uvcb.rc == UVC_RC_INV_CMD, "invalid command");
+	report_prefix_push("invalid");
+	for (i = 0; invalid_cmds[i].name; i++) {
+		hdr->cmd = invalid_cmds[i].cmd;
+		hdr->len = invalid_cmds[i].len;
+		cc = uv_call(0, (u64)hdr);
+		report(cc == 1 && hdr->rc == UVC_RC_INV_CMD &&
+		       (invalid_cmds[i].call_bit == -1 || !uv_query_test_call(invalid_cmds[i].call_bit)),
+		       "%s", invalid_cmds[i].name);
+	}
+	report_prefix_pop();
 }
 
 int main(void)

From patchwork Wed May 19 07:40:22 2021
Content-Type: text/plain; charset="utf-8"
MIME-Version: 1.0
Content-Transfer-Encoding: 7bit
X-Patchwork-Submitter: Janosch Frank <frankja@linux.ibm.com>
X-Patchwork-Id: 12266505
Return-Path: <kvm-owner@kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-16.8 required=3.0 tests=BAYES_00,DKIM_SIGNED,
	DKIM_VALID,HEADER_FROM_DIFFERENT_DOMAINS,INCLUDES_CR_TRAILER,INCLUDES_PATCH,
	MAILING_LIST_MULTI,SPF_HELO_NONE,SPF_PASS,USER_AGENT_GIT
	autolearn=unavailable autolearn_force=no version=3.4.0
Received: from mail.kernel.org (mail.kernel.org [198.145.29.99])
	by smtp.lore.kernel.org (Postfix) with ESMTP id AD5BCC433B4
	for <kvm@archiver.kernel.org>; Wed, 19 May 2021 07:40:49 +0000 (UTC)
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by mail.kernel.org (Postfix) with ESMTP id 8E2E361244
	for <kvm@archiver.kernel.org>; Wed, 19 May 2021 07:40:49 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S240718AbhESHmH (ORCPT <rfc822;kvm@archiver.kernel.org>);
        Wed, 19 May 2021 03:42:07 -0400
Received: from mx0b-001b2d01.pphosted.com ([148.163.158.5]:39066 "EHLO
        mx0a-001b2d01.pphosted.com" rhost-flags-OK-OK-OK-FAIL)
        by vger.kernel.org with ESMTP id S240620AbhESHmG (ORCPT
        <rfc822;kvm@vger.kernel.org>); Wed, 19 May 2021 03:42:06 -0400
Received: from pps.filterd (m0098413.ppops.net [127.0.0.1])
        by mx0b-001b2d01.pphosted.com (8.16.0.43/8.16.0.43) with SMTP id
 14J7YwUp105831;
        Wed, 19 May 2021 03:40:46 -0400
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=ibm.com;
 h=from : to : cc : subject
 : date : message-id : in-reply-to : references : mime-version :
 content-transfer-encoding; s=pp1;
 bh=bThTQ1Wpivr9h6ESx2ObTmYPBqdaVdJyCLpeVXTxs48=;
 b=GahniPky3xsAntZP/dxJSP23B74u1qtgQP0hmPTygHlexVsapN5ur/ufVfK/8K1dck70
 33U9WPBmdmtBbemDqFN0KwrVU5/JU4PcPeyFd9QXXLeGEESBYla4QWg2hGRfO8/u6vWI
 RyQMNOj2r2cIcgBnpoAHIUL0XR1fXDT4F/+xPVURW0mzQbi4Q1JQ0qA9ex4Ann1U0I+l
 5RyjJdyUPtDVCPVhqv2kjVk5lf5RxdJPrk4NdCrCf82ooqGmx9w/FD/BTVfgxLR55vUr
 sljaYDkAHwTIIgrZEQPXkk4xMt6KeJFrRdO2Wws3sVhzwVoss7SN6KM7XdyxbmChzFit xA==
Received: from pps.reinject (localhost [127.0.0.1])
        by mx0b-001b2d01.pphosted.com with ESMTP id 38mxbs0a1s-1
        (version=TLSv1.2 cipher=ECDHE-RSA-AES256-GCM-SHA384 bits=256
 verify=NOT);
        Wed, 19 May 2021 03:40:46 -0400
Received: from m0098413.ppops.net (m0098413.ppops.net [127.0.0.1])
        by pps.reinject (8.16.0.43/8.16.0.43) with SMTP id 14J7ZMTj107274;
        Wed, 19 May 2021 03:40:46 -0400
Received: from ppma05fra.de.ibm.com (6c.4a.5195.ip4.static.sl-reverse.com
 [149.81.74.108])
        by mx0b-001b2d01.pphosted.com with ESMTP id 38mxbs0a02-1
        (version=TLSv1.2 cipher=ECDHE-RSA-AES256-GCM-SHA384 bits=256
 verify=NOT);
        Wed, 19 May 2021 03:40:45 -0400
Received: from pps.filterd (ppma05fra.de.ibm.com [127.0.0.1])
        by ppma05fra.de.ibm.com (8.16.0.43/8.16.0.43) with SMTP id
 14J7bkGf010075;
        Wed, 19 May 2021 07:40:44 GMT
Received: from b06cxnps3074.portsmouth.uk.ibm.com
 (d06relay09.portsmouth.uk.ibm.com [9.149.109.194])
        by ppma05fra.de.ibm.com with ESMTP id 38m19sreqm-1
        (version=TLSv1.2 cipher=ECDHE-RSA-AES256-GCM-SHA384 bits=256
 verify=NOT);
        Wed, 19 May 2021 07:40:43 +0000
Received: from b06wcsmtp001.portsmouth.uk.ibm.com
 (b06wcsmtp001.portsmouth.uk.ibm.com [9.149.105.160])
        by b06cxnps3074.portsmouth.uk.ibm.com (8.14.9/8.14.9/NCO v10.0) with
 ESMTP id 14J7efma33882560
        (version=TLSv1/SSLv3 cipher=DHE-RSA-AES256-GCM-SHA384 bits=256
 verify=OK);
        Wed, 19 May 2021 07:40:41 GMT
Received: from b06wcsmtp001.portsmouth.uk.ibm.com (unknown [127.0.0.1])
        by IMSVA (Postfix) with ESMTP id 0B0C3A4054;
        Wed, 19 May 2021 07:40:41 +0000 (GMT)
Received: from b06wcsmtp001.portsmouth.uk.ibm.com (unknown [127.0.0.1])
        by IMSVA (Postfix) with ESMTP id 3DD40A405C;
        Wed, 19 May 2021 07:40:40 +0000 (GMT)
Received: from linux01.pok.stglabs.ibm.com (unknown [9.114.17.81])
        by b06wcsmtp001.portsmouth.uk.ibm.com (Postfix) with ESMTP;
        Wed, 19 May 2021 07:40:40 +0000 (GMT)
From: Janosch Frank <frankja@linux.ibm.com>
To: kvm@vger.kernel.org
Cc: frankja@linux.ibm.com, david@redhat.com, cohuck@redhat.com,
        linux-s390@vger.kernel.org, imbrenda@linux.ibm.com,
        thuth@redhat.com
Subject: [kvm-unit-tests PATCH v3 6/6] s390x: Add UV host test
Date: Wed, 19 May 2021 07:40:22 +0000
Message-Id: <20210519074022.7368-7-frankja@linux.ibm.com>
X-Mailer: git-send-email 2.30.2
In-Reply-To: <20210519074022.7368-1-frankja@linux.ibm.com>
References: <20210519074022.7368-1-frankja@linux.ibm.com>
MIME-Version: 1.0
X-TM-AS-GCONF: 00
X-Proofpoint-GUID: WDwz757QkV4MFPnnRJ09Av9a2XpMncwH
X-Proofpoint-ORIG-GUID: _6--r5jvhChrbDy25EXeex4HpUSE3Rdv
X-Proofpoint-Virus-Version: vendor=fsecure engine=2.50.10434:6.0.391,18.0.761
 definitions=2021-05-19_02:2021-05-18,2021-05-19 signatures=0
X-Proofpoint-Spam-Details: rule=outbound_notspam policy=outbound score=0
 bulkscore=0 impostorscore=0
 clxscore=1015 suspectscore=0 mlxlogscore=999 phishscore=0 mlxscore=0
 spamscore=0 priorityscore=1501 adultscore=0 lowpriorityscore=0
 malwarescore=0 classifier=spam adjust=0 reason=mlx scancount=1
 engine=8.12.0-2104190000 definitions=main-2105190055
Precedence: bulk
List-ID: <kvm.vger.kernel.org>
X-Mailing-List: kvm@vger.kernel.org

Let's also test the UV host interfaces.

Signed-off-by: Janosch Frank <frankja@linux.ibm.com>
Reviewed-by: Claudio Imbrenda <imbrenda@linux.ibm.com>
Acked-by: Cornelia Huck <cohuck@redhat.com>
---
 s390x/Makefile  |   1 +
 s390x/uv-host.c | 480 ++++++++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 481 insertions(+)
 create mode 100644 s390x/uv-host.c

diff --git a/s390x/Makefile b/s390x/Makefile
index bbf177fa..8de926ab 100644
--- a/s390x/Makefile
+++ b/s390x/Makefile
@@ -21,6 +21,7 @@ tests += $(TEST_DIR)/css.elf
 tests += $(TEST_DIR)/uv-guest.elf
 tests += $(TEST_DIR)/sie.elf
 tests += $(TEST_DIR)/mvpg.elf
+tests += $(TEST_DIR)/uv-host.elf
 
 tests_binary = $(patsubst %.elf,%.bin,$(tests))
 ifneq ($(HOST_KEY_DOCUMENT),)
diff --git a/s390x/uv-host.c b/s390x/uv-host.c
new file mode 100644
index 00000000..49c66f17
--- /dev/null
+++ b/s390x/uv-host.c
@@ -0,0 +1,480 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Guest Ultravisor Call tests
+ *
+ * Copyright (c) 2021 IBM Corp
+ *
+ * Authors:
+ *  Janosch Frank <frankja@linux.ibm.com>
+ */
+
+#include <libcflat.h>
+#include <alloc.h>
+#include <vmalloc.h>
+#include <sclp.h>
+#include <smp.h>
+#include <uv.h>
+#include <asm/page.h>
+#include <asm/sigp.h>
+#include <asm/pgtable.h>
+#include <asm/asm-offsets.h>
+#include <asm/interrupt.h>
+#include <asm/facility.h>
+#include <asm/uv.h>
+#include <asm-generic/barrier.h>
+
+static struct uv_cb_qui uvcb_qui;
+static struct uv_cb_init uvcb_init;
+static struct uv_cb_cgc uvcb_cgc;
+static struct uv_cb_csc uvcb_csc;
+
+extern int diag308_load_reset(u64 code);
+
+struct cmd_list{
+	const char *name;
+	uint16_t cmd;
+	uint16_t len;
+	int call_bit;
+};
+
+static void cpu_loop(void)
+{
+	for (;;) {}
+}
+
+static struct cmd_list cmds[] = {
+	{ "init", UVC_CMD_INIT_UV, sizeof(struct uv_cb_init), BIT_UVC_CMD_INIT_UV },
+	{ "create conf", UVC_CMD_CREATE_SEC_CONF, sizeof(struct uv_cb_cgc), BIT_UVC_CMD_CREATE_SEC_CONF },
+	{ "destroy conf", UVC_CMD_DESTROY_SEC_CONF, sizeof(struct uv_cb_nodata), BIT_UVC_CMD_DESTROY_SEC_CONF },
+	{ "create cpu", UVC_CMD_CREATE_SEC_CPU, sizeof(struct uv_cb_csc), BIT_UVC_CMD_CREATE_SEC_CPU },
+	{ "destroy cpu", UVC_CMD_DESTROY_SEC_CPU, sizeof(struct uv_cb_nodata), BIT_UVC_CMD_DESTROY_SEC_CPU },
+	{ "conv to", UVC_CMD_CONV_TO_SEC_STOR, sizeof(struct uv_cb_cts), BIT_UVC_CMD_CONV_TO_SEC_STOR },
+	{ "conv from", UVC_CMD_CONV_FROM_SEC_STOR, sizeof(struct uv_cb_cfs), BIT_UVC_CMD_CONV_FROM_SEC_STOR },
+	{ "set sec conf", UVC_CMD_SET_SEC_CONF_PARAMS, sizeof(struct uv_cb_ssc), BIT_UVC_CMD_SET_SEC_PARMS },
+	{ "unpack", UVC_CMD_UNPACK_IMG, sizeof(struct uv_cb_unp), BIT_UVC_CMD_UNPACK_IMG },
+	{ "verify", UVC_CMD_VERIFY_IMG, sizeof(struct uv_cb_nodata), BIT_UVC_CMD_VERIFY_IMG },
+	{ "cpu reset", UVC_CMD_CPU_RESET, sizeof(struct uv_cb_nodata), BIT_UVC_CMD_CPU_RESET },
+	{ "cpu initial reset", UVC_CMD_CPU_RESET_INITIAL, sizeof(struct uv_cb_nodata), BIT_UVC_CMD_CPU_RESET_INITIAL },
+	{ "conf clear reset", UVC_CMD_PERF_CONF_CLEAR_RESET, sizeof(struct uv_cb_nodata), BIT_UVC_CMD_PREPARE_CLEAR_RESET },
+	{ "cpu clear reset", UVC_CMD_CPU_RESET_CLEAR, sizeof(struct uv_cb_nodata), BIT_UVC_CMD_CPU_PERFORM_CLEAR_RESET },
+	{ "cpu set state", UVC_CMD_CPU_SET_STATE, sizeof(struct uv_cb_cpu_set_state), BIT_UVC_CMD_CPU_SET_STATE },
+	{ "pin shared", UVC_CMD_PIN_PAGE_SHARED, sizeof(struct uv_cb_cfs), BIT_UVC_CMD_PIN_PAGE_SHARED },
+	{ "unpin shared", UVC_CMD_UNPIN_PAGE_SHARED, sizeof(struct uv_cb_cts), BIT_UVC_CMD_UNPIN_PAGE_SHARED },
+	{ NULL, 0, 0 },
+};
+
+static void test_priv(void)
+{
+	struct uv_cb_header uvcb = {};
+	uint16_t pgm;
+	int i;
+
+	report_prefix_push("privileged");
+	for (i = 0; cmds[i].name; i++) {
+		expect_pgm_int();
+		uvcb.cmd = cmds[i].cmd;
+		uvcb.len = cmds[i].len;
+		enter_pstate();
+		uv_call(0, (uint64_t)&uvcb);
+		pgm = clear_pgm_int();
+		report(pgm == PGM_INT_CODE_PRIVILEGED_OPERATION, "%s", cmds[i].name);
+	}
+	report_prefix_pop();
+}
+
+static void test_config_destroy(void)
+{
+	int rc;
+	struct uv_cb_nodata uvcb = {
+		.header.cmd = UVC_CMD_DESTROY_SEC_CONF,
+		.header.len = sizeof(uvcb),
+		.handle = uvcb_cgc.guest_handle,
+	};
+
+	report_prefix_push("dsc");
+	uvcb.header.len -= 8;
+	rc = uv_call(0, (uint64_t)&uvcb);
+	report(rc == 1 && uvcb.header.rc == UVC_RC_INV_LEN,
+	       "hdr invalid length");
+	uvcb.header.len += 8;
+
+	uvcb.handle += 1;
+	rc = uv_call(0, (uint64_t)&uvcb);
+	report(rc == 1 && uvcb.header.rc == UVC_RC_INV_GHANDLE, "invalid handle");
+	uvcb.handle -= 1;
+
+	rc = uv_call(0, (uint64_t)&uvcb);
+	report(rc == 0 && uvcb.header.rc == UVC_RC_EXECUTED, "success");
+	report_prefix_pop();
+}
+
+static void test_cpu_destroy(void)
+{
+	int rc;
+	struct uv_cb_nodata uvcb = {
+		.header.len = sizeof(uvcb),
+		.header.cmd = UVC_CMD_DESTROY_SEC_CPU,
+		.handle = uvcb_csc.cpu_handle,
+	};
+
+	report_prefix_push("dcpu");
+
+	uvcb.header.len -= 8;
+	rc = uv_call(0, (uint64_t)&uvcb);
+	report(rc == 1 && uvcb.header.rc == UVC_RC_INV_LEN,
+	       "hdr invalid length");
+	uvcb.header.len += 8;
+
+	uvcb.handle += 1;
+	rc = uv_call(0, (uint64_t)&uvcb);
+	report(rc == 1 && uvcb.header.rc == UVC_RC_INV_CHANDLE, "invalid handle");
+	uvcb.handle -= 1;
+
+	rc = uv_call(0, (uint64_t)&uvcb);
+	report(rc == 0 && uvcb.header.rc == UVC_RC_EXECUTED, "success");
+
+	report_prefix_pop();
+}
+
+static void test_cpu_create(void)
+{
+	int rc;
+	unsigned long tmp;
+
+	report_prefix_push("csc");
+	uvcb_csc.header.len = sizeof(uvcb_csc);
+	uvcb_csc.header.cmd = UVC_CMD_CREATE_SEC_CPU;
+	uvcb_csc.guest_handle = uvcb_cgc.guest_handle;
+	uvcb_csc.stor_origin = (unsigned long)memalign(PAGE_SIZE, uvcb_qui.cpu_stor_len);
+	uvcb_csc.state_origin = (unsigned long)memalign(PAGE_SIZE, PAGE_SIZE);
+
+	uvcb_csc.header.len -= 8;
+	rc = uv_call(0, (uint64_t)&uvcb_csc);
+	report(uvcb_csc.header.rc == UVC_RC_INV_LEN && rc == 1 &&
+	       !uvcb_csc.cpu_handle, "hdr invalid length");
+	uvcb_csc.header.len += 8;
+
+	uvcb_csc.guest_handle += 1;
+	rc = uv_call(0, (uint64_t)&uvcb_csc);
+	report(uvcb_csc.header.rc == UVC_RC_INV_GHANDLE && rc == 1,
+	       "invalid guest handle");
+	uvcb_csc.guest_handle -= 1;
+
+	uvcb_csc.num = uvcb_qui.max_guest_cpus + 1;
+	rc = uv_call(0, (uint64_t)&uvcb_csc);
+	report(uvcb_csc.header.rc == 0x103 && rc == 1,
+	       "invalid cpu #");
+	uvcb_csc.num = 0;
+
+	tmp = uvcb_csc.stor_origin;
+	uvcb_csc.stor_origin = get_max_ram_size() + PAGE_SIZE;
+	rc = uv_call(0, (uint64_t)&uvcb_csc);
+	report(uvcb_csc.header.rc == 0x105 && rc == 1,
+	       "cpu stor inaccessible");
+	uvcb_csc.stor_origin = tmp;
+
+	tmp = uvcb_csc.stor_origin;
+	uvcb_csc.stor_origin = 0;
+	rc = uv_call(0, (uint64_t)&uvcb_csc);
+	report(uvcb_csc.header.rc == 0x106 && rc == 1,
+	       "cpu stor in lowcore");
+	uvcb_csc.stor_origin = tmp;
+
+	tmp = uvcb_csc.state_origin;
+	uvcb_csc.state_origin = get_max_ram_size() + PAGE_SIZE;
+	rc = uv_call(0, (uint64_t)&uvcb_csc);
+	report(uvcb_csc.header.rc == 0x107 && rc == 1,
+	       "SIE SD inaccessible");
+	uvcb_csc.state_origin = tmp;
+
+	rc = uv_call(0, (uint64_t)&uvcb_csc);
+	report(rc == 0 && uvcb_csc.header.rc == UVC_RC_EXECUTED &&
+	       uvcb_csc.cpu_handle, "success");
+
+	tmp = uvcb_csc.stor_origin;
+	uvcb_csc.stor_origin = (unsigned long)memalign(PAGE_SIZE, uvcb_qui.cpu_stor_len);
+	rc = uv_call(0, (uint64_t)&uvcb_csc);
+	report(rc == 1 && uvcb_csc.header.rc == 0x104, "already defined");
+	uvcb_csc.stor_origin = tmp;
+	report_prefix_pop();
+}
+
+static void test_config_create(void)
+{
+	int rc;
+	unsigned long vsize, tmp;
+	static struct uv_cb_cgc uvcb;
+
+	uvcb_cgc.header.cmd = UVC_CMD_CREATE_SEC_CONF;
+	uvcb_cgc.header.len = sizeof(uvcb_cgc);
+	report_prefix_push("cgc");
+
+	uvcb_cgc.guest_stor_origin = 0;
+	uvcb_cgc.guest_stor_len = 42 * (1UL << 20);
+	vsize = uvcb_qui.conf_base_virt_stor_len +
+		((uvcb_cgc.guest_stor_len / (1UL << 20)) * uvcb_qui.conf_virt_var_stor_len);
+
+	uvcb_cgc.conf_base_stor_origin = (uint64_t)memalign(PAGE_SIZE * 4, uvcb_qui.conf_base_phys_stor_len);
+	uvcb_cgc.conf_var_stor_origin = (uint64_t)memalign(PAGE_SIZE, vsize);
+	uvcb_cgc.guest_asce = (uint64_t)memalign(PAGE_SIZE, 4 * PAGE_SIZE) | ASCE_DT_SEGMENT | REGION_TABLE_LENGTH | ASCE_P;
+	uvcb_cgc.guest_sca = (uint64_t)memalign(PAGE_SIZE * 4, PAGE_SIZE * 4);
+
+	uvcb_cgc.header.len -= 8;
+	rc = uv_call(0, (uint64_t)&uvcb_cgc);
+	report(uvcb_cgc.header.rc == UVC_RC_INV_LEN && rc == 1 &&
+	       !uvcb_cgc.guest_handle, "hdr invalid length");
+	uvcb_cgc.header.len += 8;
+
+	uvcb_cgc.guest_stor_origin = uvcb_qui.max_guest_stor_addr + (1UL << 20) * 2 + 1;
+	rc = uv_call(0, (uint64_t)&uvcb_cgc);
+	report(uvcb_cgc.header.rc == 0x101 && rc == 1,
+	       "MSO > max guest addr");
+	uvcb_cgc.guest_stor_origin = 0;
+
+	uvcb_cgc.guest_stor_origin = uvcb_qui.max_guest_stor_addr - (1UL << 20);
+	rc = uv_call(0, (uint64_t)&uvcb_cgc);
+	report(uvcb_cgc.header.rc == 0x102 && rc == 1,
+	       "MSO + MSL > max guest addr");
+	uvcb_cgc.guest_stor_origin = 0;
+
+	uvcb_cgc.guest_asce &= ~ASCE_P;
+	rc = uv_call(0, (uint64_t)&uvcb_cgc);
+	report(uvcb_cgc.header.rc == 0x105 && rc == 1,
+	       "ASCE private bit missing");
+	uvcb_cgc.guest_asce |= ASCE_P;
+
+	uvcb_cgc.guest_asce |= 0x20;
+	rc = uv_call(0, (uint64_t)&uvcb_cgc);
+	report(uvcb_cgc.header.rc == 0x105 && rc == 1,
+	       "ASCE bit 58 set");
+	uvcb_cgc.guest_asce &= ~0x20;
+
+	tmp = uvcb_cgc.conf_base_stor_origin;
+	uvcb_cgc.conf_base_stor_origin = get_max_ram_size() + 8;
+	rc = uv_call(0, (uint64_t)&uvcb_cgc);
+	report(uvcb_cgc.header.rc == 0x108 && rc == 1,
+	       "base storage origin > available memory");
+	uvcb_cgc.conf_base_stor_origin = tmp;
+
+	tmp = uvcb_cgc.conf_base_stor_origin;
+	uvcb_cgc.conf_base_stor_origin = 0x1000;
+	rc = uv_call(0, (uint64_t)&uvcb_cgc);
+	report(uvcb_cgc.header.rc == 0x109 && rc == 1,
+	       "base storage origin contains lowcore");
+	uvcb_cgc.conf_base_stor_origin = tmp;
+
+	if (smp_query_num_cpus() == 1) {
+		sigp_retry(1, SIGP_SET_PREFIX,
+			   uvcb_cgc.conf_var_stor_origin + PAGE_SIZE, NULL);
+		rc = uv_call(0, (uint64_t)&uvcb_cgc);
+		report(uvcb_cgc.header.rc == 0x10e && rc == 1 &&
+		       !uvcb_cgc.guest_handle, "variable storage area contains lowcore");
+		sigp_retry(1, SIGP_SET_PREFIX, 0x0, NULL);
+	}
+
+	tmp = uvcb_cgc.guest_sca;
+	uvcb_cgc.guest_sca = 0;
+	rc = uv_call(0, (uint64_t)&uvcb_cgc);
+	report(uvcb_cgc.header.rc == 0x10c && rc == 1,
+	       "sca == 0");
+	uvcb_cgc.guest_sca = tmp;
+
+	tmp = uvcb_cgc.guest_sca;
+	uvcb_cgc.guest_sca = get_max_ram_size() + + PAGE_SIZE * 4;
+	rc = uv_call(0, (uint64_t)&uvcb_cgc);
+	report(uvcb_cgc.header.rc == 0x10d && rc == 1,
+	       "sca inaccessible");
+	uvcb_cgc.guest_sca = tmp;
+
+	rc = uv_call(0, (uint64_t)&uvcb_cgc);
+	report(rc == 0 && uvcb_cgc.header.rc == UVC_RC_EXECUTED, "successful");
+
+	uvcb_cgc.header.rc = 0;
+	uvcb_cgc.header.rrc = 0;
+	tmp = uvcb_cgc.guest_handle;
+	uvcb_cgc.guest_handle = 0;
+	rc = uv_call(0, (uint64_t)&uvcb_cgc);
+	report(uvcb_cgc.header.rc >= 0x100 && rc == 1, "reuse uvcb");
+	uvcb_cgc.guest_handle = tmp;
+
+	/* Copy over most data from uvcb_cgc, so we have the ASCE that was used. */
+	memcpy(&uvcb, &uvcb_cgc, sizeof(uvcb));
+
+	/* Reset the header and handle */
+	uvcb.header.rc = 0;
+	uvcb.header.rrc = 0;
+	uvcb.guest_handle = 0;
+
+	/* Use new storage areas. */
+	uvcb.conf_base_stor_origin = (uint64_t)memalign(PAGE_SIZE * 4, uvcb_qui.conf_base_phys_stor_len);
+	uvcb.conf_var_stor_origin = (uint64_t)memalign(PAGE_SIZE, vsize);
+
+	rc = uv_call(0, (uint64_t)&uvcb);
+	report(uvcb.header.rc >= 0x104 && rc == 1 && !uvcb.guest_handle,
+	       "reuse ASCE");
+	free((void *)uvcb.conf_base_stor_origin);
+	free((void *)uvcb.conf_var_stor_origin);
+
+	/* Missing: 106, 10a, a0b */
+	report_prefix_pop();
+}
+
+static void test_init(void)
+{
+	int rc;
+	uint64_t mem;
+	struct psw psw;
+
+	/* Donated storage needs to be over 2GB */
+	mem = (uint64_t)memalign(1UL << 31, uvcb_qui.uv_base_stor_len);
+
+	uvcb_init.header.len = sizeof(uvcb_init);
+	uvcb_init.header.cmd = UVC_CMD_INIT_UV;
+	uvcb_init.stor_origin = mem;
+	uvcb_init.stor_len = uvcb_qui.uv_base_stor_len;
+
+	report_prefix_push("init");
+	uvcb_init.header.len -= 8;
+	rc = uv_call(0, (uint64_t)&uvcb_init);
+	report(rc == 1 && uvcb_init.header.rc == UVC_RC_INV_LEN,
+	       "hdr invalid length");
+	uvcb_init.header.len += 8;
+
+	uvcb_init.stor_len -= 8;
+	rc = uv_call(0, (uint64_t)&uvcb_init);
+	report(rc == 1 && uvcb_init.header.rc == 0x103,
+	       "storage invalid length");
+	uvcb_init.stor_len += 8;
+
+	uvcb_init.stor_origin =  get_max_ram_size() + 8;
+	rc = uv_call(0, (uint64_t)&uvcb_init);
+	report(rc == 1 && uvcb_init.header.rc == 0x104,
+	       "storage origin invalid");
+	uvcb_init.stor_origin = mem;
+
+	uvcb_init.stor_origin = get_max_ram_size() - 8;
+	rc = uv_call(0, (uint64_t)&uvcb_init);
+	report(rc == 1 && uvcb_init.header.rc == 0x105,
+	       "storage + length invalid");
+	uvcb_init.stor_origin = mem;
+
+	uvcb_init.stor_origin = 1UL << 30;
+	rc = uv_call(0, (uint64_t)&uvcb_init);
+	report(rc == 1 && uvcb_init.header.rc == 0x108,
+	       "storage below 2GB");
+	uvcb_init.stor_origin = mem;
+
+	psw.mask = extract_psw_mask();
+	psw.addr = (unsigned long)cpu_loop;
+	smp_cpu_setup(1, psw);
+	rc = uv_call(0, (uint64_t)&uvcb_init);
+	report(rc == 1 && uvcb_init.header.rc == 0x102,
+	       "too many running cpus");
+	smp_cpu_stop(1);
+
+	rc = uv_call(0, (uint64_t)&uvcb_init);
+	report(rc == 0 && uvcb_init.header.rc == UVC_RC_EXECUTED, "successful");
+
+	mem = (uint64_t)memalign(1UL << 31, uvcb_qui.uv_base_stor_len);
+	rc = uv_call(0, (uint64_t)&uvcb_init);
+	report(rc == 1 && uvcb_init.header.rc == 0x101, "double init");
+	free((void *)mem);
+
+	report_prefix_pop();
+}
+
+static void test_query(void)
+{
+	int i = 0;
+
+	uvcb_qui.header.cmd = UVC_CMD_QUI;
+	uvcb_qui.header.len = sizeof(uvcb_qui);
+
+	report_prefix_push("query");
+	uvcb_qui.header.len = 0xa0;
+	uv_call(0, (uint64_t)&uvcb_qui);
+	report(uvcb_qui.header.rc == UVC_RC_INV_LEN, "length");
+
+	uvcb_qui.header.len = 0xa8;
+	uv_call(0, (uint64_t)&uvcb_qui);
+	report(uvcb_qui.header.rc == 0x100, "insf length");
+
+	uvcb_qui.header.len = sizeof(uvcb_qui);
+	uv_call(0, (uint64_t)&uvcb_qui);
+	report(uvcb_qui.header.rc == UVC_RC_EXECUTED, "successful query");
+
+	for (i = 0; cmds[i].name; i++)
+		report(uv_query_test_call(cmds[i].call_bit), "%s", cmds[i].name);
+
+	report_prefix_pop();
+}
+
+static struct cmd_list invalid_cmds[] = {
+	{ "bogus", 0x4242, sizeof(struct uv_cb_header), -1},
+	{ "share", UVC_CMD_SET_SHARED_ACCESS, sizeof(struct uv_cb_share), BIT_UVC_CMD_SET_SHARED_ACCESS },
+	{ "unshare", UVC_CMD_REMOVE_SHARED_ACCESS, sizeof(struct uv_cb_share), BIT_UVC_CMD_REMOVE_SHARED_ACCESS },
+	{ NULL, 0, 0 },
+};
+
+static void test_invalid(void)
+{
+	struct uv_cb_header hdr = {};
+	int i, cc;
+
+	report_prefix_push("invalid");
+	for (i = 0; invalid_cmds[i].name; i++) {
+		hdr.cmd = invalid_cmds[i].cmd;
+		hdr.len = invalid_cmds[i].len;
+		cc = uv_call(0, (uint64_t)&hdr);
+		report(cc == 1 && hdr.rc == UVC_RC_INV_CMD &&
+		       (invalid_cmds[i].call_bit == -1 || !uv_query_test_call(invalid_cmds[i].call_bit)),
+		       "%s", invalid_cmds[i].name);
+	}
+	report_prefix_pop();
+}
+
+static void test_clear(void)
+{
+	uint64_t *tmp = (void *)uvcb_init.stor_origin;
+
+	diag308_load_reset(1);
+	sclp_console_setup();
+	report(!*tmp, "memory cleared after reset 1");
+}
+
+static void setup_vmem(void)
+{
+	uint64_t asce, mask;
+
+	setup_mmu(get_max_ram_size());
+	asce = stctg(1);
+	lctlg(13, asce);
+	mask = extract_psw_mask() | 0x0000C00000000000UL;
+	load_psw_mask(mask);
+}
+
+int main(void)
+{
+	bool has_uvc = test_facility(158);
+
+	report_prefix_push("uvc");
+	if (!has_uvc) {
+		report_skip("Ultravisor call facility is not available");
+		goto done;
+	}
+
+	test_priv();
+	test_invalid();
+	test_query();
+	test_init();
+
+	setup_vmem();
+	test_config_create();
+	test_cpu_create();
+	test_cpu_destroy();
+	test_config_destroy();
+	test_clear();
+
+done:
+	return report_summary();
+}
